<html>
<head>
<title>config.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">Optional</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">jax_jit</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">transfer_guard_lib</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">bool_env(varname: str</span><span class="s2">, </span><span class="s1">default: bool) -&gt; bool:</span>
  <span class="s3">&quot;&quot;&quot;Read an environment variable and interpret it as a boolean. 
 
  True values are (case insensitive): 'y', 'yes', 't', 'true', 'on', and '1'; 
  false values are 'n', 'no', 'f', 'false', 'off', and '0'. 
 
  Args: 
    varname: the name of the variable 
    default: the default boolean value 
  Raises: ValueError if the environment variable is anything else. 
  &quot;&quot;&quot;</span>
  <span class="s1">val = os.getenv(varname</span><span class="s2">, </span><span class="s1">str(default))</span>
  <span class="s1">val = val.lower()</span>
  <span class="s2">if </span><span class="s1">val </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'y'</span><span class="s2">, </span><span class="s4">'yes'</span><span class="s2">, </span><span class="s4">'t'</span><span class="s2">, </span><span class="s4">'true'</span><span class="s2">, </span><span class="s4">'on'</span><span class="s2">, </span><span class="s4">'1'</span><span class="s1">):</span>
    <span class="s2">return True</span>
  <span class="s2">elif </span><span class="s1">val </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'n'</span><span class="s2">, </span><span class="s4">'no'</span><span class="s2">, </span><span class="s4">'f'</span><span class="s2">, </span><span class="s4">'false'</span><span class="s2">, </span><span class="s4">'off'</span><span class="s2">, </span><span class="s4">'0'</span><span class="s1">):</span>
    <span class="s2">return False</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;invalid truth value </span><span class="s2">{</span><span class="s1">val</span><span class="s2">!r} </span><span class="s4">for environment </span><span class="s2">{</span><span class="s1">varname</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">int_env(varname: str</span><span class="s2">, </span><span class="s1">default: int) -&gt; int:</span>
  <span class="s3">&quot;&quot;&quot;Read an environment variable and interpret it as an integer.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">int(os.getenv(varname</span><span class="s2">, </span><span class="s1">str(default)))</span>


<span class="s1">UPGRADE_BOOL_HELP = (</span>
    <span class="s4">&quot; This will be enabled by default in future versions of JAX, at which &quot;</span>
    <span class="s4">&quot;point all uses of the flag will be considered deprecated (following &quot;</span>
    <span class="s4">&quot;the `API compatibility policy &quot;</span>
    <span class="s4">&quot;&lt;https://jax.readthedocs.io/en/latest/api_compatibility.html&gt;`_).&quot;</span><span class="s1">)</span>

<span class="s1">UPGRADE_BOOL_EXTRA_DESC = </span><span class="s4">&quot; (transient)&quot;</span>


<span class="s2">class </span><span class="s1">Config:</span>
  <span class="s1">_HAS_DYNAMIC_ATTRIBUTES = </span><span class="s2">True</span>

  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.values = {}</span>
    <span class="s1">self.meta = {}</span>
    <span class="s1">self.FLAGS = NameSpace(self.read</span><span class="s2">, </span><span class="s1">self.update)</span>
    <span class="s1">self.use_absl = </span><span class="s2">False</span>
    <span class="s1">self._contextmanager_flags = set()</span>
    <span class="s1">self._update_hooks = {}</span>

  <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">self.check_exists(name)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.values:</span>
      <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">f&quot;Unrecognized config option: </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">self.values[name] = val</span>

    <span class="s1">hook = self._update_hooks.get(name</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">hook:</span>
      <span class="s1">hook(val)</span>

  <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._contextmanager_flags:</span>
      <span class="s2">raise </span><span class="s1">AttributeError(</span>
          <span class="s4">&quot;For flags with a corresponding contextmanager, read their value &quot;</span>
          <span class="s4">f&quot;via e.g. `config.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">` rather than `config.FLAGS.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">`.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">self._read(name)</span>

  <span class="s2">def </span><span class="s1">_read(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">self.values[name]</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
      <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">f&quot;Unrecognized config option: </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">add_option(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">opt_type</span><span class="s2">, </span><span class="s1">meta_args</span><span class="s2">, </span><span class="s1">meta_kwargs</span><span class="s2">,</span>
                 <span class="s1">update_hook: Optional[Callable[[Any]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.values:</span>
      <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">f&quot;Config option </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">already defined&quot;</span><span class="s1">)</span>
    <span class="s1">self.values[name] = default</span>
    <span class="s1">self.meta[name] = (opt_type</span><span class="s2">, </span><span class="s1">meta_args</span><span class="s2">, </span><span class="s1">meta_kwargs)</span>
    <span class="s2">if </span><span class="s1">update_hook:</span>
      <span class="s1">self._update_hooks[name] = update_hook</span>
      <span class="s1">update_hook(default)</span>

  <span class="s2">def </span><span class="s1">check_exists(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.values:</span>
      <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">f&quot;Unrecognized config option: </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">DEFINE_bool(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">update_hook = kwargs.pop(</span><span class="s4">&quot;update_hook&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">self.add_option(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">update_hook=update_hook)</span>

  <span class="s2">def </span><span class="s1">DEFINE_integer(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">update_hook = kwargs.pop(</span><span class="s4">&quot;update_hook&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">self.add_option(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">update_hook=update_hook)</span>

  <span class="s2">def </span><span class="s1">DEFINE_float(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">update_hook = kwargs.pop(</span><span class="s4">&quot;update_hook&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">self.add_option(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">update_hook=update_hook)</span>

  <span class="s2">def </span><span class="s1">DEFINE_string(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">update_hook = kwargs.pop(</span><span class="s4">&quot;update_hook&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">self.add_option(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">update_hook=update_hook)</span>

  <span class="s2">def </span><span class="s1">DEFINE_enum(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">update_hook = kwargs.pop(</span><span class="s4">&quot;update_hook&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">self.add_option(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s4">'enum'</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">,</span>
                    <span class="s1">update_hook=update_hook)</span>

  <span class="s2">def </span><span class="s1">config_with_absl(self):</span>
    <span class="s0"># Run this before calling `app.run(main)` etc</span>
    <span class="s2">import </span><span class="s1">absl.flags </span><span class="s2">as </span><span class="s1">absl_FLAGS  </span><span class="s0"># noqa: F401  # pytype: disable=import-error</span>
    <span class="s2">from </span><span class="s1">absl </span><span class="s2">import </span><span class="s1">app</span><span class="s2">, </span><span class="s1">flags </span><span class="s2">as </span><span class="s1">absl_flags  </span><span class="s0"># pytype: disable=import-error</span>

    <span class="s1">self.use_absl = </span><span class="s2">True</span>
    <span class="s1">self.absl_flags = absl_flags</span>
    <span class="s1">absl_defs = { bool: absl_flags.DEFINE_bool</span><span class="s2">,</span>
                  <span class="s1">int:  absl_flags.DEFINE_integer</span><span class="s2">,</span>
                  <span class="s1">float: absl_flags.DEFINE_float</span><span class="s2">,</span>
                  <span class="s1">str:  absl_flags.DEFINE_string</span><span class="s2">,</span>
                  <span class="s4">'enum'</span><span class="s1">: absl_flags.DEFINE_enum }</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.values.items():</span>
      <span class="s1">flag_type</span><span class="s2">, </span><span class="s1">meta_args</span><span class="s2">, </span><span class="s1">meta_kwargs = self.meta[name]</span>
      <span class="s1">absl_defs[flag_type](name</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">*meta_args</span><span class="s2">, </span><span class="s1">**meta_kwargs)</span>
    <span class="s1">app.call_after_init(</span><span class="s2">lambda</span><span class="s1">: self.complete_absl_config(absl_flags))</span>

  <span class="s2">def </span><span class="s1">complete_absl_config(self</span><span class="s2">, </span><span class="s1">absl_flags):</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.values.items():</span>
      <span class="s1">flag = absl_flags.FLAGS[name]</span>
      <span class="s2">if </span><span class="s1">flag.present:</span>
        <span class="s1">self.update(name</span><span class="s2">, </span><span class="s1">flag.value)</span>

  <span class="s2">def </span><span class="s1">parse_flags_with_absl(self):</span>
    <span class="s2">global </span><span class="s1">already_configured_with_absl</span>
    <span class="s2">if not </span><span class="s1">already_configured_with_absl:</span>
      <span class="s0"># Extract just the --jax... flags (before the first --) from argv. In some</span>
      <span class="s0"># environments (e.g. ipython/colab) argv might be a mess of things</span>
      <span class="s0"># parseable by absl and other junk.</span>
      <span class="s1">jax_argv = itertools.takewhile(</span><span class="s2">lambda </span><span class="s1">a: a != </span><span class="s4">'--'</span><span class="s2">, </span><span class="s1">sys.argv)</span>
      <span class="s1">jax_argv = [</span><span class="s4">''</span><span class="s2">, </span><span class="s1">*(a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">jax_argv </span><span class="s2">if </span><span class="s1">a.startswith(</span><span class="s4">'--jax'</span><span class="s1">))]</span>

      <span class="s2">import </span><span class="s1">absl.flags  </span><span class="s0"># pytype: disable=import-error</span>
      <span class="s1">self.config_with_absl()</span>
      <span class="s1">absl.flags.FLAGS(jax_argv</span><span class="s2">, </span><span class="s1">known_only=</span><span class="s2">True</span><span class="s1">)</span>
      <span class="s1">self.complete_absl_config(absl.flags)</span>
      <span class="s1">already_configured_with_absl = </span><span class="s2">True</span>

  <span class="s2">def </span><span class="s1">define_bool_state(</span>
    <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">default: bool</span><span class="s2">, </span><span class="s1">help: str</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s1">update_global_hook: Optional[Callable[[bool]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
    <span class="s1">update_thread_local_hook: Optional[Callable[[Optional[bool]]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
    <span class="s1">upgrade: bool = </span><span class="s2">False,</span>
    <span class="s1">extra_description: str = </span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
 
    This function is a convenience wrapper. It defines a flag, environment 
    variable, and corresponding thread-local state, which can be managed via the 
    contextmanager it returns. 
 
    The thread-local state value can be read via the ``config.&lt;option_name&gt;`` 
    attribute, where ``config`` is the singleton ``Config`` instance. 
 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      default: boolean, a default value for the option. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
      update_global_hook: a optional callback that is called with the updated 
        value of the global state when it is altered or set initially. 
      update_thread_local_hook: a optional callback that is called with the 
        updated value of the thread-local state when it is altered or set 
        initially. 
      upgrade: optional indicator that this flag controls a canonical feature 
        upgrade, so that it is `True` for the incoming functionality, `False` 
        for the outgoing functionality to be deprecated. 
      extra_description: string, optional: extra information to add to the 
        summary description. 
 
    Returns: 
      A contextmanager to control the thread-local state value. 
 
    Example: 
 
      enable_foo = config.define_bool_state( 
          name='jax_enable_foo', 
          default=False, 
          help='Enable foo.') 
 
      # Now the JAX_ENABLE_FOO shell environment variable and --jax_enable_foo 
      # command-line flag can be used to control the process-level value of 
      # the configuration option, in addition to using e.g. 
      # ``config.update(&quot;jax_enable_foo&quot;, True)`` directly. We can also use a 
      # context manager: 
 
      with enable_foo(True): 
        ... 
 
    The value of the thread-local state or flag can be accessed via 
    ``config.jax_enable_foo``. Reading it via ``config.FLAGS.jax_enable_foo`` is 
    an error. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">name = name.lower()</span>
    <span class="s2">if </span><span class="s1">upgrade:</span>
      <span class="s1">help += </span><span class="s4">' ' </span><span class="s1">+ UPGRADE_BOOL_HELP</span>
      <span class="s1">extra_description += UPGRADE_BOOL_EXTRA_DESC</span>
    <span class="s1">self.DEFINE_bool(name</span><span class="s2">, </span><span class="s1">bool_env(name.upper()</span><span class="s2">, </span><span class="s1">default)</span><span class="s2">, </span><span class="s1">help</span><span class="s2">,</span>
                     <span class="s1">update_hook=update_global_hook)</span>
    <span class="s1">self._contextmanager_flags.add(name)</span>

    <span class="s2">def </span><span class="s1">get_state(self):</span>
      <span class="s1">val = _thread_local_state.__dict__.get(name</span><span class="s2">, </span><span class="s1">unset)</span>
      <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is not </span><span class="s1">unset </span><span class="s2">else </span><span class="s1">self._read(name)</span>
    <span class="s1">setattr(Config</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(get_state))</span>

    <span class="s2">return </span><span class="s1">_StateContextManager(name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">,</span>
                                <span class="s1">extra_description=extra_description</span><span class="s2">,</span>
                                <span class="s1">default_value=</span><span class="s2">True</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">define_enum_state(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">enum_values: List[str]</span><span class="s2">, </span><span class="s1">default: Optional[str]</span><span class="s2">,</span>
      <span class="s1">help: str</span><span class="s2">, </span><span class="s1">update_global_hook: Optional[Callable[[str]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">update_thread_local_hook: Optional[Callable[[Optional[str]]</span><span class="s2">, None</span><span class="s1">]] \</span>
        <span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      enum_values: list of strings representing the possible values for the 
        option. 
      default: optional string, default value. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
    Returns: 
      A contextmanager to control the thread-local state value. 
    See docstring for ``define_bool_state``. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = name.lower()</span>
    <span class="s1">default = os.getenv(name.upper()</span><span class="s2">, </span><span class="s1">default)</span>
    <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None and </span><span class="s1">default </span><span class="s2">not in </span><span class="s1">enum_values:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid value </span><span class="s2">\&quot;{</span><span class="s1">default</span><span class="s2">}\&quot; </span><span class="s4">for JAX flag </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">self.DEFINE_enum(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">,</span>
                     <span class="s1">enum_values=enum_values</span><span class="s2">, </span><span class="s1">help=help</span><span class="s2">,</span>
                     <span class="s1">update_hook=update_global_hook)</span>
    <span class="s1">self._contextmanager_flags.add(name)</span>

    <span class="s2">def </span><span class="s1">get_state(self):</span>
      <span class="s1">val = _thread_local_state.__dict__.get(name</span><span class="s2">, </span><span class="s1">unset)</span>
      <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is not </span><span class="s1">unset </span><span class="s2">else </span><span class="s1">self._read(name)</span>
    <span class="s1">setattr(Config</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(get_state))</span>

    <span class="s2">def </span><span class="s1">validate(new_val):</span>
      <span class="s2">if </span><span class="s1">(new_val </span><span class="s2">is not None and</span>
          <span class="s1">(type(new_val) </span><span class="s2">is not </span><span class="s1">str </span><span class="s2">or </span><span class="s1">new_val </span><span class="s2">not in </span><span class="s1">enum_values)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;new enum value must be None or in </span><span class="s2">{</span><span class="s1">enum_values</span><span class="s2">}</span><span class="s4">, &quot;</span>
                         <span class="s4">f&quot;got </span><span class="s2">{</span><span class="s1">new_val</span><span class="s2">} </span><span class="s4">of type </span><span class="s2">{</span><span class="s1">type(new_val)</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_StateContextManager(name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">, </span><span class="s1">validate)</span>

  <span class="s2">def </span><span class="s1">define_int_state(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">default: Optional[int]</span><span class="s2">,</span>
      <span class="s1">help: str</span><span class="s2">, </span><span class="s1">update_global_hook: Optional[Callable[[str]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">update_thread_local_hook: Optional[Callable[[Optional[str]]</span><span class="s2">, None</span><span class="s1">]] \</span>
        <span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      enum_values: list of strings representing the possible values for the 
        option. 
      default: optional int, default value. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
    Returns: 
      A contextmanager to control the thread-local state value. 
    See docstring for ``define_bool_state``. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = name.lower()</span>
    <span class="s1">default_env = os.getenv(name.upper()</span><span class="s2">, </span><span class="s1">default)</span>
    <span class="s2">if </span><span class="s1">default_env </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">default = int(default_env)</span>
      <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid value </span><span class="s2">\&quot;{</span><span class="s1">default_env</span><span class="s2">}\&quot; </span><span class="s4">for JAX flag </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">self.DEFINE_integer(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">help=help</span><span class="s2">, </span><span class="s1">update_hook=update_global_hook)</span>
    <span class="s1">self._contextmanager_flags.add(name)</span>

    <span class="s2">def </span><span class="s1">get_state(self):</span>
      <span class="s1">val = _thread_local_state.__dict__.get(name</span><span class="s2">, </span><span class="s1">unset)</span>
      <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is not </span><span class="s1">unset </span><span class="s2">else </span><span class="s1">self._read(name)</span>
    <span class="s1">setattr(Config</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(get_state))</span>

    <span class="s2">def </span><span class="s1">validate(new_val):</span>
      <span class="s2">if </span><span class="s1">new_val </span><span class="s2">is not None and not </span><span class="s1">isinstance(new_val</span><span class="s2">, </span><span class="s1">int):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'new int config value must be None or of type int, '</span>
                         <span class="s4">f'got </span><span class="s2">{</span><span class="s1">new_val</span><span class="s2">} </span><span class="s4">of type </span><span class="s2">{</span><span class="s1">type(new_val)</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_StateContextManager(name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">, </span><span class="s1">validate)</span>

  <span class="s2">def </span><span class="s1">define_float_state(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">default: Optional[float]</span><span class="s2">,</span>
      <span class="s1">help: str</span><span class="s2">, </span><span class="s1">update_global_hook: Optional[Callable[[str]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">update_thread_local_hook: Optional[Callable[[Optional[str]]</span><span class="s2">, None</span><span class="s1">]] \</span>
        <span class="s1">= </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      enum_values: list of strings representing the possible values for the 
        option. 
      default: optional float, default value. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
    Returns: 
      A contextmanager to control the thread-local state value. 
    See docstring for ``define_bool_state``. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = name.lower()</span>
    <span class="s1">default_env = os.getenv(name.upper()</span><span class="s2">, </span><span class="s1">default)</span>
    <span class="s2">if </span><span class="s1">default_env </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">default = float(default_env)</span>
      <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid value </span><span class="s2">\&quot;{</span><span class="s1">default_env</span><span class="s2">}\&quot; </span><span class="s4">for JAX flag </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">self.DEFINE_float(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">help=help</span><span class="s2">, </span><span class="s1">update_hook=update_global_hook)</span>
    <span class="s1">self._contextmanager_flags.add(name)</span>

    <span class="s2">def </span><span class="s1">get_state(self):</span>
      <span class="s1">val = _thread_local_state.__dict__.get(name</span><span class="s2">, </span><span class="s1">unset)</span>
      <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is not </span><span class="s1">unset </span><span class="s2">else </span><span class="s1">self._read(name)</span>
    <span class="s1">setattr(Config</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(get_state))</span>

    <span class="s2">def </span><span class="s1">validate(new_val):</span>
      <span class="s2">if </span><span class="s1">new_val </span><span class="s2">is not None and not </span><span class="s1">isinstance(new_val</span><span class="s2">, </span><span class="s1">(float</span><span class="s2">, </span><span class="s1">int)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'new float config value must be None or of type float, '</span>
                         <span class="s4">f'got </span><span class="s2">{</span><span class="s1">new_val</span><span class="s2">} </span><span class="s4">of type </span><span class="s2">{</span><span class="s1">type(new_val)</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_StateContextManager(name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">, </span><span class="s1">validate)</span>

  <span class="s2">def </span><span class="s1">define_string_state(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">default: Optional[str]</span><span class="s2">, </span><span class="s1">help: str</span><span class="s2">,</span>
      <span class="s1">update_global_hook: Optional[Callable[[str]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">update_thread_local_hook: Optional[Callable[[Optional[str]]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
 
    See docstring for ``define_bool_state``. 
 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      default: string, a default value for the option. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
      update_global_hook: an optional callback that is called with the updated 
        value of the global state when it is altered or set initially. 
      update_thread_local_hook: an optional callback that is called with the 
        updated value of the thread-local state when it is altered or set 
        initially. 
 
    Returns: 
      A contextmanager to control the thread-local state value. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">validate(new_val):</span>
      <span class="s2">if </span><span class="s1">new_val </span><span class="s2">is not None and not </span><span class="s1">isinstance(new_val</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'new string config value must be None or of type str,'</span>
                         <span class="s4">f' got </span><span class="s2">{</span><span class="s1">new_val</span><span class="s2">} </span><span class="s4">of type </span><span class="s2">{</span><span class="s1">type(new_val)</span><span class="s2">}</span><span class="s4">.'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">self.define_string_or_object_state(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">help</span><span class="s2">,</span>
                                              <span class="s1">update_global_hook</span><span class="s2">,</span>
                                              <span class="s1">update_thread_local_hook</span><span class="s2">,</span>
                                              <span class="s1">validate)</span>

  <span class="s2">def </span><span class="s1">define_string_or_object_state(</span>
      <span class="s1">self</span><span class="s2">,</span>
      <span class="s1">name: str</span><span class="s2">,</span>
      <span class="s1">default: Any</span><span class="s2">,</span>
      <span class="s1">help: str</span><span class="s2">,</span>
      <span class="s1">update_global_hook: Optional[Callable[[Any]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">update_thread_local_hook: Optional[Callable[[Any]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
      <span class="s1">validate_new_val_hook: Optional[Callable[[Any]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;Set up thread-local state and return a contextmanager for managing it. 
 
    Similar to ``define_string_state``, except the context manager will accept 
    any object, not just a string. Any value passed via commandline flag or 
    environment variable will be treated as a string. 
 
    Args: 
      name: string, converted to lowercase to define the name of the config 
        option (and absl flag). It is converted to uppercase to define the 
        corresponding shell environment variable. 
      default: string, a default value for the option. 
      help: string, used to populate the flag help information as well as the 
        docstring of the returned context manager. 
      update_global_hook: an optional callback that is called with the updated 
        value of the global state when it is altered or set initially. 
      update_thread_local_hook: an optional callback that is called with the 
        updated value of the thread-local state when it is altered or set 
        initially. 
      validate_new_val_hook: an optional callback that is called with the new 
        value on any update, and should raise an error if the new value is 
        invalid. 
 
    Returns: 
      A contextmanager to control the thread-local state value. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = name.lower()</span>
    <span class="s1">default = os.getenv(name.upper()</span><span class="s2">, </span><span class="s1">default)</span>
    <span class="s1">self.DEFINE_string(name</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">help=help</span><span class="s2">,</span>
                       <span class="s1">update_hook=update_global_hook)</span>
    <span class="s1">self._contextmanager_flags.add(name)</span>

    <span class="s2">def </span><span class="s1">get_state(self):</span>
      <span class="s1">val = _thread_local_state.__dict__.get(name</span><span class="s2">, </span><span class="s1">unset)</span>
      <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">val </span><span class="s2">is not </span><span class="s1">unset </span><span class="s2">else </span><span class="s1">self._read(name)</span>
    <span class="s1">setattr(Config</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(get_state))</span>

    <span class="s2">return </span><span class="s1">_StateContextManager(name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">,</span>
                                <span class="s1">validate_new_val_hook)</span>

  <span class="s2">def </span><span class="s1">_trace_context(self):</span>
    <span class="s3">&quot;&quot;&quot;Returns a tuple of configuration values that affect tracing. 
 
    These values are included in the cache key for linear_util.cache. 
 
    Values included in this set should also most likely be included in 
    the C++ JIT state, which is handled separately.&quot;&quot;&quot;</span>
    <span class="s1">tls = jax_jit.thread_local_state()</span>
    <span class="s1">axis_env_state = ()</span>
    <span class="s1">mesh_context_manager = ()</span>
    <span class="s1">context = tls.extra_jit_context</span>
    <span class="s2">if </span><span class="s1">context </span><span class="s2">and </span><span class="s1">context.axis_env_state </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">axis_env_state = context.axis_env_state</span>
    <span class="s2">if </span><span class="s1">context </span><span class="s2">and </span><span class="s1">context.mesh_context_manager:</span>
      <span class="s1">mesh_context_manager = context.mesh_context_manager</span>
    <span class="s2">return </span><span class="s1">(axis_env_state</span><span class="s2">, </span><span class="s1">mesh_context_manager</span><span class="s2">, </span><span class="s1">self.x64_enabled</span><span class="s2">,</span>
            <span class="s1">self.jax_numpy_rank_promotion</span><span class="s2">, </span><span class="s1">self.jax_default_matmul_precision</span><span class="s2">,</span>
            <span class="s1">self.jax_dynamic_shapes</span><span class="s2">, </span><span class="s1">self.jax_numpy_dtype_promotion</span><span class="s2">,</span>
            <span class="s1">self.jax_default_device</span><span class="s2">, </span><span class="s1">self.jax_array</span><span class="s2">,</span>
            <span class="s1">self.jax_threefry_partitionable</span><span class="s2">,</span>
            <span class="s0"># Technically this affects jaxpr-&gt;MHLO lowering, not tracing.</span>
            <span class="s1">self.jax_hlo_source_file_canonicalization_regex)</span>

<span class="s2">class </span><span class="s1">NoDefault: </span><span class="s2">pass</span>
<span class="s1">no_default = NoDefault()</span>

<span class="s2">class </span><span class="s1">_StateContextManager:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">help</span><span class="s2">, </span><span class="s1">update_thread_local_hook</span><span class="s2">,</span>
               <span class="s1">validate_new_val_hook: Optional[Callable[[Any]</span><span class="s2">, None</span><span class="s1">]] = </span><span class="s2">None,</span>
               <span class="s1">extra_description: str = </span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">default_value: Any = no_default):</span>
    <span class="s1">self._name = name</span>
    <span class="s1">self.__name__ = name[</span><span class="s5">4</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">name.startswith(</span><span class="s4">'jax_'</span><span class="s1">) </span><span class="s2">else </span><span class="s1">name</span>
    <span class="s1">self.__doc__ = (</span><span class="s4">f&quot;Context manager for `</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">` config option&quot;</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">extra_description</span><span class="s2">}</span><span class="s4">.</span><span class="s2">\n\n{</span><span class="s1">help</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">self._update_thread_local_hook = update_thread_local_hook</span>
    <span class="s1">self._validate_new_val_hook = validate_new_val_hook</span>
    <span class="s1">self._default_value = default_value</span>

  <span class="s1">@contextlib.contextmanager</span>
  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">new_val: Any = no_default):</span>
    <span class="s2">if </span><span class="s1">new_val </span><span class="s2">is </span><span class="s1">no_default:</span>
      <span class="s2">if </span><span class="s1">self._default_value </span><span class="s2">is not </span><span class="s1">no_default:</span>
        <span class="s1">new_val = self._default_value  </span><span class="s0"># default_value provided to constructor</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># no default_value provided to constructor and no value provided as an</span>
        <span class="s0"># argument, so we raise an error</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Context manager for </span><span class="s2">{</span><span class="s1">self.__name__</span><span class="s2">} </span><span class="s4">config option &quot;</span>
                        <span class="s4">&quot;requires an argument representing the new value for &quot;</span>
                        <span class="s4">&quot;the config option.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">self._validate_new_val_hook:</span>
      <span class="s1">self._validate_new_val_hook(new_val)</span>
    <span class="s1">prev_val = getattr(_thread_local_state</span><span class="s2">, </span><span class="s1">self._name</span><span class="s2">, </span><span class="s1">unset)</span>
    <span class="s1">setattr(_thread_local_state</span><span class="s2">, </span><span class="s1">self._name</span><span class="s2">, </span><span class="s1">new_val)</span>
    <span class="s2">if </span><span class="s1">self._update_thread_local_hook:</span>
      <span class="s1">self._update_thread_local_hook(new_val)</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">prev_val </span><span class="s2">is </span><span class="s1">unset:</span>
        <span class="s1">delattr(_thread_local_state</span><span class="s2">, </span><span class="s1">self._name)</span>
        <span class="s2">if </span><span class="s1">self._update_thread_local_hook:</span>
          <span class="s1">self._update_thread_local_hook(</span><span class="s2">None</span><span class="s1">)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">setattr(_thread_local_state</span><span class="s2">, </span><span class="s1">self._name</span><span class="s2">, </span><span class="s1">prev_val)</span>
        <span class="s2">if </span><span class="s1">self._update_thread_local_hook:</span>
          <span class="s1">self._update_thread_local_hook(prev_val)</span>

  <span class="s2">def </span><span class="s1">_add_hooks(self</span><span class="s2">, </span><span class="s1">update_global_hook</span><span class="s2">, </span><span class="s1">update_thread_local_hook):</span>
    <span class="s3">&quot;&quot;&quot;Private method that adds hooks to an existing context-manager. 
 
    Used to avoid cyclic import dependencies.&quot;&quot;&quot;</span>
    <span class="s1">self._update_thread_local_hook = update_thread_local_hook</span>
    <span class="s1">config._update_hooks[self._name] = update_global_hook</span>
    <span class="s1">update_global_hook(config._read(self._name))</span>


<span class="s1">_thread_local_state = threading.local()</span>

<span class="s2">class </span><span class="s1">_Unset: </span><span class="s2">pass</span>
<span class="s1">unset = _Unset()</span>

<span class="s2">class </span><span class="s1">NameSpace:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">getter</span><span class="s2">, </span><span class="s1">setter):</span>
    <span class="s0"># must use super because we override this class's __setattr__, see</span>
    <span class="s0"># https://docs.python.org/3/reference/datamodel.html#object.__setattr__</span>
    <span class="s1">super().__setattr__(</span><span class="s4">'_getter'</span><span class="s2">, </span><span class="s1">getter)</span>
    <span class="s1">super().__setattr__(</span><span class="s4">'_setter'</span><span class="s2">, </span><span class="s1">setter)</span>

  <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s2">return </span><span class="s1">self._getter(name)</span>

  <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s1">self._setter(name</span><span class="s2">, </span><span class="s1">val)</span>


<span class="s1">config = Config()</span>
<span class="s1">flags = config</span>
<span class="s1">FLAGS = flags.FLAGS</span>

<span class="s1">already_configured_with_absl = </span><span class="s2">False</span>


<span class="s0"># The C++ JIT maintains its own copy of several configuration items as</span>
<span class="s0"># a global/thread-local state. These methods allow updates to part of the</span>
<span class="s0"># state when a configuration value changes.</span>
<span class="s2">class </span><span class="s1">_GlobalExtraJitContext(NamedTuple):</span>
  <span class="s1">numpy_rank_promotion: Optional[str] = </span><span class="s2">None</span>
  <span class="s1">numpy_dtype_promotion: Optional[str] = </span><span class="s2">None</span>
  <span class="s1">default_matmul_precision: Optional[Any] = </span><span class="s2">None</span>
  <span class="s1">dynamic_shapes: bool = </span><span class="s2">False</span>
  <span class="s1">threefry_partitionable: bool = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_update_global_jit_state(**kw):</span>
  <span class="s1">gs = jax_jit.global_state()</span>
  <span class="s1">context = gs.extra_jit_context </span><span class="s2">or </span><span class="s1">_GlobalExtraJitContext()</span>
  <span class="s1">gs.extra_jit_context = context._replace(**kw)</span>


<span class="s2">class </span><span class="s1">_ThreadLocalExtraJitContext(NamedTuple):</span>
  <span class="s3">&quot;&quot;&quot;&quot;A namedtuple containing states to add to the cache key. 
 
  Just in time compilation (for jit, pmap, etc) behavior is configurable through 
  global and thread-local options, used in the cache key. 
 
  The initialization, which uses both config.py and core.py is done using 
  `_update_thread_local_jit_state` in core.py to prevent circular imports. 
  &quot;&quot;&quot;</span>
  <span class="s1">dynamic_trace_state: Optional[Any] = </span><span class="s2">None</span>
  <span class="s1">axis_env_state: Hashable = ()</span>
  <span class="s1">mesh_context_manager: Hashable = ()</span>
  <span class="s1">numpy_rank_promotion: Optional[str] = </span><span class="s2">None</span>
  <span class="s1">numpy_dtype_promotion: Optional[str] = </span><span class="s2">None</span>
  <span class="s1">default_matmul_precision: Optional[Any] = </span><span class="s2">None</span>
  <span class="s1">dynamic_shapes: bool = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">_ThreadLocalStateCache(threading.local):</span>
  <span class="s3">&quot;&quot;&quot;&quot;A thread local cache for _ThreadLocalExtraJitContext 
 
  The extra_jit_context in jax_jit.thread_local_state() may get updated and thus 
  incurring dispatch overhead for comparing this python object during jit calls. 
  We want to duduplicate the objects that have the same hash/equality to also 
  have the same object ID, since the equality check is much faster if the object 
  IDs match. 
  &quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.canonicalize = functools.lru_cache(</span><span class="s5">128</span><span class="s1">)(</span><span class="s2">lambda </span><span class="s1">x: x)</span>


<span class="s1">_thread_local_state_cache = _ThreadLocalStateCache()</span>


<span class="s2">def </span><span class="s1">update_thread_local_jit_state(**kw):</span>
  <span class="s1">tls = jax_jit.thread_local_state()</span>
  <span class="s0"># After xla_client._version &gt;= 70, the thread_local object will necessarily</span>
  <span class="s0"># be initialized when accessed. The following line can be removed when the</span>
  <span class="s0"># minimum  jaxlib version is past version 70</span>
  <span class="s1">context = tls.extra_jit_context </span><span class="s2">or </span><span class="s1">_ThreadLocalExtraJitContext()</span>
  <span class="s1">tmp = context._replace(**kw)</span>
  <span class="s1">tls.extra_jit_context = _thread_local_state_cache.canonicalize(tmp)</span>


<span class="s1">flags.DEFINE_integer(</span>
    <span class="s4">'jax_tracer_error_num_traceback_frames'</span><span class="s2">,</span>
    <span class="s1">int_env(</span><span class="s4">'JAX_TRACER_ERROR_NUM_TRACEBACK_FRAMES'</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=</span><span class="s4">'Set the number of stack frames in JAX tracer error messages.'</span>
<span class="s1">)</span>

<span class="s1">flags.DEFINE_bool(</span>
    <span class="s4">'jax_pprint_use_color'</span><span class="s2">,</span>
    <span class="s1">bool_env(</span><span class="s4">'JAX_PPRINT_USE_COLOR'</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=</span><span class="s4">'Enable jaxpr pretty-printing with colorful syntax highlighting.'</span>
<span class="s1">)</span>

<span class="s1">flags.DEFINE_bool(</span>
    <span class="s4">'jax_host_callback_inline'</span><span class="s2">,</span>
    <span class="s1">bool_env(</span><span class="s4">'JAX_HOST_CALLBACK_INLINE'</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=</span><span class="s4">'Inline the host_callback, if not in a staged context.'</span>
<span class="s1">)</span>
<span class="s1">flags.DEFINE_integer(</span>
    <span class="s4">'jax_host_callback_max_queue_byte_size'</span><span class="s2">,</span>
    <span class="s1">int_env(</span><span class="s4">'JAX_HOST_CALLBACK_MAX_QUEUE_BYTE_SIZE'</span><span class="s2">, </span><span class="s1">int(</span><span class="s5">256 </span><span class="s1">* </span><span class="s5">1e6</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'The size in bytes of the buffer used to hold outfeeds from each '</span>
          <span class="s4">'device. When this capacity is reached consuming outfeeds from the '</span>
          <span class="s4">'device is paused, thus potentially pausing the device computation, '</span>
          <span class="s4">'until the Python callback consume more outfeeds.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">lower_bound=int(</span><span class="s5">16 </span><span class="s1">* </span><span class="s5">1e6</span><span class="s1">)</span>
<span class="s1">)</span>
<span class="s1">flags.DEFINE_bool(</span>
    <span class="s4">'jax_host_callback_outfeed'</span><span class="s2">,</span>
    <span class="s1">bool_env(</span><span class="s4">'JAX_HOST_CALLBACK_OUTFEED'</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=(</span>
        <span class="s4">'Use outfeed implementation for host_callback, even on CPU and GPU. '</span>
        <span class="s4">'If false, use the CustomCall implementation. '</span>
        <span class="s4">'Has no effect on TPU, since only the outfeed mechanism is implemented.'</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s1">flags.DEFINE_bool(</span>
    <span class="s4">'jax_host_callback_ad_transforms'</span><span class="s2">,</span>
    <span class="s1">bool_env(</span><span class="s4">'JAX_HOST_CALLBACK_AD_TRANSFORMS'</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=(</span>
        <span class="s4">'Enable support for jvp/vjp for the host_callback primitives. Default is '</span>
        <span class="s4">'False, which means that host_callback operates only on primals. '</span>
        <span class="s4">'The flag exists only temporarily, for backward compatibility.'</span>
    <span class="s1">)</span>
<span class="s1">)</span>

<span class="s0"># TODO(b/214340779): remove flag when XLA:CPU is improved.</span>
<span class="s1">jax2tf_associative_scan_reductions = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax2tf_associative_scan_reductions'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span>
        <span class="s4">'JAX has two separate lowering rules for the cumulative reduction '</span>
        <span class="s4">'primitives (cumsum, cumprod, cummax, cummin). On CPUs and GPUs it uses '</span>
        <span class="s4">'a lax.associative_scan, while for TPUs it uses the HLO ReduceWindow. '</span>
        <span class="s4">'The latter has a slow implementation on CPUs and GPUs. '</span>
        <span class="s4">'By default, jax2tf uses the TPU lowering. Set this flag to True to '</span>
        <span class="s4">'use the associative scan lowering usage, and only if it makes a difference '</span>
        <span class="s4">'for your application. '</span>
        <span class="s4">'See the jax2tf README.md for more details.'</span>
    <span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">jax2tf_default_native_serialization = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax2tf_default_native_serialization'</span><span class="s2">,</span>
    <span class="s1">default=bool_env(</span><span class="s4">'JAX2TF_DEFAULT_NATIVE_SERIALIZATION'</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=(</span>
        <span class="s4">'Sets the default value of the native_serialization parameter to '</span>
        <span class="s4">'jax2tf.convert. Prefer using the parameter instead of the flag, '</span>
        <span class="s4">'the flag may be removed in the future.'</span>
    <span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">jax_platforms = config.define_string_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_platforms'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span>
        <span class="s4">'Comma-separated list of platform names specifying which platforms jax '</span>
        <span class="s4">'should initialize. If any of the platforms in this list are not successfully '</span>
        <span class="s4">'initialized, an exception will be raised and the program will be aborted. '</span>
        <span class="s4">'The first platform in the list will be the default platform. '</span>
        <span class="s4">'For example, config.jax_platforms=cpu,tpu means that CPU and TPU backends '</span>
        <span class="s4">'will be initialized, and the CPU backend will be used unless otherwise '</span>
        <span class="s4">'specified. If TPU initialization fails, it will raise an exception. '</span>
        <span class="s4">'By default, jax will try to initialize all available '</span>
        <span class="s4">'platforms and will default to GPU or TPU if available, and fallback to CPU '</span>
        <span class="s4">'otherwise.'</span>
        <span class="s1">))</span>

<span class="s1">enable_checks = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_enable_checks'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=</span><span class="s4">'Turn on invariant checking for JAX internals. Makes things slower.'</span><span class="s1">)</span>

<span class="s1">check_tracer_leaks = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_check_tracer_leaks'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Turn on checking for leaked tracers as soon as a trace completes. '</span>
          <span class="s4">'Enabling leak checking may have performance impacts: some caching '</span>
          <span class="s4">'is disabled, and other overheads may be added. Additionally, be aware '</span>
          <span class="s4">'that some Python debuggers can cause false positives, so it is recommended '</span>
          <span class="s4">'to disable any debuggers while leak checking is enabled.'</span><span class="s1">))</span>
<span class="s1">checking_leaks = functools.partial(check_tracer_leaks</span><span class="s2">, True</span><span class="s1">)</span>

<span class="s1">debug_nans = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_debug_nans'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Add nan checks to every operation. When a nan is detected on the '</span>
          <span class="s4">'output of a jit-compiled computation, call into the un-compiled '</span>
          <span class="s4">'version in an attempt to more precisely identify the operation '</span>
          <span class="s4">'which produced the nan.'</span><span class="s1">))</span>

<span class="s1">debug_infs = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_debug_infs'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Add inf checks to every operation. When an inf is detected on the '</span>
          <span class="s4">'output of a jit-compiled computation, call into the un-compiled '</span>
          <span class="s4">'version in an attempt to more precisely identify the operation '</span>
          <span class="s4">'which produced the inf.'</span><span class="s1">))</span>

<span class="s1">log_compiles = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_log_compiles'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Log a message each time every time `jit` or `pmap` compiles an XLA '</span>
          <span class="s4">'computation. Logging is performed with `logging`. When this '</span>
          <span class="s4">'option is set, the log level is WARNING; otherwise the level is '</span>
          <span class="s4">'DEBUG.'</span><span class="s1">))</span>

<span class="s1">log_compiles = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_log_checkpoint_residuals'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Log a message every time jax.checkpoint (aka jax.remat) is '</span>
          <span class="s4">'partially evaluated (e.g. for autodiff), printing what residuals '</span>
          <span class="s4">'are saved.'</span><span class="s1">))</span>

<span class="s1">parallel_functions_output_gda = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_parallel_functions_output_gda'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=</span><span class="s4">'If True, pjit will output GDAs.'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_update_jax_array_global(val):</span>
  <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None and not </span><span class="s1">val:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s4">'jax.config.jax_array cannot be disabled after jax 0.4.7 release.'</span>
        <span class="s4">' Please downgrade to jax and jaxlib 0.4.6 if you want to disable'</span>
        <span class="s4">' jax.config.jax_array.'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_update_jax_array_thread_local(val):</span>
  <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None and not </span><span class="s1">val:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s4">'jax.config.jax_array cannot be disabled after jax 0.4.7 release.'</span>
        <span class="s4">' Please downgrade to jax and jaxlib 0.4.6 if you want to disable'</span>
        <span class="s4">' jax.config.jax_array.'</span><span class="s1">)</span>

<span class="s1">jax_array = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_array'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">True,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">update_global_hook = _update_jax_array_global</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook = _update_jax_array_thread_local</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'If True, new pjit behavior will be enabled and `jax.Array` will be '</span>
          <span class="s4">'used.'</span><span class="s1">))</span>


<span class="s1">jit_pjit_api_merge = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_jit_pjit_api_merge'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">True,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">help=(</span><span class="s4">'If True, jit and pjit API will be merged. You can only disable it via '</span>
          <span class="s4">&quot;the environment variable i.e. `os.environ['JAX_JIT_PJIT_API_MERGE'] = '0'`. &quot;</span>
          <span class="s4">&quot;The merge must be disabled via an environment variable since it &quot;</span>
          <span class="s4">&quot;affects JAX at import time so it needs to be disabled before jax is &quot;</span>
          <span class="s4">&quot;imported.&quot;</span><span class="s1">))</span>


<span class="s1">spmd_mode = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_spmd_mode'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'allow_all'</span><span class="s2">, </span><span class="s4">'allow_jit'</span><span class="s2">, </span><span class="s4">'allow_pjit'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s0"># TODO(yashkatariya): Default to `allow_jit` when the training wheels come</span>
    <span class="s0"># off.</span>
    <span class="s1">default=</span><span class="s4">'allow_pjit'</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">&quot;Decides whether Math on `jax.Array`'s that are not fully addressable &quot;</span>
          <span class="s4">&quot;(i.e. spans across multiple processes) is allowed. The options are: &quot;</span>
          <span class="s4">&quot;* allow_pjit: Default, only `pjit` computations are allowed to &quot;</span>
          <span class="s4">&quot;    execute on non-fully addressable `jax.Array`s</span><span class="s2">\n</span><span class="s4">&quot;</span>
          <span class="s4">&quot;* allow_jit: `pjit` and `jax.jit` computations are allowed to &quot;</span>
          <span class="s4">&quot;    execute on non-fully addressable `jax.Array`s</span><span class="s2">\n</span><span class="s4">&quot;</span>
          <span class="s4">&quot;* allow_all: `jnp`, normal math (like `a + b`, etc), `pjit`, &quot;</span>
          <span class="s4">&quot;     `jax.jit` and all other operations are allowed to &quot;</span>
          <span class="s4">&quot;     execute on non-fully addresable `jax.Array`s.&quot;</span><span class="s1">))</span>


<span class="s1">distributed_debug = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_distributed_debug'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Enable logging useful for debugging multi-process distributed '</span>
          <span class="s4">'computations. Logging is performed with `logging` at WARNING '</span>
          <span class="s4">'level.'</span><span class="s1">))</span>


<span class="s1">enable_custom_prng = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_enable_custom_prng'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">help=(</span><span class="s4">'Enables an internal upgrade that allows one to define custom '</span>
          <span class="s4">'pseudo-random number generator implementations.'</span><span class="s1">))</span>

<span class="s1">default_prng_impl = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_default_prng_impl'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'threefry2x32'</span><span class="s2">, </span><span class="s4">'rbg'</span><span class="s2">, </span><span class="s4">'unsafe_rbg'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s4">'threefry2x32'</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Select the default PRNG implementation, used when one is not '</span>
          <span class="s4">'explicitly provided at seeding time.'</span><span class="s1">))</span>

<span class="s1">threefry_partitionable = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_threefry_partitionable'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">help=(</span><span class="s4">'Enables internal threefry PRNG implementation changes that '</span>
          <span class="s4">'render it automatically partitionable in some cases. For use '</span>
          <span class="s4">'with pjit and/or jax_array=True. Without this flag, using the '</span>
          <span class="s4">'standard jax.random pseudo-random number generation may result '</span>
          <span class="s4">'in extraneous communication and/or redundant distributed '</span>
          <span class="s4">'computation. With this flag, the communication overheads disappear '</span>
          <span class="s4">'in some cases.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_global_jit_state(</span>
        <span class="s1">threefry_partitionable=val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: update_thread_local_jit_state(</span>
        <span class="s1">threefry_partitionable=val))</span>

<span class="s1">enable_custom_vjp_by_custom_transpose = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_enable_custom_vjp_by_custom_transpose'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">help=(</span><span class="s4">'Enables an internal upgrade that implements `jax.custom_vjp` by '</span>
          <span class="s4">'reduction to `jax.custom_jvp` and `jax.custom_transpose`.'</span><span class="s1">))</span>

<span class="s1">raise_persistent_cache_errors = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_raise_persistent_cache_errors'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'If true, exceptions raised when reading or writing to the '</span>
          <span class="s4">'persistent compilation cache will be allowed through, halting '</span>
          <span class="s4">'program execution if not manually caught. If false, exceptions are '</span>
          <span class="s4">'caught and raised as warnings, allowing program execution to '</span>
          <span class="s4">'continue. Defaults to false so cache bugs or intermittent issues '</span>
          <span class="s4">'are non-fatal.'</span><span class="s1">))</span>

<span class="s1">persistent_cache_min_compile_time_secs = config.define_float_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_persistent_cache_min_compile_time_secs'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'The minimum compile time of a computation to be written to the '</span>
          <span class="s4">'persistent compilation cache. This threshold can be raised to '</span>
          <span class="s4">'decrease the number of entries written to the cache.'</span><span class="s1">))</span>

<span class="s1">hlo_source_file_canonicalization_regex = config.define_string_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_hlo_source_file_canonicalization_regex'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Used to canonicalize the source_path metadata of HLO instructions '</span>
          <span class="s4">'by removing the given regex. If set, re.sub() is called on each '</span>
          <span class="s4">'source_file with the given regex, and all matches are removed. '</span>
          <span class="s4">'This can be used to avoid spurious cache misses when using the '</span>
          <span class="s4">'persistent compilation cache, which includes HLO metadata in the '</span>
          <span class="s4">'cache key.'</span><span class="s1">))</span>

<span class="s1">config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_default_dtype_bits'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'32'</span><span class="s2">, </span><span class="s4">'64'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s4">'64'</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Specify bit width of default dtypes, either 32-bit or 64-bit. '</span>
          <span class="s4">'This is a temporary flag that will be used during the process '</span>
          <span class="s4">'of deprecating the ``jax_enable_x64`` flag.'</span><span class="s1">))</span>

<span class="s1">numpy_dtype_promotion = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_numpy_dtype_promotion'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'standard'</span><span class="s2">, </span><span class="s4">'strict'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s4">'standard'</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Specify the rules used for implicit type promotion in operations '</span>
          <span class="s4">'between arrays. Options are &quot;standard&quot; or &quot;strict&quot;; in strict-mode, '</span>
          <span class="s4">'binary operations between arrays of differing strongly-specified '</span>
          <span class="s4">'dtypes will result in an error.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">_update_global_jit_state(numpy_dtype_promotion=val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">update_thread_local_jit_state(numpy_dtype_promotion=val))</span>

<span class="s2">def </span><span class="s1">_update_x64_global(val):</span>
  <span class="s1">lib.jax_jit.global_state().enable_x64 = val</span>

<span class="s2">def </span><span class="s1">_update_x64_thread_local(val):</span>
  <span class="s1">lib.jax_jit.thread_local_state().enable_x64 = val</span>

<span class="s1">enable_x64 = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_enable_x64'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=</span><span class="s4">'Enable 64-bit types to be used'</span><span class="s2">,</span>
    <span class="s1">update_global_hook=_update_x64_global</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=_update_x64_thread_local)</span>

<span class="s0"># TODO(phawkins): remove after fixing users of FLAGS.x64_enabled.</span>
<span class="s1">config._contextmanager_flags.remove(</span><span class="s4">'jax_enable_x64'</span><span class="s1">)</span>

<span class="s1">Config.x64_enabled = Config.jax_enable_x64  </span><span class="s0"># type: ignore</span>


<span class="s2">def </span><span class="s1">_update_default_device_global(val):</span>
  <span class="s1">lib.jax_jit.global_state().default_device = val</span>


<span class="s2">def </span><span class="s1">_update_default_device_thread_local(val):</span>
  <span class="s1">lib.jax_jit.thread_local_state().default_device = val</span>


<span class="s2">def </span><span class="s1">_validate_default_device(val):</span>
  <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None and not </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">xla_client.Device):</span>
    <span class="s0"># TODO(skyewm): this is a workaround for non-PJRT Device types. Remove when</span>
    <span class="s0"># all JAX backends use a single C++ device interface.</span>
    <span class="s2">if </span><span class="s4">'Device' </span><span class="s2">in </span><span class="s1">str(type(val)):</span>
      <span class="s1">logger.info(</span>
          <span class="s4">'Allowing non-`xla_client.Device` default device: %s, type: %s'</span><span class="s2">,</span>
          <span class="s1">repr(val)</span><span class="s2">, </span><span class="s1">type(val))</span>
      <span class="s2">return</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'jax.default_device must be passed a Device object (e.g. '</span>
                     <span class="s4">f&quot;`jax.devices('cpu')[0]`), got: </span><span class="s2">{</span><span class="s1">repr(val)</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s0"># TODO(skye): default_device only accepts devices for now. Make it work with</span>
<span class="s0"># platform names as well (e.g. &quot;cpu&quot; to mean the same as jax.devices(&quot;cpu&quot;)[0]).</span>
<span class="s1">default_device = config.define_string_or_object_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_default_device'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span>
        <span class="s4">'Configure the default device for JAX operations. Set to a Device '</span>
        <span class="s4">'object (e.g. ``jax.devices(&quot;cpu&quot;)[0]``) to use that Device as the '</span>
        <span class="s4">'default device for JAX operations and jit</span><span class="s2">\'</span><span class="s4">d function calls (there is '</span>
        <span class="s4">'no effect on multi-device computations, e.g. pmapped function calls). '</span>
        <span class="s4">'Set to None to use the system default device. See '</span>
        <span class="s4">':ref:`faq-data-placement` for more information on device placement.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=_update_default_device_global</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=_update_default_device_thread_local</span><span class="s2">,</span>
    <span class="s1">validate_new_val_hook=_validate_default_device)</span>

<span class="s2">def </span><span class="s1">_update_disable_jit_global(val):</span>
  <span class="s1">lib.jax_jit.global_state().disable_jit = val</span>

<span class="s2">def </span><span class="s1">_update_disable_jit_thread_local(val):</span>
  <span class="s1">lib.jax_jit.thread_local_state().disable_jit = val</span>

<span class="s1">disable_jit = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_disable_jit'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Disable JIT compilation and just call original Python.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=_update_disable_jit_global</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=_update_disable_jit_thread_local)</span>


<span class="s1">numpy_rank_promotion = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_numpy_rank_promotion'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'allow'</span><span class="s2">, </span><span class="s4">'warn'</span><span class="s2">, </span><span class="s4">'raise'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s4">'allow'</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Control NumPy-style automatic rank promotion broadcasting '</span>
          <span class="s4">'(&quot;allow&quot;, &quot;warn&quot;, or &quot;raise&quot;).'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">_update_global_jit_state(numpy_rank_promotion=val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">update_thread_local_jit_state(numpy_rank_promotion=val))</span>

<span class="s1">default_matmul_precision = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_default_matmul_precision'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">'bfloat16'</span><span class="s2">, </span><span class="s4">'tensorfloat32'</span><span class="s2">, </span><span class="s4">'float32'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Control the default matmul and conv precision for 32bit inputs.</span><span class="s2">\n\n</span><span class="s4">'</span>

          <span class="s4">'Some platforms, like TPU, offer configurable precision levels for '</span>
          <span class="s4">'matrix multiplication and convolution computations, trading off '</span>
          <span class="s4">'accuracy for speed. The precision can be controlled for each '</span>
          <span class="s4">'operation; for example, see the :func:`jax.lax.conv_general_dilated` '</span>
          <span class="s4">'and :func:`jax.lax.dot` docstrings. But it can be useful to control '</span>
          <span class="s4">'the default behavior obtained when an operation is not given a '</span>
          <span class="s4">'specific precision.</span><span class="s2">\n\n</span><span class="s4">'</span>

          <span class="s4">'This option can be used to control the default precision '</span>
          <span class="s4">'level for computations involved in matrix multiplication and '</span>
          <span class="s4">'convolution on 32bit inputs. The levels roughly describe the '</span>
          <span class="s4">&quot;precision at which scalar products are computed. The 'bfloat16' &quot;</span>
          <span class="s4">&quot;option is the fastest and least precise; 'float32' is similar to &quot;</span>
          <span class="s4">&quot;full float32 precision; 'tensorfloat32' is intermediate.</span><span class="s2">\n\n</span><span class="s4">&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">_update_global_jit_state(default_matmul_precision=val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">update_thread_local_jit_state(default_matmul_precision=val))</span>

<span class="s1">traceback_filtering = config.define_enum_state(</span>
    <span class="s1">name = </span><span class="s4">'jax_traceback_filtering'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span><span class="s4">&quot;off&quot;</span><span class="s2">, </span><span class="s4">&quot;tracebackhide&quot;</span><span class="s2">, </span><span class="s4">&quot;remove_frames&quot;</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
    <span class="s1">help=</span><span class="s4">&quot;Controls how JAX filters internal frames out of tracebacks.</span><span class="s2">\n\n</span><span class="s4">&quot;</span>
         <span class="s4">&quot;Valid values are:</span><span class="s2">\n</span><span class="s4">&quot;</span>
         <span class="s4">&quot; * </span><span class="s2">\&quot;</span><span class="s4">off</span><span class="s2">\&quot;</span><span class="s4">: disables traceback filtering.</span><span class="s2">\n</span><span class="s4">&quot;</span>
         <span class="s4">&quot; * </span><span class="s2">\&quot;</span><span class="s4">auto</span><span class="s2">\&quot;</span><span class="s4">: use </span><span class="s2">\&quot;</span><span class="s4">tracebackhide</span><span class="s2">\&quot; </span><span class="s4">if running under a sufficiently &quot;</span>
         <span class="s4">&quot;new IPython, or </span><span class="s2">\&quot;</span><span class="s4">remove_frames</span><span class="s2">\&quot; </span><span class="s4">otherwise.</span><span class="s2">\n</span><span class="s4">&quot;</span>
         <span class="s4">&quot; * </span><span class="s2">\&quot;</span><span class="s4">tracebackhide</span><span class="s2">\&quot;</span><span class="s4">: adds </span><span class="s2">\&quot;</span><span class="s4">__tracebackhide__</span><span class="s2">\&quot; </span><span class="s4">annotations to &quot;</span>
         <span class="s4">&quot; hidden stack frames, which some traceback printers support.</span><span class="s2">\n</span><span class="s4">&quot;</span>
         <span class="s4">&quot; * </span><span class="s2">\&quot;</span><span class="s4">remove_frames</span><span class="s2">\&quot;</span><span class="s4">: removes hidden frames from tracebacks, and adds &quot;</span>
         <span class="s4">&quot; the unfiltered traceback as a __cause__ of the exception.</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s0"># This flag is for internal use.</span>
<span class="s0"># TODO(tianjianlu): Removes once we always enable cusparse lowering.</span>
<span class="s0"># TODO(b/262050896): Set to true after bug is fixed</span>
<span class="s1">bcoo_cusparse_lowering = config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_bcoo_cusparse_lowering'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Enables lowering BCOO ops to cuSparse.'</span><span class="s1">))</span>

<span class="s0"># TODO(mattjj): remove this flag when we ensure we only succeed at trace-staging</span>
<span class="s0"># if the intended backend can handle lowering the result</span>
<span class="s1">config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_dynamic_shapes'</span><span class="s2">,</span>
    <span class="s1">default=bool(os.getenv(</span><span class="s4">'JAX_DYNAMIC_SHAPES'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Enables experimental features for staging out computations with '</span>
          <span class="s4">'dynamic shapes.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">_update_global_jit_state(dynamic_shapes=val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: \</span>
      <span class="s1">update_thread_local_jit_state(dynamic_shapes=val))</span>

<span class="s0"># This flag is temporary during rollout of the remat barrier.</span>
<span class="s0"># TODO(parkers): Remove if there are no complaints.</span>
<span class="s1">config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_remat_opt_barrier'</span><span class="s2">,</span>
    <span class="s1">default=(lib.version &gt;= (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">6</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">help=(</span><span class="s4">'Enables using optimization-barrier op for lowering remat.'</span><span class="s1">))</span>

<span class="s0"># TODO(b/205307544): Remove flag once coordination service has rolled out.</span>
<span class="s1">config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_coordination_service'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">True,</span>
    <span class="s1">help=(</span>
         <span class="s4">'Use coordination service (experimental) instead of the default PjRT '</span>
         <span class="s4">'distributed runtime.'</span>
    <span class="s1">)</span>
<span class="s1">)</span>

<span class="s0"># TODO(sharadmv,mattjj): set default to True, then remove</span>
<span class="s1">config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_eager_pmap'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">True,</span>
    <span class="s1">upgrade=</span><span class="s2">True,</span>
    <span class="s1">help=</span><span class="s4">'Enable eager-mode pmap when jax_disable_jit is activated.'</span><span class="s1">)</span>

<span class="s1">config.define_bool_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_experimental_unsafe_xla_runtime_errors'</span><span class="s2">,</span>
    <span class="s1">default=</span><span class="s2">False,</span>
    <span class="s1">help=(</span><span class="s4">'Enable XLA runtime errors for jax.experimental.checkify.checks '</span>
          <span class="s4">'on CPU and GPU. These errors are async, might get lost and are not '</span>
          <span class="s4">'very readable. But, they crash the computation and enable you '</span>
          <span class="s4">'to write jittable checks without needing to checkify. Does not '</span>
          <span class="s4">'work under pmap/pjit.'</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">explicit_device_put_scope() -&gt; Iterator[</span><span class="s2">None</span><span class="s1">]:</span>
  <span class="s3">&quot;&quot;&quot;Indicates that the current context is an explicit device_put*() call.&quot;&quot;&quot;</span>
  <span class="s1">state = transfer_guard_lib.thread_local_state()</span>
  <span class="s1">prev = state.explicit_device_put</span>
  <span class="s1">state.explicit_device_put = </span><span class="s2">True</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">state.explicit_device_put = prev</span>

<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">explicit_device_get_scope() -&gt; Iterator[</span><span class="s2">None</span><span class="s1">]:</span>
  <span class="s3">&quot;&quot;&quot;Indicates that the current context is an explicit device_get() call.&quot;&quot;&quot;</span>
  <span class="s1">state = transfer_guard_lib.thread_local_state()</span>
  <span class="s1">prev = state.explicit_device_get</span>
  <span class="s1">state.explicit_device_get = </span><span class="s2">True</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">state.explicit_device_get = prev</span>

<span class="s2">def </span><span class="s1">_update_transfer_guard(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val):</span>
  <span class="s3">&quot;&quot;&quot;Applies the transfer guard level within transfer_guard_lib.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s2">elif </span><span class="s1">val == </span><span class="s4">'allow'</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">transfer_guard_lib.TransferGuardLevel.ALLOW)</span>
  <span class="s2">elif </span><span class="s1">val == </span><span class="s4">'log'</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">transfer_guard_lib.TransferGuardLevel.LOG)</span>
  <span class="s2">elif </span><span class="s1">val == </span><span class="s4">'disallow'</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">transfer_guard_lib.TransferGuardLevel.DISALLOW)</span>
  <span class="s2">elif </span><span class="s1">val == </span><span class="s4">'log_explicit'</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">transfer_guard_lib.TransferGuardLevel.LOG_EXPLICIT)</span>
  <span class="s2">elif </span><span class="s1">val == </span><span class="s4">'disallow_explicit'</span><span class="s1">:</span>
    <span class="s1">setattr(state</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">transfer_guard_lib.TransferGuardLevel.DISALLOW_EXPLICIT)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">assert False, </span><span class="s4">f'Invalid transfer guard level </span><span class="s2">{</span><span class="s1">val</span><span class="s2">}</span><span class="s4">'</span>

<span class="s1">transfer_guard_host_to_device = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_transfer_guard_host_to_device'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span>
        <span class="s4">'allow'</span><span class="s2">, </span><span class="s4">'log'</span><span class="s2">, </span><span class="s4">'disallow'</span><span class="s2">, </span><span class="s4">'log_explicit'</span><span class="s2">, </span><span class="s4">'disallow_explicit'</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s0"># The default is applied by transfer_guard_lib. Use None here to avoid</span>
    <span class="s0"># accidentally overriding --jax_transfer_guard.</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Select the transfer guard level for host-to-device transfers. '</span>
          <span class="s4">'Default is &quot;allow&quot;.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.global_state()</span><span class="s2">, </span><span class="s4">'host_to_device'</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.thread_local_state()</span><span class="s2">, </span><span class="s4">'host_to_device'</span><span class="s2">, </span><span class="s1">val))</span>

<span class="s1">transfer_guard_device_to_device = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_transfer_guard_device_to_device'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span>
        <span class="s4">'allow'</span><span class="s2">, </span><span class="s4">'log'</span><span class="s2">, </span><span class="s4">'disallow'</span><span class="s2">, </span><span class="s4">'log_explicit'</span><span class="s2">, </span><span class="s4">'disallow_explicit'</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s0"># The default is applied by transfer_guard_lib. Use None here to avoid</span>
    <span class="s0"># accidentally overriding --jax_transfer_guard.</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Select the transfer guard level for device-to-device transfers. '</span>
          <span class="s4">'Default is &quot;allow&quot;.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.global_state()</span><span class="s2">, </span><span class="s4">'device_to_device'</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.thread_local_state()</span><span class="s2">, </span><span class="s4">'device_to_device'</span><span class="s2">, </span><span class="s1">val))</span>

<span class="s1">transfer_guard_device_to_host = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_transfer_guard_device_to_host'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span>
        <span class="s4">'allow'</span><span class="s2">, </span><span class="s4">'log'</span><span class="s2">, </span><span class="s4">'disallow'</span><span class="s2">, </span><span class="s4">'log_explicit'</span><span class="s2">, </span><span class="s4">'disallow_explicit'</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s0"># The default is applied by transfer_guard_lib. Use None here to avoid</span>
    <span class="s0"># accidentally overriding --jax_transfer_guard.</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Select the transfer guard level for device-to-host transfers. '</span>
          <span class="s4">'Default is &quot;allow&quot;.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.global_state()</span><span class="s2">, </span><span class="s4">'device_to_host'</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">,</span>
    <span class="s1">update_thread_local_hook=</span><span class="s2">lambda </span><span class="s1">val: _update_transfer_guard(</span>
        <span class="s1">transfer_guard_lib.thread_local_state()</span><span class="s2">, </span><span class="s4">'device_to_host'</span><span class="s2">, </span><span class="s1">val))</span>

<span class="s2">def </span><span class="s1">_update_all_transfer_guard_global(val):</span>
  <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'jax_transfer_guard_host_to_device'</span><span class="s2">,</span>
               <span class="s4">'jax_transfer_guard_device_to_device'</span><span class="s2">,</span>
               <span class="s4">'jax_transfer_guard_device_to_host'</span><span class="s1">):</span>
    <span class="s1">config.update(name</span><span class="s2">, </span><span class="s1">val)</span>

<span class="s1">_transfer_guard = config.define_enum_state(</span>
    <span class="s1">name=</span><span class="s4">'jax_transfer_guard'</span><span class="s2">,</span>
    <span class="s1">enum_values=[</span>
        <span class="s4">'allow'</span><span class="s2">, </span><span class="s4">'log'</span><span class="s2">, </span><span class="s4">'disallow'</span><span class="s2">, </span><span class="s4">'log_explicit'</span><span class="s2">, </span><span class="s4">'disallow_explicit'</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s0"># The default is applied by transfer_guard_lib. Use None here to avoid</span>
    <span class="s0"># accidentally overriding --jax_transfer_guard_*.</span>
    <span class="s1">default=</span><span class="s2">None,</span>
    <span class="s1">help=(</span><span class="s4">'Select the transfer guard level for all transfers. This option is '</span>
          <span class="s4">'set-only; the transfer guard level for a specific direction should '</span>
          <span class="s4">'be read using the per-transfer direction option. '</span>
          <span class="s4">'Default is &quot;allow&quot;.'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">update_global_hook=_update_all_transfer_guard_global)</span>

<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">transfer_guard(new_val: str) -&gt; Iterator[</span><span class="s2">None</span><span class="s1">]:</span>
  <span class="s3">&quot;&quot;&quot;A contextmanager to control the transfer guard level for all transfers. 
 
  For more information, see 
  https://jax.readthedocs.io/en/latest/transfer_guard.html 
 
  Args: 
    new_val: The new thread-local transfer guard level for all transfers. 
 
  Yields: 
    None. 
  &quot;&quot;&quot;</span>
  <span class="s2">with </span><span class="s1">contextlib.ExitStack() </span><span class="s2">as </span><span class="s1">stack:</span>
    <span class="s1">stack.enter_context(transfer_guard_host_to_device(new_val))</span>
    <span class="s1">stack.enter_context(transfer_guard_device_to_device(new_val))</span>
    <span class="s1">stack.enter_context(transfer_guard_device_to_host(new_val))</span>
    <span class="s1">stack.enter_context(_transfer_guard(new_val))</span>
    <span class="s2">yield</span>
</pre>
</body>
</html>