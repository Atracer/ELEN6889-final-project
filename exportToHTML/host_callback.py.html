<html>
<head>
<title>host_callback.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
host_callback.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;Primitives for calling Python functions on the host from JAX accelerator code. 
 
**Experimental: please give feedback, and expect changes.** 
 
This module introduces the host callback functions :func:`call`, 
:func:`id_tap`, and :func:`id_print`, that send their arguments from the device 
to the host and invoke user-defined Python functions on the host, optionally 
returning results back to the device computation. 
 
We show below how these functions can be used. We start with :func:`call`, 
and we discuss examples of calling from JAX to arbitrary Python functions 
on the CPU, e.g., to use NumPy CPU custom kernels. Then we 
show uses of :func:`id_tap` and :func:`id_print`, which have the restriction 
that they cannot return values from the host to the device. 
These primitives are generally faster 
because they are executed asynchronously with the device code. 
In particular, they can be used to tap into and to debug JAX code. 
 
Using :func:`call` to call a host function and return results to device 
----------------------------------------------------------------------- 
 
Use :func:`call` to invoke a computation on the host and return 
NumPy arrays to the device computation. 
Host computation is useful, e.g., when a device computation needs some data 
that requires I/O on the host, or it needs a library that is available on the 
host and you do not want to code it in JAX. 
For example, eigen decomposition for general matrices in JAX does not work on TPU. 
We can call the Numpy implementation from any JAX accelerator computation, 
using a host computation:: 
 
  # This function runs on the host 
  def host_eig(m: np.ndarray) -&gt; np.ndarray: 
    return np.linalg.eigvals(m) 
 
  # This function is used in JAX 
  def device_fun(m): 
    # We send &quot;m&quot; to the host, asking it to call &quot;host_eig&quot; and return the result. 
    # We have to specify the result shape and dtype, either in the form of an 
    # example return value or any object that has `shape` and `dtype` attributes, 
    # e.g., a NumPy array or a `jax.ShapeDtypeStruct`. 
    return hcb.call(host_eig, m, 
                    # Given an input of shape (..., d, d), eig output has shape (..., d) 
                    result_shape=jax.ShapeDtypeStruct(m.shape[:-1], m.dtype)) 
 
 
The :func:`call` function and the Python host function both take a single argument 
and return a single result, but those can be pytrees. Note that we must tell 
the :func:`call` what shape and dtype to expect from the host invocation, using 
the ``result_shape`` keyword argument. 
This is important because the device code is compiled with that expectation. 
There will be an error raised at runtime if the actual invocation produces a 
different result shape. In general, **such errors and also exceptions raised 
by the host computation may be difficult to debug**. See the Debugging section 
below. 
This is a problem for :func:`call` but not for :func:`id_tap` because for the 
latter the device code does not expect a returned value. 
 
The :func:`call` API can be used inside a jit or pmap computation or inside 
cond/scan/while control flow. When used inside :func:`jax.pmap`, there will be 
separate calls to the host from each of the participating devices:: 
 
  def host_sin(x, *, device): 
    # The ``device`` argument is passed due to ``call_with_device=True`` below. 
    print(f&quot;Invoking host_sin with {x.shape} on {device}&quot;) 
    return np.sin(x) 
 
  # Use pmap to run the computation on two devices 
  jax.pmap(lambda x: hcb.call(host_sin, x, 
                              result_shape=x, 
                              # Ask that the `host_sin` function be passed `device=dev` 
                              call_with_device=True))( 
           np.ones((2, 4), dtype=np.float32)) 
 
  # prints (in arbitrary order) 
  # Invoking host_sin with (4,) on cpu:0 
  # Invoking host_sin with (4,) on cpu:1 
 
Note that :func:`call` does not support any JAX transformations, but as we 
show below one can make use of the 
existing support for `Custom differentiation in JAX &lt;https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html&gt;`_. 
 
Using :func:`id_tap` to call a Python function on the host, with no returned values 
----------------------------------------------------------------------------------- 
 
The :func:`id_tap` and :func:`id_print` are special cases of :func:`call`, when 
you just want the side effects of your Python callback. These functions have 
the advantage that once the arguments have been sent to the host, the device 
computation can proceed without waiting for the Python callback to return. 
For :func:`id_tap` you can specify your Python callback to be called, while 
:func:`id_print` uses a built-in callback that prints the arguments to 
`stdout` on the host. 
The Python function passed 
to :func:`id_tap` takes two positional arguments (the value tapped 
from the device computation along with a ``transforms`` tuple, 
described below). Optionally, the function may be passed a keyword argument 
``device`` with the Device from which the value was tapped. 
 
A few examples:: 
 
  def host_func(arg, transforms): 
     ...do something with arg... 
 
  # calls host_func(2x, []) on host 
  id_tap(host_func, 2 * x) 
 
  # calls host_func((2x, 3x), []) 
  id_tap(host_func, (2 * x, 3 * x))  # The argument can be a pytree 
 
  # calls host_func(2x, [], device=jax.devices()[0]) 
  id_tap(host_func, 2 * x, tap_with_device=True)  # Pass the device to the tap 
 
  # calls host_func(2x, [], what='activation') 
  id_tap(functools.partial(host_func, what='activation'), 2 * x) 
 
  # calls host_func(dict(x=x, y=y), what='data') 
  id_tap(lambda tap, transforms: host_func(tap, what='data'), dict(x=x, y=y)) 
 
The above examples can all be adapted to use :func:`id_print` instead, with 
the difference that :func:`id_print` prints on the host the positional argument, 
along with any additional kwargs and the automatic kwarg ``transforms``. 
 
Using :func:`barrier_wait` to wait until all callbacks have executed 
-------------------------------------------------------------------- 
 
If your Python callbacks have side-effects you may need to wait until the 
computation has finished to ensure that the side-effects have been observed. 
You can use the :func:`barrier_wait` function for that purpose:: 
 
   accumulator = [] 
   def host_log(arg, transforms): 
     # We just record the arguments in a list 
     accumulator.append(arg) 
 
 
   def device_fun(c): 
     id_tap(host_log, x) 
     id_tap(host_log, 2. * x) 
 
   jax.jit(device_fun)(1.) 
   jax.jit(device_fun)(1.) 
 
   # At this point, we have started two computations, each with two 
   # taps, but they may not have yet executed. 
   barrier_wait() 
   # Now we know that all the computations started before `barrier_wait` 
   # on all devices, have finished, and all the callbacks have finished 
   # executing. 
 
Note that :func:`barrier_wait` will start one 
tiny computation with one tap on each of the `jax.local_devices()` and 
will wait for all these taps to be received. 
 
An alternative to using :func:`barrier_wait` is to just wait for the end 
of the computation, if all the callbacks are :func:`call`:: 
 
   accumulator = p[] 
   def host_log(arg): 
     # We just record the arguments in a list 
     accumulator.append(arg) 
     return 0.  #  return something 
 
 
   def device_fun(c): 
     y = call(host_log, x, result_shape=jax.ShapeDtypeStruct((), np.float32)) 
     z = call(host_log, 2. * x, result_shape=jax.ShapeDtypeStruct((), np.float32)) 
     return y + z  # return something that uses both results 
 
   res1 = jax.jit(device_fun)(1.) 
   res2 = jax.jit(device_fun)(1.) 
   res1.block_until_ready() 
   res2.block_until_ready() 
 
Behavior under parallelization transformations 
---------------------------------------------- 
 
In presence of :func:`jax.pmap` the code will run on multiple devices and 
each device will tap its values independently. 
It may be helpful to use the ``tap_with_device`` option for :func:`id_print` 
or :func:`id_tap`, so that you see which device is sending which data:: 
 
  jax.pmap(power3, devices=jax.local_devices()[:2])(np.array([3., 4.]) 
  # device=cpu:0 what=x,x^2: (3., 9.)  # from the first device 
  # device=cpu:1 what=x,x^2: (4., 16.)  # from the second device 
 
When using :func:`jax.pmap` with multiple devices on multiple hosts, every 
host will receive callbacks from all of its local devices, with an operand 
that corresponds to each device slice. For a 
:func:`call`, the callback must return to each device only the slice of the 
result that pertains to the corresponding device. 
 
When using the experimental :func:`pjit.pjit` the code will run on multiple 
devices on different shards of the input. The current implementation of 
host callbacks will ensure that a single device will collect and outfeed 
the entire operand, in a single callback. The callback function is supposed 
to return the entire array, which will then be sent in a single infeed to the 
same device that issued the outfeed. This device is then responsible for 
sending the required shards to the other devices:: 
 
  with jax.sharding.Mesh(jax.local_devices()[:2], [&quot;d&quot;]): 
    pjit.pjit(power3, in_shardings=(P(&quot;d&quot;),), 
              out_shardings=(P(&quot;d&quot;),))(np.array([3., 4.])) 
 
  # device=TPU:0 what=x,x^2: ( [3., 4.], 
  #                            [9., 16.] ) 
 
Note that the collection of the operand on one device may result in OOM if 
the operand was sharded across devices. 
 
When using :func:`pjit.pjit` with multiple devices on multiple hosts, only 
the host for the device 0 (w.r.t. the mesh) will receive the callback, with 
the operand collected 
from all participating devices on all hosts. For a :func:`call`, the callback 
must return the entire array for all devices on all hosts. 
 
Behavior under JAX autodiff transformations 
------------------------------------------- 
 
When used under a JAX autodiff transformation, the host callback functions 
operate on the primal values only. Consider the following example:: 
 
    def power3(x): 
      y = x * x 
      # Print both 'x' and 'x^2'. Must pack as a tuple. 
      hcb.id_print((x, y), what=&quot;x,x^2&quot;) 
      return y * x 
 
    power3(3.) 
    # what: x,x^2 : (3., 9.) 
 
(You can see these examples tested in `host_callback_test.HostCallbackTapTest.test_tap_transforms`.) 
 
When used under :func:`jax.jvp` there will be one callback with the primal 
values only:: 
 
    jax.jvp(power3, (3.,), (0.1,)) 
    # what: x,x^2 : (3., 9.) 
 
Similarly for :func:`jax.grad`, we get a callback from the forward computation 
only:: 
 
    jax.grad(power3)(3.) 
    # what: x,x^2 : (3., 9.) 
 
If you want to invoke the callback on the tangents during a :func:`jax.jvp`, 
you can use a custom_jvp. For example, you can define a function that does 
nothing interesting except that its custom_jvp will print the tangents:: 
 
    @jax.custom_jvp 
    def print_tangents(arg): 
      return None 
 
    @print_tangents.defjvp 
    def print_tangents_jvp(primals, tangents): 
      arg_dot, = tangents 
      hcb.id_print(arg_dot, what=&quot;tangents&quot;) 
      return primals, tangents 
 
Then you use this function in the places where you want to tap the tangents:: 
 
    def power3_with_tangents(x): 
      y = x * x 
      # Print both 'x' and 'x^2'. Must pack as a tuple. 
      hcb.id_print((x, y), what=&quot;x,x^2&quot;) 
      print_tangents((x, y)) 
      return y * x 
 
    jax.jvp(power3_with_tangents, (3.,), (0.1,)) 
    # what: x,x^2 : (3., 9.) 
    # what: tangents : (0.1, 0.6) 
 
You can do a similar thing for the cotangents during :func:`jax.grad`. This 
time you must be careful to use in the rest of the computation the values whose 
cotangents you want to tap. Hence we make the ``print_cotangents`` return 
its argument:: 
 
    @jax.custom_vjp 
    def print_cotangents(arg): 
      # Must return the argument for which we want the cotangent. 
      return arg 
 
    # f_fwd: a -&gt; (b, residual) 
    def print_cotangents_fwd(arg): 
      return print_cotangents(arg), None 
    # f_bwd: (residual, CT b) -&gt; [CT a] 
    def print_cotangents_bwd(residual, ct_b): 
      hcb.id_print(ct_b, what=&quot;cotangents&quot;, output_stream=testing_stream) 
      return ct_b, 
 
    print_cotangents.defvjp(print_cotangents_fwd, print_cotangents_bwd) 
 
    def power3_with_cotangents(x): 
      y = x * x 
      # Print both 'x' and 'x^2'. Must pack as a tuple. 
      hcb.id_print((x, y), what=&quot;x,x^2&quot;, output_stream=testing_stream) 
      (x1, y1) = print_cotangents((x, y)) 
      # Must use the output of print_cotangents 
      return y1 * x1 
 
    jax.grad(power3_with_cotangents)(3.) 
    # what: x,x^2 : (3., 9.) 
    # what: cotangents : (9., 3.) 
 
If you use :func:`ad_checkpoint.checkpoint` to rematerialize the residuals 
for the backward pass, then the callbacks from the primal computation will 
be called twice:: 
 
    jax.grad(lambda x: power3(ad_checkpoint.checkpoint(power3)(x)))(3.) 
    # what: x,x^2 : (3., 9.) 
    # what: x,x^2 : (27., 729.) 
    # what: x,x^2 : (3., 9.) 
 
The callbacks are, in order from: the primal computation of the inner ``power3``, 
the primal computation of the outer ``power3``, and the rematerialization 
of the residuals for the inner ``power3``. 
 
 
Behavior under jax.vmap 
----------------------- 
 
The host callback functions :func:`id_print` and :func:`id_tap` support the 
vectorization transformation :func:`jax.vmap`. 
 
For :func:`jax.vmap` the arguments to the callback are batched, 
and the callback function is 
passed an additional special ``transforms`` containing a list of transformation descriptors 
in the form ``(&quot;batch&quot;, {&quot;batch_dims&quot;: ...})``, where ``...``` denotes the 
batched dimensions for the tapped values (one entry per argument, ` 
`None`` denotes an argument that was broadcast). 
 
  jax.vmap(power3)(np.array([2., 3.])) 
  # transforms: [('batch', {'batch_dims': (0, 0)})] what: x,x^2 : ([2., 3.], [4., 9.]) 
 
See documentation for :func:`id_tap`, :func:`id_print`, and :func:`call`. 
 
For more usage example, see tests/host_callback_test.py. 
 
Using :func:`call` to call a TensorFlow function, with reverse-mode autodiff support 
------------------------------------------------------------------------------------ 
 
Another possible use for host computation is to invoke a library written for 
another framework, such as TensorFlow. 
In this case it becomes interesting to support JAX autodiff for host callbacks 
by deferring to the autodiff mechanism in TensorFlow, 
using the :func:`jax.custom_vjp` mechanism. 
 
This is relatively easy to do, once one understands both the JAX custom VJP 
and the TensorFlow autodiff mechanisms. 
The code for how this can be done is shown in the ``call_tf_full_ad`` 
function in `host_callback_to_tf_test.py &lt;https://github.com/google/jax/blob/main/tests/host_callback_to_tf_test.py&gt;`_. 
This example supports arbitrary higher-order differentiation as well. 
 
Note that if you just want to call TensorFlow functions from JAX, you can also 
use the `jax2tf.call_tf function &lt;https://github.com/google/jax/blob/main/jax/experimental/jax2tf/call_tf.py&gt;`_. 
 
Using :func:`call` to call a JAX function on another device, with reverse-mode autodiff support 
------------------------------------------------------------------------------------------------ 
 
It should not be surprising that we can use host computation to invoke a JAX 
computation on another device. The arguments are sent from the accelerator to 
the host, and then to the outside device on which the JAX host 
computation will run, and then the results are sent back to the original accelerator. 
 
The code for how this can be done is shown in the ``call_jax_other_device function`` 
in `host_callback_test.py &lt;https://github.com/google/jax/blob/main/tests/host_callback_test.py&gt;`_. 
 
Low-level details and debugging 
------------------------------- 
 
The host callback functions will be executed for each device in the order in 
which the send operations were performed on the device. 
 
The host callback functions for multiple devices may be interleaved. 
The data from the devices is received by separate threads managed by the JAX 
runtime (one thread per device). The runtime maintains a buffer of 
configurable size (see the flag ``--jax_host_callback_max_queue_byte_size``). 
When the buffer is full, all the receiving threads are paused 
which eventually pauses the computation on devices. The runtime has one 
additional thread for each device to invoke the Python user functions with the 
received data. If the processing of the callbacks is slow, it may actually 
lead to the runtime buffer filling up, and eventually pausing the computation 
on the devices when they need to send something. 
For more details on the outfeed receiver runtime mechanism see 
`runtime code 
&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_. 
 
In order to pause the execution until all data from computations already 
started on devices has arrived and has been processed, use :func:`barrier_wait`. 
 
Exceptions from the user-defined callback functions are logged along with their 
stack traces, but the receiving threads are not stopped. Instead the last 
exception is recorded and the subsequent :func:`barrier_wait` will 
raise :exc:`CallbackException` if any exception had occurred 
in one of the tap functions. This exception will include the text and the 
stack trace of the last exception encountered. 
 
One further complication arises for callback functions that must return 
results to the call origin device, such as :func:`call()`. This is handled 
differently on CPU/GPU devices compared to TPU devices. 
 
On CPU/GPU devices, in order to avoid the device computation 
being stuck waiting for a result that will never arrive, in case of any 
error during the processing of the callback (whether raised by the user-code 
itself or due to a mismatch of the returned value and the expected return_shape) 
we send the device a &quot;fake&quot; result of shape ``int8[12345]``. 
This will make the device 
computation abort because the received data is different than the one that 
it expects. On CPU the runtime will crash with a distinctive error message: 
 
``` 
Check failed: buffer-&gt;length() == buffer_length (12345 vs. ...) 
``` 
 
On GPU, the failure is more user-friendly and will be surfaced to the Python 
program as: 
 
``` 
RET_CHECK failure ... Mismatch between infeed source buffer shape s8[12345] ... 
``` 
 
To debug the underlying cause for these messages, see the Debugging section. 
 
On TPU devices, there is currently no shape check for infeed, so we take the 
safer route of not sending this fake result in case of errors. This means 
that the computation will hang, and no exception will be raised (but any 
exceptions in the callback functions will still appear in the logs). 
 
The current implementation uses the outfeed mechanism provided by XLA. The 
mechanism itself is quite primitive in the sense that a receiver must know 
exactly the shape of each incoming packet, and how many packets are expected. 
This makes it hard to use for multiple kinds of data in the same computation, 
and it is practically impossible to use it under conditionals or in loops 
of non-constant iteration count. Furthermore, code that uses the outfeed 
mechanism directly cannot be transformed by JAX. All these limitations are 
addressed by the host callback functions. The tapping API introduced here 
makes it easy to share the outfeed mechanism for multiple purposes, while 
supporting all transformations. 
 
**Note that after you have used the host callback functions, you cannot 
use lax.outfeed directly**. You may want to :func:`stop_outfeed_receiver` 
if you later need to use lax.outfeed. 
 
Since the actual calls to your callback functions are made from the C++ 
receiver, it may be hard to debug the calls. In particular, the stack trace 
will not include the calling code. You can use the flag 
``jax_host_callback_inline`` (or the environment variable 
``JAX_HOST_CALLBACK_INLINE``) to ensure that the calls to the callbacks are 
inlined. This works only if the calls are outside a staging context 
(:func:`~jax.jit` or a control-flow primitive). 
 
The C++ `receiver 
&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_ 
is started automatically on the first call to :func:`id_tap`. In order to stop 
it properly, upon start an ``atexit`` handler is registered to call 
:func:`barrier_wait` with the logging name &quot;at_exit&quot;. 
 
There are a few environment variables that you can use to turn on logging 
for the C++ outfeed `receiver backend 
&lt;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/xla/python/outfeed_receiver.cc&gt;`_. 
 
  * ``TF_CPP_MIN_LOG_LEVEL=0``: will turn on INFO logging, needed for all below. 
  * ``TF_CPP_MIN_VLOG_LEVEL=3``: will make all VLOG logging up to level 3 behave 
    like INFO logs. This may be too much, but you will see which modules are 
    logging relevant info, and then you can select which modules to log from. 
  * ``TF_CPP_VMODULE=&lt;module_name&gt;=3`` (the module name can be either C++ or 
    Python, without the extension). 
 
You should also use the ``--verbosity=2`` flag so that you see the logs 
from Python. 
 
For example, you can try to enable logging in the ``host_callback`` module: 
``TF_CPP_MIN_LOG_LEVEL=0 TF_CPP_VMODULE=host_callback=3 python tests/host_callback_test.py --verbosity=2 HostCallbackIdTapTest.test_tap_jit_simple`` 
 
If you want to enable logging in lower-level implementation modules try: 
``TF_CPP_MIN_LOG_LEVEL=0 TF_CPP_VMODULE=outfeed_receiver=3,host_callback=3,outfeed_receiver_py=3,outfeed_thunk=3,infeed_thunk=3,cpu_transfer_manager=3,cpu_runtime=3,xfeed_manager=3,pjrt_client=3 python tests/host_callback_test.py --verbosity=2 HostCallbackIdTapTest.test_tap_jit_simple`` 
 
(For bazel tests use --test_arg=--vmodule=... 
 
Still to do: 
  * More performance tests. 
  * Explore implementation with outside compilation for TPU. 
  * Explore implementation with XLA CustomCall for CPU and GPU. 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">atexit</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">traceback</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">(Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">,</span>
                    <span class="s1">Tuple</span><span class="s3">, </span><span class="s1">cast)</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">api</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax.config </span><span class="s3">import </span><span class="s1">config</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">custom_derivatives</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax.experimental </span><span class="s3">import </span><span class="s1">pjit</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">ad</span><span class="s3">, </span><span class="s1">batching</span><span class="s3">, </span><span class="s1">pxla</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">mlir</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">partial_eval </span><span class="s3">as </span><span class="s1">pe</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">xla</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">ad_checkpoint</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dispatch</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">pretty_printer </span><span class="s3">as </span><span class="s1">pp</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">source_info_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">lib </span><span class="s3">as </span><span class="s1">jaxlib</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">pytree</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">xla_bridge </span><span class="s3">as </span><span class="s1">xb</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">xla_client</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">xla_extension</span>
<span class="s3">from </span><span class="s1">jax._src.lib.mlir.dialects </span><span class="s3">import </span><span class="s1">hlo</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>


<span class="s1">FLAGS = config.FLAGS</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s3">def </span><span class="s1">_inline_host_callback() -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">FLAGS.jax_host_callback_inline</span>


<span class="s3">def </span><span class="s1">_use_outfeed(platform: str) -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">(platform </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;tpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s3">, </span><span class="s4">&quot;cuda&quot;</span><span class="s3">, </span><span class="s4">&quot;rocm&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">FLAGS.jax_host_callback_outfeed)</span>


<span class="s3">def </span><span class="s1">_raise_if_using_outfeed_with_pjrt_c_api(backend: xb.XlaBackend):</span>
  <span class="s2">&quot;&quot;&quot;Should be called whenever outfeed (or infeed) will be used.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">xb.using_pjrt_c_api(backend):</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
        <span class="s4">&quot;host_callback functionality isn't supported with the new Cloud TPU &quot;</span>
        <span class="s4">&quot;runtime. See https://jax.readthedocs.io/en/latest/debugging/index.html&quot;</span>
        <span class="s4">&quot; and &quot;</span>
        <span class="s4">&quot;https://jax.readthedocs.io/en/latest/notebooks/external_callbacks.html&quot;</span>
        <span class="s4">&quot; for alternatives. Please file a feature request at &quot;</span>
        <span class="s4">&quot;https://github.com/google/jax/issues if none of the alternatives are &quot;</span>
        <span class="s4">&quot;sufficent.&quot;</span><span class="s1">)</span>


<span class="s1">xops = xla_client._xla.ops</span>

<span class="s1">XlaOp = xla_client.XlaOp</span>
<span class="s1">XlaShape = xla_client.Shape</span>
<span class="s1">XlaBuilder = xla_client.XlaBuilder</span>
<span class="s1">XlaDevice = xla_client.Device</span>
<span class="s1">XlaLocalClient = xla_client.Client</span>
<span class="s1">DType = Any</span>


<span class="s3">def </span><span class="s1">id_tap(tap_func</span><span class="s3">,</span>
           <span class="s1">arg</span><span class="s3">,</span>
           <span class="s1">*</span><span class="s3">,</span>
           <span class="s1">result=</span><span class="s3">None,</span>
           <span class="s1">tap_with_device=</span><span class="s3">False,</span>
           <span class="s1">device_index=</span><span class="s5">0</span><span class="s3">,</span>
           <span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;Host-callback tap primitive, like identity function with a call to ``tap_func``. 
 
  **Experimental: please give feedback, and expect changes!** 
 
  ``id_tap`` behaves semantically like the identity function but has the 
  side-effect that a user-defined Python function is called with the runtime 
  value of the argument. 
 
  Args: 
    tap_func: tap function to call like ``tap_func(arg, transforms)``, with 
      ``arg`` as described below and where ``transforms`` is the sequence of 
      applied JAX transformations in the form ``(name, params)``. If the 
      `tap_with_device` optional argument is True, then the invocation also 
      includes the device from which the value is tapped as a keyword argument: 
      ``tap_func(arg, transforms, device=dev)``. 
    arg: the argument passed to the tap function, can be a pytree of JAX 
      types. 
    result: if given, specifies the return value of ``id_tap``. This value is 
      not passed to the tap function, and in fact is not sent from the device to 
      the host. If the ``result`` parameter is not specified then the return 
      value of ``id_tap`` is ``arg``. 
    tap_with_device: if True then the tap function is invoked with the 
      device from which the tap originates as a keyword argument. 
    device_index: specifies from which device the tap function is invoked in a 
      SPMD program. Works only when using the outfeed implementation mechanism, 
      i.e., does not work on CPU unless --jax_host_callback_outfeed=True. 
 
  Returns: 
    ``arg``, or ``result`` if given. 
 
  The order of execution is by data dependency: after all the arguments and 
  the value of ``result`` if present, are computed and before the returned 
  value is used. At least one of the returned values of ``id_tap`` must be 
  used in the rest of the computation, or else this operation has no effect. 
 
  Tapping works even for code executed on accelerators and even for code under 
  JAX transformations. 
 
  For more details see the :mod:`jax.experimental.host_callback` module documentation. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">kwargs:</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;Support for **kwargs in ``id_tap`` has been removed. Instead, &quot;</span>
        <span class="s4">&quot;pre-apply keyword arguments, either by using a closure or by passing &quot;</span>
        <span class="s4">&quot;``functools.partial(tap_func, **kwargs)``.&quot;</span><span class="s1">)</span>
    <span class="s3">raise </span><span class="s1">TypeError(msg)</span>
  <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s1">warnings.warn(</span><span class="s4">'The flag jax_host_callback_ad_transforms is for temporary '</span>
                  <span class="s4">'backwards compatibility mode. This flag, and the behavior '</span>
                  <span class="s4">'it enabled will be removed soon.'</span><span class="s3">,</span>
                  <span class="s1">FutureWarning)</span>

  <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">flat_results</span><span class="s3">, </span><span class="s1">result_treedef = pytree.flatten(result)</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">flat_results:</span>
      <span class="s1">dispatch.check_arg(r)</span>

  <span class="s1">call_res = _call(</span>
      <span class="s1">tap_func</span><span class="s3">,</span>
      <span class="s1">arg</span><span class="s3">,</span>
      <span class="s1">call_with_device=tap_with_device</span><span class="s3">,</span>
      <span class="s1">result_shape=</span><span class="s3">None,</span>
      <span class="s1">identity=</span><span class="s3">True,</span>
      <span class="s1">device_index=device_index)</span>

  <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s0"># Return the results, but add a dependency on the call, to ensure it</span>
    <span class="s0"># is kept in the graph.</span>
    <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
      <span class="s1">call_flat_results</span><span class="s3">, </span><span class="s1">_ = pytree.flatten(call_res)</span>
      <span class="s3">if </span><span class="s1">call_flat_results:</span>
        <span class="s1">call_flat_results = [id_tap_dep_p.bind(r</span><span class="s3">, </span><span class="s1">call_flat_results[</span><span class="s5">0</span><span class="s1">])</span>
                             <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">flat_results]</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">call_flat_results = flat_results</span>
      <span class="s3">return </span><span class="s1">result_treedef.unflatten(call_flat_results)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">result</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">call_res</span>


<span class="s3">def </span><span class="s1">id_print(arg</span><span class="s3">,</span>
             <span class="s1">*</span><span class="s3">,</span>
             <span class="s1">result=</span><span class="s3">None,</span>
             <span class="s1">tap_with_device=</span><span class="s3">False,</span>
             <span class="s1">device_index=</span><span class="s5">0</span><span class="s3">,</span>
             <span class="s1">output_stream=</span><span class="s3">None,</span>
             <span class="s1">threshold=</span><span class="s3">None,</span>
             <span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;Like :func:`id_tap` with a printing tap function. 
 
   **Experimental: please give feedback, and expect changes!** 
 
   On each invocation of the printing tap, the ``kwargs`` if present 
   will be printed first (sorted by keys). Then arg will be printed, 
   with the arrays stringified with ``numpy.array2string``. 
 
   See the :func:`id_tap` documentation. 
 
   Additional keyword arguments: 
 
   * ``tap_with_device`` if True, will print also the device from which 
     the value originates. 
   * ``output_stream`` if given then it will be used instead of the 
     built-in ``print``. The string will be passed as 
     ``output_stream.write(s)``. 
   * ``threshold`` is passed to ``numpy.array2string``. 
 
  For more details see the :mod:`jax.experimental.host_callback` module documentation. 
  &quot;&quot;&quot;</span>
  <span class="s1">printer = functools.partial(_print_tap_func</span><span class="s3">,</span>
                              <span class="s1">output_stream=output_stream</span><span class="s3">,</span>
                              <span class="s1">threshold=threshold</span><span class="s3">, </span><span class="s1">**kwargs)</span>
  <span class="s3">return </span><span class="s1">id_tap(</span>
      <span class="s1">printer</span><span class="s3">,</span>
      <span class="s1">arg</span><span class="s3">,</span>
      <span class="s1">result=result</span><span class="s3">,</span>
      <span class="s1">tap_with_device=tap_with_device</span><span class="s3">,</span>
      <span class="s1">device_index=device_index)</span>


<span class="s3">def </span><span class="s1">call(callback_func: Callable</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
         <span class="s1">result_shape=</span><span class="s3">None,</span>
         <span class="s1">call_with_device=</span><span class="s3">False,</span>
         <span class="s1">device_index=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Make a call to the host, and expect a result. 
 
  **Experimental: please give feedback, and expect changes!** 
 
  Args: 
    callback_func: The Python function to invoke on the host as 
      ``callback_func(arg)``. If the ``call_with_device`` optional argument is True, 
      then the invocation also includes the ``device`` kwarg with the device 
      from which the call originates: ``callback_func(arg, device=dev)``. This function 
      must return a pytree of numpy ndarrays. 
 
    arg: the argument passed to the callback function, can be a pytree of JAX 
      types. 
 
    result_shape: a value that describes the expected shape and dtype of the 
      result. This can be a numeric scalar, from which a shape and dtype are 
      obtained, or an object that has ``.shape`` and ``.dtype`` attributes. 
      If the result of the callback is a pytree, then ``result_shape`` should 
      also be a pytree with the same structure. In particular, ``result_shape`` 
      can be `()` or `None` if the function does not have any results. 
      The device code containing ``call`` is compiled with the expected result shape and dtype, 
      and an error will be raised at runtime if the actual ``callback_func`` 
      invocation returns a different kind of result. 
 
    call_with_device: if True then the callback function is invoked with the 
      device from which the call originates as a keyword argument. 
 
    device_index: specifies from which device the tap function is invoked in a 
      SPMD program. Works only when using the outfeed implementation mechanism, 
      i.e., does not work on CPU unless --jax_host_callback_outfeed=True. 
  Returns: 
    the result of the ``callback_func`` invocation. 
 
  For more details see the :mod:`jax.experimental.host_callback` module documentation. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">_call(callback_func</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">result_shape=result_shape</span><span class="s3">,</span>
               <span class="s1">call_with_device=call_with_device</span><span class="s3">, </span><span class="s1">identity=</span><span class="s3">False,</span>
               <span class="s1">device_index=device_index)</span>


<span class="s0"># We need the wrapper function to have hash and equality defined since it is</span>
<span class="s0"># used as a primitive keyword argument, and we want a compilation cache hit if</span>
<span class="s0"># the user uses the same function twice.</span>
<span class="s3">class </span><span class="s1">_CallbackWrapper:</span>
  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">callback_func</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">, </span><span class="s1">call_with_device):</span>
    <span class="s1">self.callback_func = callback_func</span>
    <span class="s1">self.identity = identity</span>
    <span class="s1">self.call_with_device = call_with_device</span>

  <span class="s3">def </span><span class="s1">__hash__(self):</span>
    <span class="s3">return </span><span class="s1">hash((self.callback_func</span><span class="s3">, </span><span class="s1">self.identity</span><span class="s3">, </span><span class="s1">self.call_with_device))</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">return </span><span class="s1">(self.callback_func == other.callback_func </span><span class="s3">and</span>
            <span class="s1">self.identity == other.identity </span><span class="s3">and</span>
            <span class="s1">self.call_with_device == other.call_with_device)</span>

  <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">transforms):</span>
    <span class="s3">if </span><span class="s1">self.identity:</span>
      <span class="s0"># For id_tap, we pass the transforms, for backwards compatibility</span>
      <span class="s3">if </span><span class="s1">self.call_with_device:</span>
        <span class="s3">return </span><span class="s1">self.callback_func(arg</span><span class="s3">, </span><span class="s1">transforms</span><span class="s3">, </span><span class="s1">device=device)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">self.callback_func(arg</span><span class="s3">, </span><span class="s1">transforms)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">self.call_with_device:</span>
        <span class="s3">return </span><span class="s1">self.callback_func(arg</span><span class="s3">, </span><span class="s1">device=device)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">self.callback_func(arg)</span>


<span class="s0"># Helper function to implement both `call` and `id_tap`. The two cases are</span>
<span class="s0"># differentiated by the `identity` flag.</span>
<span class="s3">def </span><span class="s1">_call(callback_func: Callable</span><span class="s3">,</span>
          <span class="s1">arg</span><span class="s3">,</span>
          <span class="s1">*</span><span class="s3">,</span>
          <span class="s1">result_shape=</span><span class="s3">None,</span>
          <span class="s1">call_with_device=</span><span class="s3">False,</span>
          <span class="s1">device_index=</span><span class="s5">0</span><span class="s3">,</span>
          <span class="s1">identity=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s0"># Lazy initialization</span>
  <span class="s1">_initialize_outfeed_receiver(</span>
      <span class="s1">max_callback_queue_size_bytes=FLAGS.jax_host_callback_max_queue_byte_size)</span>
  <span class="s1">api.check_callable(callback_func)</span>
  <span class="s1">flat_args</span><span class="s3">, </span><span class="s1">arg_treedef = pytree.flatten(arg)</span>
  <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">flat_args:</span>
    <span class="s1">dispatch.check_arg(arg)</span>
  <span class="s0"># See definition of outside_call_p for what parameters it takes</span>
  <span class="s1">params: Dict[str</span><span class="s3">, </span><span class="s1">Any] = {}</span>
  <span class="s0"># TODO: wrap function</span>
  <span class="s1">params[</span><span class="s4">&quot;callback&quot;</span><span class="s1">] = _CallbackWrapper(callback_func</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">,</span>
                                        <span class="s1">call_with_device)</span>
  <span class="s1">params[</span><span class="s4">&quot;identity&quot;</span><span class="s1">] = identity</span>
  <span class="s1">params[</span><span class="s4">&quot;arg_treedef&quot;</span><span class="s1">] = arg_treedef</span>
  <span class="s1">params[</span><span class="s4">&quot;device_index&quot;</span><span class="s1">] = device_index</span>

  <span class="s3">if not </span><span class="s1">identity:</span>
    <span class="s0"># Turn abstract values into ShapesDtypeStruct</span>
    <span class="s1">flat_results_shape</span><span class="s3">, </span><span class="s1">result_treedef = pytree.flatten(result_shape)</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">flat_results_aval = [core.ShapedArray(np.shape(r)</span><span class="s3">, </span><span class="s1">dtypes.dtype(r</span><span class="s3">, </span><span class="s1">canonicalize=</span><span class="s3">True</span><span class="s1">))</span>
                           <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">flat_results_shape]</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
      <span class="s1">msg = (</span><span class="s4">&quot;result_shape should be a pytree of values with structure &quot;</span>
             <span class="s4">&quot;matching the expected result of the callback function. The &quot;</span>
             <span class="s4">&quot;values must be either numeric scalars, or must have 'shape' and &quot;</span>
             <span class="s4">f&quot;'dtype' attributes. Got </span><span class="s3">{</span><span class="s1">result_shape</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s1">params[</span><span class="s4">&quot;result_treedef&quot;</span><span class="s1">] = result_treedef</span>
    <span class="s1">params[</span><span class="s4">&quot;flat_results_aval&quot;</span><span class="s1">] = tuple(flat_results_aval)</span>
  <span class="s1">flat_results = outside_call_p.bind(*flat_args</span><span class="s3">, </span><span class="s1">**params)</span>
  <span class="s3">return </span><span class="s1">result_treedef.unflatten(flat_results) </span><span class="s3">if not </span><span class="s1">identity </span><span class="s3">else </span><span class="s1">arg_treedef.unflatten(flat_results)</span>


<span class="s0"># We need the lock for when we use the CustomCall implementation of callbacks.</span>
<span class="s0"># The outfeed implementation is driven by a single thread from C++.</span>
<span class="s1">_print_tap_lock = threading.Lock()</span>


<span class="s3">def </span><span class="s1">_print_tap_func(</span>
    <span class="s1">arg</span><span class="s3">, </span><span class="s1">transforms</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">device=</span><span class="s3">None,</span>
    <span class="s1">output_stream=</span><span class="s3">None, </span><span class="s1">threshold=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;The consumer for id_print. 
 
  We provide this as a simple tapping function for printing. 
  This is **experimental** and may not want to add many features to it; 
  it should be easy for the user to roll their own printing function. 
 
  Args: 
    device: the device from which the value originates (only if 
      ``tap_with_device`` was used for :func:`id_print`). 
    output_stream: a function whose `write` method is called with the strings to 
      be output. 
    threshold: the value of numpy.array2string threshold parameter. 
    **kwargs: all other keyword args are printed before printing `arg`. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">emit_str(s: str):</span>
    <span class="s3">if </span><span class="s1">output_stream </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">output_stream.write(s + </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">print(s)</span>

  <span class="s3">if </span><span class="s1">transforms:</span>
    <span class="s1">kwargs[</span><span class="s4">'transforms'</span><span class="s1">] = [(name</span><span class="s3">, </span><span class="s1">params) </span><span class="s3">if </span><span class="s1">params </span><span class="s3">else </span><span class="s1">name</span>
                            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">params </span><span class="s3">in </span><span class="s1">transforms]</span>
  <span class="s3">if </span><span class="s1">device </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">kwargs[</span><span class="s4">'device'</span><span class="s1">] = device</span>
  <span class="s1">kv_pairs = </span><span class="s4">&quot; &quot;</span><span class="s1">.join([</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s4">: </span><span class="s3">{</span><span class="s1">v</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">sorted(kwargs.items())</span>
  <span class="s1">])</span>

  <span class="s3">def </span><span class="s1">pp_val(arg) -&gt; pp.Doc:</span>
    <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">tuple):</span>
      <span class="s3">return </span><span class="s1">pp.group(pp.concat([</span>
        <span class="s1">pp.text(</span><span class="s4">&quot;( &quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">pp.nest(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">pp.join(pp.brk()</span><span class="s3">, </span><span class="s1">[pp_val(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">arg]))</span><span class="s3">,</span>
        <span class="s1">pp.text(</span><span class="s4">&quot; )&quot;</span><span class="s1">)</span>
      <span class="s1">]))</span>
    <span class="s3">elif </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">list):</span>
      <span class="s3">return </span><span class="s1">pp.group(pp.concat([</span>
        <span class="s1">pp.text(</span><span class="s4">&quot;[ &quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">pp.nest(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">pp.join(pp.brk()</span><span class="s3">, </span><span class="s1">[pp_val(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">arg]))</span><span class="s3">,</span>
        <span class="s1">pp.text(</span><span class="s4">&quot; ]&quot;</span><span class="s1">)</span>
      <span class="s1">]))</span>
    <span class="s3">elif </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">dict):</span>
      <span class="s3">return </span><span class="s1">pp.group(pp.concat([</span>
        <span class="s1">pp.text(</span><span class="s4">&quot;{ &quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">pp.nest(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">pp.join(pp.brk()</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">pp.text(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s4">=&quot;</span><span class="s1">) + pp_val(v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">sorted(arg.items())</span>
        <span class="s1">]))</span><span class="s3">,</span>
        <span class="s1">pp.text(</span><span class="s4">&quot; }&quot;</span><span class="s1">)</span>
      <span class="s1">]))</span>
    <span class="s3">elif </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
      <span class="s3">return </span><span class="s1">pp.text(np.array2string(arg</span><span class="s3">, </span><span class="s1">threshold=threshold))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">pp.text(str(arg))</span>

  <span class="s3">with </span><span class="s1">_print_tap_lock:</span>
    <span class="s3">if </span><span class="s1">kv_pairs:</span>
      <span class="s1">emit_str(kv_pairs)</span>
    <span class="s1">emit_str(str(pp_val(arg)))</span>


<span class="s3">def </span><span class="s1">_values_to_avals(vals) -&gt; Sequence[core.ShapedArray]:</span>
  <span class="s3">return </span><span class="s1">tuple(core.raise_to_shaped(core.get_aval(v)) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vals)</span>

<span class="s0">### The id_tap_dep primitive</span>
<span class="s0"># The id_tap_dep_p primitive is used to create a dependency of the result of</span>
<span class="s0"># id_tap on the actual tap operation. This is only needed when the</span>
<span class="s0"># id_tap function is used with the `result` parameter. This primitive acts</span>
<span class="s0"># as the identity operator on the first argument.</span>
<span class="s0">#</span>
<span class="s0"># For example, given `id_tap(f, (a, b), result=(r, s)`, we convert this to</span>
<span class="s0">#</span>
<span class="s0">#    a1, b1 = outside_call_p(f, a, b)</span>
<span class="s0">#    r1 = id_tap_dep_p(r, a1)</span>
<span class="s0">#    s1 = id_tap_dep_p(s, a1)</span>
<span class="s0">#</span>
<span class="s0"># There are always two arguments and the result is equal to the first.</span>
<span class="s1">id_tap_dep_p = core.Primitive(</span><span class="s4">&quot;id_tap_dep&quot;</span><span class="s1">)</span>
<span class="s1">id_tap_dep_p.multiple_results = </span><span class="s3">False</span>
<span class="s1">id_tap_dep_p.def_impl(</span><span class="s3">lambda </span><span class="s1">r</span><span class="s3">, </span><span class="s1">_: r)</span>
<span class="s1">xla.register_translation(id_tap_dep_p</span><span class="s3">,</span>
                         <span class="s3">lambda </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">avals_in</span><span class="s3">, </span><span class="s1">avals_out</span><span class="s3">, </span><span class="s1">a_res</span><span class="s3">, </span><span class="s1">a_tap: [a_res])</span>
<span class="s1">id_tap_dep_p.def_abstract_eval(</span><span class="s3">lambda </span><span class="s1">r_a</span><span class="s3">, </span><span class="s1">_: r_a)</span>

<span class="s3">def </span><span class="s1">_id_tap_dep_jvp_rule(primals</span><span class="s3">, </span><span class="s1">tangents):</span>
  <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s3">assert False</span>
  <span class="s1">tangents_instantiated = tuple(map(_instantiate_zeros</span><span class="s3">, </span><span class="s1">tangents</span><span class="s3">, </span><span class="s1">primals))</span>
  <span class="s3">return </span><span class="s1">(id_tap_dep_p.bind(primals[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">primals[</span><span class="s5">1</span><span class="s1">])</span><span class="s3">,</span>
          <span class="s1">id_tap_dep_p.bind(tangents_instantiated[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tangents_instantiated[</span><span class="s5">1</span><span class="s1">]))</span>

<span class="s1">ad.primitive_jvps[id_tap_dep_p] = _id_tap_dep_jvp_rule</span>

<span class="s3">def </span><span class="s1">_id_tap_dep_transpose_rule(cts</span><span class="s3">, </span><span class="s1">arg_res</span><span class="s3">, </span><span class="s1">arg_tap):</span>
  <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s3">assert False</span>
  <span class="s3">if </span><span class="s1">ad.is_undefined_primal(arg_res):</span>
    <span class="s1">ct_res = _instantiate_zeros(cts</span><span class="s3">, </span><span class="s1">arg_res)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">ct_res = </span><span class="s3">None</span>
  <span class="s3">if </span><span class="s1">ad.is_undefined_primal(arg_tap):</span>
    <span class="s1">ct_tap = ad.Zero(arg_tap.aval)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">ct_tap = </span><span class="s3">None</span>
  <span class="s3">return </span><span class="s1">(ct_res</span><span class="s3">, </span><span class="s1">ct_tap)</span>

<span class="s1">ad.primitive_transposes[id_tap_dep_p] = _id_tap_dep_transpose_rule</span>


<span class="s3">def </span><span class="s1">_id_tap_dep_batching_rule(batched_args</span><span class="s3">, </span><span class="s1">batch_dims):</span>
  <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s3">assert False</span>
  <span class="s1">arg_res</span><span class="s3">, </span><span class="s1">arg_tap = batched_args</span>
  <span class="s3">return </span><span class="s1">id_tap_dep_p.bind(arg_res</span><span class="s3">, </span><span class="s1">arg_tap)</span><span class="s3">, </span><span class="s1">batch_dims[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s1">batching.primitive_batchers[id_tap_dep_p] = _id_tap_dep_batching_rule</span>

<span class="s0">### The outside_call primitive</span>
<span class="s4">&quot;&quot;&quot; 
This primitive is used to implement the `call` and `id_tap` functions. 
It takes several positional arguments that are the flattened 
according to `arg_treedef`. 
The result of the primitive is computed based on the `identity` parameter, 
as follows: 
 
  * if `identity` is True, then the results are the same as the 
  positional arguments of the primitive (except perhaps the last couple of 
  arguments, see `has_token`). In this case, `result_treedef` and 
  `flat_results_aval` are ignored, and `args_treedef` describes the result also. 
  * if `identity` is False, then the results are those from 
  the call to the outside computation: 
 
     flatten(callback(arg_treedef.unflatten(args), device=...)) 
 
   In this case, the callback results must match `result_treedef` 
   and `flat_results_aval`. 
 
It takes the following parameters: 
 
  * callback: the function to invoke with the unflattened arguments, 
    the device and the transforms: `callback(arrays, device, transforms)` 
  * arg_treedef: the treedef for the argument. 
  * identity: see description above. 
  * result_treedef, flat_results_aval: describes the expected result of the 
    callback. Only used when not `identity`. 
  * transforms: a tuple of the transformations that have been applied. Each 
    element of the tuple is itself a tuple with the first element the name 
    of the transform. The remaining elements depend on the transform. For 
    example, for `batch`, the parameters are the dimensions that have been 
    batched, and for `mask` the logical shapes. These are unpacked by 
    _outside_call_run_callback before passing to the user function. 
  * has_token: a boolean, when True it means that the last positional argument 
    is the current token. In this case, the result of the primitive is 
    going to be the non-token positional arguments, along with the updated 
    token. The tokens and this parameter are added after all the JAX 
    transformations, just before staging XLA. 
  * device_index: an integer, denotes from which device the invocation is from. 
    Works only when using the outfeed implementation mechanism, i.e., does 
    not work on CPU unless --jax_host_callback_outfeed=True. 
&quot;&quot;&quot;</span>
<span class="s1">outside_call_p = core.Primitive(</span><span class="s4">&quot;outside_call&quot;</span><span class="s1">)</span>
<span class="s1">outside_call_p.multiple_results = </span><span class="s3">True</span>
<span class="s1">core.outfeed_primitives.add(outside_call_p)</span>


<span class="s3">def </span><span class="s1">_outside_call_abstract_eval(*args_a: pe.AbstractValue</span><span class="s3">,</span>
                                <span class="s1">identity</span><span class="s3">, </span><span class="s1">**params) -&gt; Sequence[pe.AbstractValue]:</span>
  <span class="s3">if </span><span class="s1">identity:</span>
    <span class="s0"># Do some validation here</span>
    <span class="s3">assert </span><span class="s4">&quot;result_treedef&quot; </span><span class="s3">not in </span><span class="s1">params</span>
    <span class="s3">assert </span><span class="s4">&quot;flat_results_aval&quot; </span><span class="s3">not in </span><span class="s1">params</span>
    <span class="s3">return </span><span class="s1">args_a</span>
  <span class="s3">assert </span><span class="s1">params[</span><span class="s4">&quot;device_index&quot;</span><span class="s1">] </span><span class="s3">is not None</span>
  <span class="s3">assert </span><span class="s1">params[</span><span class="s4">&quot;result_treedef&quot;</span><span class="s1">] </span><span class="s3">is not None</span>
  <span class="s3">assert </span><span class="s1">params[</span><span class="s4">&quot;flat_results_aval&quot;</span><span class="s1">] </span><span class="s3">is not None</span>
  <span class="s1">flat_results_aval = params[</span><span class="s4">&quot;flat_results_aval&quot;</span><span class="s1">]</span>
  <span class="s3">if </span><span class="s4">&quot;has_token&quot; </span><span class="s3">in </span><span class="s1">params </span><span class="s3">and </span><span class="s1">params[</span><span class="s4">&quot;has_token&quot;</span><span class="s1">]:</span>
    <span class="s3">assert </span><span class="s1">len(args_a) &gt;= </span><span class="s5">2</span>
    <span class="s3">return </span><span class="s1">flat_results_aval + args_a[-</span><span class="s5">2</span><span class="s1">:]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">flat_results_aval</span>


<span class="s1">outside_call_p.def_abstract_eval(_outside_call_abstract_eval)</span>


<span class="s3">def </span><span class="s1">_outside_call_impl(*args</span><span class="s3">, </span><span class="s1">**params):</span>
  <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">params</span>
  <span class="s3">if </span><span class="s1">_inline_host_callback():</span>
    <span class="s1">device_index = params[</span><span class="s4">&quot;device_index&quot;</span><span class="s1">]</span>
    <span class="s1">device = xb.devices()[device_index]</span>
    <span class="s1">results = _outside_call_run_callback(args</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">send_infeed=</span><span class="s3">False, </span><span class="s1">**params)</span>
    <span class="s3">return </span><span class="s1">results</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s0"># We use the jitted-version of the primitive even for eager execution, both</span>
    <span class="s0"># so that we do not duplicate logic, but also so that all outfeed is received</span>
    <span class="s0"># by the outfeed_listeners, in the same thread from a given device. If we were</span>
    <span class="s0"># to process the tap here, it would be coming from the main thread. Also,</span>
    <span class="s0"># even in eager execution some primitives, such as while, are compiled.</span>
    <span class="s0"># It would be confusing to process a sequence &quot;id_tap; while&quot; in two</span>
    <span class="s0"># different threads.</span>
    <span class="s3">return </span><span class="s1">dispatch.apply_primitive(outside_call_p</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params)</span>


<span class="s1">outside_call_p.def_impl(_outside_call_impl)</span>


<span class="s3">def </span><span class="s1">_outside_call_translation_rule(ctx</span><span class="s3">,</span>
                                   <span class="s1">avals_in</span><span class="s3">,</span>
                                   <span class="s1">avals_out</span><span class="s3">,</span>
                                   <span class="s1">*args_op: XlaOp</span><span class="s3">,</span>
                                   <span class="s1">has_token</span><span class="s3">,</span>
                                   <span class="s1">identity</span><span class="s3">,</span>
                                   <span class="s1">device_index</span><span class="s3">,</span>
                                   <span class="s1">flat_results_aval=()</span><span class="s3">,</span>
                                   <span class="s1">**params):</span>
  <span class="s0"># We expect the current tokens at the end, inserted by _rewrite_jaxpr.</span>
  <span class="s3">assert </span><span class="s1">has_token</span>
  <span class="s1">current_token = args_op[-</span><span class="s5">2</span><span class="s1">]</span>
  <span class="s1">current_itoken = args_op[-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">comp = ctx.builder</span>
  <span class="s3">assert </span><span class="s1">comp.get_shape(current_token).is_token() </span><span class="s3">and </span><span class="s1">comp.get_shape(current_itoken).is_token()</span><span class="s3">, </span><span class="s1">(</span>
      <span class="s4">&quot;The last two arguments must be tokens&quot;</span><span class="s1">)</span>

  <span class="s1">args_to_outfeed = args_op[:-</span><span class="s5">2</span><span class="s1">]</span>
  <span class="s0"># Some platforms refuse to infeed empty arrays. We generate constants</span>
  <span class="s0"># instead.</span>
  <span class="s1">non_empty_flat_results_aval = list(filter(</span><span class="s3">lambda </span><span class="s1">aval: </span><span class="s3">not </span><span class="s1">(_aval_is_empty(aval))</span><span class="s3">,</span>
                                            <span class="s1">flat_results_aval))</span>
  <span class="s1">need_callback_results_on_device = (</span><span class="s3">not </span><span class="s1">identity </span><span class="s3">and</span>
                                     <span class="s1">len(non_empty_flat_results_aval) &gt; </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">use_outfeed = _use_outfeed(ctx.platform)</span>
  <span class="s0"># TODO(sharadmv): Delete non-outfeed path when jaxlib minimum version is</span>
  <span class="s0"># bumped past 0.3.8.</span>
  <span class="s3">assert </span><span class="s1">use_outfeed</span><span class="s3">, </span><span class="s4">'Should be using MLIR path for `CustomCall` lowering'</span>
  <span class="s1">send_infeed = use_outfeed </span><span class="s3">and </span><span class="s1">need_callback_results_on_device</span>
  <span class="s1">generated_infeed = </span><span class="s3">False  </span><span class="s0"># Keep track if we emitted an infeed op</span>
  <span class="s3">if </span><span class="s1">use_outfeed:</span>
    <span class="s1">_raise_if_using_outfeed_with_pjrt_c_api(xb.get_backend(ctx.platform))</span>
    <span class="s1">callback_id = _register_callback(</span>
        <span class="s1">functools.partial(</span>
            <span class="s1">_outside_call_run_callback</span><span class="s3">,</span>
            <span class="s1">send_infeed=send_infeed</span><span class="s3">,</span>
            <span class="s1">identity=identity</span><span class="s3">,</span>
            <span class="s1">flat_results_aval=flat_results_aval</span><span class="s3">,</span>
            <span class="s1">**params))</span>
    <span class="s1">next_token = _callback_handler_data.receiver.add_outfeed(</span>
        <span class="s1">comp</span><span class="s3">, </span><span class="s1">current_token</span><span class="s3">, </span><span class="s1">callback_id</span><span class="s3">, </span><span class="s1">args_to_outfeed</span><span class="s3">, </span><span class="s1">device_index)</span>
    <span class="s3">if </span><span class="s1">identity:</span>
      <span class="s1">results = list(args_to_outfeed)</span>
      <span class="s1">next_itoken = current_itoken</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">empty_results = [</span>
          <span class="s1">xops.ConstantLiteral(comp</span><span class="s3">, </span><span class="s1">np.zeros(aval.shape</span><span class="s3">, </span><span class="s1">aval.dtype))</span>
          <span class="s3">for </span><span class="s1">aval </span><span class="s3">in </span><span class="s1">flat_results_aval</span>
          <span class="s3">if </span><span class="s1">_aval_is_empty(aval)</span>
      <span class="s1">]</span>
      <span class="s3">if </span><span class="s1">non_empty_flat_results_aval:</span>
        <span class="s3">assert </span><span class="s1">need_callback_results_on_device</span>
        <span class="s1">after_outfeed_itoken = xops.AfterAll(comp</span><span class="s3">, </span><span class="s1">[current_itoken</span><span class="s3">, </span><span class="s1">next_token])</span>
        <span class="s0"># We shard the infeed as AssignedDevice(device_index). This must match the</span>
        <span class="s0"># outfeed (from outfeed_receiver.cc). Since `lax.infeed` does not support</span>
        <span class="s0"># this kind of sharding, we use a custom translation for infeed.</span>
        <span class="s1">array_sharding_proto = xla_client.OpSharding()</span>
        <span class="s1">array_sharding_proto.type = xla_client.OpSharding.Type.MAXIMAL</span>
        <span class="s1">array_sharding_proto.tile_assignment_dimensions = [</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">array_sharding_proto.tile_assignment_devices = [device_index]</span>

        <span class="s1">token_sharding_proto = xla_client.OpSharding()</span>
        <span class="s1">token_sharding_proto.type = xla_client.OpSharding.Type.REPLICATED</span>
        <span class="s1">infeed_sharding_proto = xla.tuple_sharding_proto(</span>
            <span class="s1">[array_sharding_proto] * len(non_empty_flat_results_aval) +</span>
            <span class="s1">[token_sharding_proto])</span>

        <span class="s1">shape = [</span>
            <span class="s1">shape.with_major_to_minor_layout_if_absent()</span>
            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">non_empty_flat_results_aval</span>
            <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">xla.aval_to_xla_shapes(x)</span>
        <span class="s1">]</span>

        <span class="s1">build_infeed = functools.partial(xops.InfeedWithToken</span><span class="s3">,</span>
                                         <span class="s1">after_outfeed_itoken</span><span class="s3">,</span>
                                         <span class="s1">xla_client.Shape.tuple_shape(shape))</span>
        <span class="s1">outs_and_token = xla.with_sharding_proto(comp</span><span class="s3">, </span><span class="s1">infeed_sharding_proto</span><span class="s3">,</span>
                                                 <span class="s1">build_infeed)</span>
        <span class="s1">outs = xops.GetTupleElement(outs_and_token</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">next_itoken = xops.GetTupleElement(outs_and_token</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">non_empty_results = [</span>
            <span class="s1">xops.GetTupleElement(outs</span><span class="s3">, </span><span class="s1">i)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(non_empty_flat_results_aval))</span>
        <span class="s1">]</span>
        <span class="s1">generated_infeed = </span><span class="s3">True</span>
        <span class="s1">results = [</span>
            <span class="s1">empty_results.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">_aval_is_empty(result_aval) </span><span class="s3">else </span><span class="s1">non_empty_results.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">result_aval </span><span class="s3">in </span><span class="s1">flat_results_aval</span>
        <span class="s1">]</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">results = empty_results</span>
        <span class="s1">next_itoken = current_itoken</span>

  <span class="s3">else</span><span class="s1">:  </span><span class="s0"># !use_outfeed : CustomCall implementation</span>
    <span class="s3">if </span><span class="s1">device_index != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The device_index feature works only when using outfeed.&quot;</span><span class="s1">)</span>

    <span class="s0"># TODO(necula): this is a weak attempt to get the device. This works</span>
    <span class="s0"># inside pmap, but does not work when we just execute on a single device,</span>
    <span class="s0"># because in such executions we always get replica_id == 0.</span>
    <span class="s1">replica_id = xla_client.ops.ReplicaId(comp)</span>
    <span class="s1">callback_operands = (current_token</span><span class="s3">, </span><span class="s1">replica_id) + args_to_outfeed</span>
    <span class="s3">if </span><span class="s1">identity:</span>
      <span class="s1">callback_flat_results_aval = (core.abstract_token</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">callback_flat_results_aval = (core.abstract_token</span><span class="s3">,</span><span class="s1">) + flat_results_aval</span>

    <span class="s3">def </span><span class="s1">wrapped_callback(*args):</span>
      <span class="s1">token</span><span class="s3">, </span><span class="s1">replica_id</span><span class="s3">, </span><span class="s1">*arrays = args</span>
      <span class="s1">result_arrays = _outside_call_run_callback(</span>
          <span class="s1">arrays</span><span class="s3">,</span>
          <span class="s1">xb.local_devices()[replica_id]</span><span class="s3">,</span>
          <span class="s1">send_infeed=</span><span class="s3">False,</span>
          <span class="s0"># The same parameters as outside_call_p</span>
          <span class="s1">identity=identity</span><span class="s3">,</span>
          <span class="s1">flat_results_aval=flat_results_aval</span><span class="s3">,</span>
          <span class="s1">**params)</span>
      <span class="s3">if </span><span class="s1">identity:</span>
        <span class="s0"># For identity, we do not pass the any results back to the device</span>
        <span class="s1">result_arrays = ()</span>
      <span class="s3">return </span><span class="s1">(token</span><span class="s3">,</span><span class="s1">) + result_arrays</span>

    <span class="s1">result_shapes = [</span>
        <span class="s1">xla.aval_to_xla_shapes(res_aval)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">res_aval </span><span class="s3">in </span><span class="s1">callback_flat_results_aval</span>
    <span class="s1">]</span>
    <span class="s1">backend = ctx.module_context.backend</span>
    <span class="s1">token_and_results_op</span><span class="s3">, </span><span class="s1">keep_alive = backend.emit_python_callback(</span>
        <span class="s1">wrapped_callback</span><span class="s3">,</span>
        <span class="s1">comp</span><span class="s3">,</span>
        <span class="s1">callback_operands</span><span class="s3">,</span>
        <span class="s1">result_shapes</span><span class="s3">,</span>
        <span class="s1">operand_layouts=</span><span class="s3">None,</span>
        <span class="s1">has_side_effects=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">_callback_handler_data.keep_alives.append(keep_alive)</span>
    <span class="s1">next_token</span><span class="s3">, </span><span class="s1">*results = (xops.GetTupleElement(token_and_results_op</span><span class="s3">, </span><span class="s1">i)</span>
                            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(callback_flat_results_aval)))</span>
    <span class="s0"># We must put the two tokens at the end</span>
    <span class="s3">if </span><span class="s1">identity:</span>
      <span class="s1">results = list(args_to_outfeed)</span>
    <span class="s1">next_itoken = current_itoken</span>

  <span class="s3">assert </span><span class="s1">generated_infeed == send_infeed</span><span class="s3">, </span><span class="s1">(</span>
      <span class="s4">f&quot;generated_infeed (</span><span class="s3">{</span><span class="s1">generated_infeed</span><span class="s3">}</span><span class="s4">) != send_infeed (</span><span class="s3">{</span><span class="s1">send_infeed</span><span class="s3">}</span><span class="s4">)&quot;</span><span class="s1">)</span>
  <span class="s3">assert </span><span class="s1">identity </span><span class="s3">or </span><span class="s1">len(results) == len(flat_results_aval)</span><span class="s3">, </span><span class="s1">(</span>
      <span class="s4">f&quot;got </span><span class="s3">{</span><span class="s1">len(results)</span><span class="s3">} </span><span class="s4">but expected </span><span class="s3">{</span><span class="s1">len(flat_results_aval)</span><span class="s3">}</span><span class="s4">. &quot;</span>
      <span class="s4">f&quot;identity = </span><span class="s3">{</span><span class="s1">identity</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">results + [next_token</span><span class="s3">, </span><span class="s1">next_itoken]</span>


<span class="s1">xla.register_translation(outside_call_p</span><span class="s3">, </span><span class="s1">_outside_call_translation_rule)</span>


<span class="s3">def </span><span class="s1">_outside_call_lowering(ctx: mlir.LoweringRuleContext</span><span class="s3">,</span>
                           <span class="s1">*args</span><span class="s3">,</span>
                           <span class="s1">has_token: bool</span><span class="s3">,</span>
                           <span class="s1">identity: bool</span><span class="s3">,</span>
                           <span class="s1">device_index: int</span><span class="s3">,</span>
                           <span class="s1">flat_results_aval=()</span><span class="s3">,</span>
                           <span class="s1">**params):</span>
  <span class="s2">&quot;&quot;&quot;MLIR Lowering for `CustomCall`-based HCB.&quot;&quot;&quot;</span>
  <span class="s1">platform = ctx.module_context.platform</span>
  <span class="s1">use_outfeed = _use_outfeed(platform)</span>
  <span class="s3">if </span><span class="s1">use_outfeed:</span>
    <span class="s0"># Fall back to XLA path if we are using the outfeed</span>
    <span class="s0"># TODO(sharadmv): update to use MLIR for this path as well and delete</span>
    <span class="s0">#                 XLA lowering</span>
    <span class="s3">return </span><span class="s1">mlir.xla_fallback_lowering(outside_call_p)(</span>
        <span class="s1">ctx</span><span class="s3">,</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">has_token=has_token</span><span class="s3">,</span>
        <span class="s1">identity=identity</span><span class="s3">,</span>
        <span class="s1">flat_results_aval=flat_results_aval</span><span class="s3">,</span>
        <span class="s1">device_index=device_index</span><span class="s3">,</span>
        <span class="s1">**params)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">device_index != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The device_index feature works only when using outfeed.&quot;</span><span class="s1">)</span>
  <span class="s0"># We expect the current tokens at the end, inserted by _rewrite_jaxpr.</span>
  <span class="s3">assert </span><span class="s1">has_token</span>
  <span class="s1">current_token = args[-</span><span class="s5">2</span><span class="s1">]</span>
  <span class="s1">current_itoken = args[-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">assert </span><span class="s1">current_token.type == hlo.TokenType.get()</span><span class="s3">, </span><span class="s4">&quot;The last two arguments must be tokens&quot;</span>
  <span class="s3">assert </span><span class="s1">current_itoken.type == hlo.TokenType.get()</span><span class="s3">, </span><span class="s4">&quot;The last two arguments must be tokens&quot;</span>

  <span class="s1">args_to_outfeed = args[:-</span><span class="s5">2</span><span class="s1">]</span>
  <span class="s0"># TODO(necula): this is a weak attempt to get the device. This works</span>
  <span class="s0"># inside pmap, but does not work when we just execute on a single device,</span>
  <span class="s0"># because in such executions we always get replica_id == 0.</span>
  <span class="s1">replica_id = hlo.ReplicaIdOp()</span>
  <span class="s1">callback_operands = [replica_id</span><span class="s3">, </span><span class="s1">*args_to_outfeed]</span>
  <span class="s1">callback_operand_avals = [</span>
      <span class="s1">core.ShapedArray(()</span><span class="s3">, </span><span class="s1">np.uint32)</span><span class="s3">, </span><span class="s1">*ctx.avals_in[:-</span><span class="s5">2</span><span class="s1">]]</span>
  <span class="s3">if </span><span class="s1">identity:</span>
    <span class="s1">callback_flat_results_aval = []</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">callback_flat_results_aval = [*flat_results_aval]</span>

  <span class="s3">def </span><span class="s1">wrapped_callback(*args):</span>
    <span class="s1">replica_id</span><span class="s3">, </span><span class="s1">*arrays = args</span>
    <span class="s1">result_arrays = _outside_call_run_callback(</span>
        <span class="s1">arrays</span><span class="s3">,</span>
        <span class="s1">xb.local_devices()[replica_id]</span><span class="s3">,</span>
        <span class="s1">send_infeed=</span><span class="s3">False,</span>
        <span class="s0"># The same parameters as outside_call_p</span>
        <span class="s1">identity=identity</span><span class="s3">,</span>
        <span class="s1">flat_results_aval=flat_results_aval</span><span class="s3">,</span>
        <span class="s1">**params)</span>
    <span class="s3">if </span><span class="s1">identity:</span>
      <span class="s0"># For identity, we do not pass the any results back to the device</span>
      <span class="s1">result_arrays = ()</span>
    <span class="s3">return </span><span class="s1">result_arrays</span>

  <span class="s3">if </span><span class="s1">isinstance(ctx.module_context.axis_context</span><span class="s3">,</span>
                <span class="s1">(mlir.SPMDAxisContext</span><span class="s3">, </span><span class="s1">mlir.ShardingContext)):</span>
    <span class="s0"># Apply maximal sharding so pjit only executes the callback on device device_index.</span>
    <span class="s1">sharding = xla_client.OpSharding()</span>
    <span class="s1">sharding.type = xla_client.OpSharding.Type.MAXIMAL</span>
    <span class="s1">sharding.tile_assignment_dimensions = [</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">sharding.tile_assignment_devices = [device_index]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">sharding = </span><span class="s3">None</span>
  <span class="s1">results</span><span class="s3">, </span><span class="s1">next_token</span><span class="s3">, </span><span class="s1">keep_alive = mlir.emit_python_callback(ctx</span><span class="s3">,</span>
      <span class="s1">wrapped_callback</span><span class="s3">, </span><span class="s1">current_token</span><span class="s3">, </span><span class="s1">callback_operands</span><span class="s3">,</span>
      <span class="s1">callback_operand_avals</span><span class="s3">, </span><span class="s1">callback_flat_results_aval</span><span class="s3">,  </span><span class="s0"># type: ignore[arg-type]</span>
      <span class="s1">has_side_effect=</span><span class="s3">True, </span><span class="s1">sharding=sharding)</span>
  <span class="s1">_callback_handler_data.keep_alives.append(keep_alive)</span>
  <span class="s0"># We must put the two tokens at the end</span>
  <span class="s3">if </span><span class="s1">identity:</span>
    <span class="s1">results = list(args_to_outfeed)</span>
  <span class="s1">next_itoken = current_itoken</span>

  <span class="s3">assert </span><span class="s1">identity </span><span class="s3">or </span><span class="s1">len(results) == len(flat_results_aval)</span><span class="s3">, </span><span class="s1">(</span>
      <span class="s4">f&quot;got </span><span class="s3">{</span><span class="s1">len(results)</span><span class="s3">} </span><span class="s4">but expected </span><span class="s3">{</span><span class="s1">len(flat_results_aval)</span><span class="s3">}</span><span class="s4">. &quot;</span>
      <span class="s4">f&quot;identity = </span><span class="s3">{</span><span class="s1">identity</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">results + [next_token</span><span class="s3">, </span><span class="s1">next_itoken]</span>

<span class="s1">mlir.register_lowering(outside_call_p</span><span class="s3">, </span><span class="s1">_outside_call_lowering</span><span class="s3">, </span><span class="s1">platform=</span><span class="s4">&quot;cpu&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_outside_call_run_callback(</span>
    <span class="s1">arrays</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
    <span class="s1">send_infeed=</span><span class="s3">True,</span>
    <span class="s0"># The same parameters as outside_call_p</span>
    <span class="s1">callback</span><span class="s3">, </span><span class="s1">arg_treedef</span><span class="s3">,</span>
    <span class="s1">identity</span><span class="s3">, </span><span class="s1">result_treedef=</span><span class="s3">None, </span><span class="s1">flat_results_aval=</span><span class="s3">None,</span>
    <span class="s1">transforms=()</span><span class="s3">, </span><span class="s1">has_token=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Performs the callback: 
       callback(arg, device, transforms) 
 
  Called during the device computation once we have the argument, either from 
  an inlined callback or from an XLA computation outfeed. 
 
  Returns the flat list of result arrays. If `send_infeed` then it will also send 
  the flat list of results to the device. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">_unpack_transforms(transforms) -&gt; Tuple[Tuple[str</span><span class="s3">, </span><span class="s1">Dict[str</span><span class="s3">, </span><span class="s1">Any]]</span><span class="s3">, </span><span class="s1">...]:</span>
    <span class="s3">def </span><span class="s1">_unpack_transform(name</span><span class="s3">, </span><span class="s1">*params):</span>
      <span class="s3">if </span><span class="s1">name == </span><span class="s4">&quot;batch&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">dict(batch_dims=params[</span><span class="s5">0</span><span class="s1">])</span>
      <span class="s3">elif </span><span class="s1">name == </span><span class="s4">&quot;mask&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">dict(logical_shapes=</span><span class="s5">5</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">assert not </span><span class="s1">params</span><span class="s3">, </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">params</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">dict()</span>

    <span class="s3">return </span><span class="s1">tuple(_unpack_transform(*t) </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">transforms)</span>

  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">arg = api.tree_unflatten(arg_treedef</span><span class="s3">, </span><span class="s1">arrays)</span>
    <span class="s1">unpacked_transforms = _unpack_transforms(transforms)</span>
    <span class="s1">logger.debug(</span>
      <span class="s4">&quot;Outside call invoking call_func %s, device=%s, transforms=%s&quot;</span><span class="s3">,</span>
      <span class="s1">callback</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">unpacked_transforms</span>
    <span class="s1">)</span>
    <span class="s1">res = callback(arg</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">unpacked_transforms)</span>
    <span class="s3">if </span><span class="s1">identity:</span>
      <span class="s3">return </span><span class="s1">tuple(arrays)</span>

    <span class="s3">else</span><span class="s1">:  </span><span class="s0"># Check the type of the callback results</span>
      <span class="s3">assert </span><span class="s1">result_treedef </span><span class="s3">is not None</span>
      <span class="s3">assert </span><span class="s1">flat_results_aval </span><span class="s3">is not None</span>
      <span class="s1">actual_flat_results</span><span class="s3">, </span><span class="s1">actual_result_treedef = pytree.flatten(res)</span>
      <span class="s3">if </span><span class="s1">actual_result_treedef != result_treedef:</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;Callback func </span><span class="s3">{</span><span class="s1">callback</span><span class="s3">} </span><span class="s4">should have returned a result &quot;</span>
               <span class="s4">f&quot;with pytree </span><span class="s3">{</span><span class="s1">result_treedef</span><span class="s3">} </span><span class="s4">but returned &quot;</span>
               <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">actual_result_treedef</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">TypeError(msg)</span>

      <span class="s1">canonical_flat_results = tuple(util.safe_map(xla.canonicalize_dtype</span><span class="s3">, </span><span class="s1">actual_flat_results))</span>
      <span class="s1">actual_flat_results_aval = _values_to_avals(canonical_flat_results)</span>
      <span class="s1">logger.debug(</span>
        <span class="s4">&quot;Outside call %s result %s. Sending to infeed for device %s.&quot;</span><span class="s3">,</span>
        <span class="s1">callback</span><span class="s3">, </span><span class="s1">flat_results_aval</span><span class="s3">, </span><span class="s1">device</span><span class="s3">,</span>
        <span class="s1">)</span>

      <span class="s3">if not </span><span class="s1">all(ea.strip_weak_type() == ra.strip_weak_type()</span>
                 <span class="s3">for </span><span class="s1">ea</span><span class="s3">, </span><span class="s1">ra </span><span class="s3">in </span><span class="s1">util.safe_zip(flat_results_aval</span><span class="s3">,</span>
                                             <span class="s1">actual_flat_results_aval)):</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;Callback func </span><span class="s3">{</span><span class="s1">callback</span><span class="s3">} </span><span class="s4">should have returned a result &quot;</span>
               <span class="s4">&quot;with abstract values &quot;</span>
               <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">result_treedef.unflatten(flat_results_aval)</span><span class="s3">} </span><span class="s4">&quot;</span>
               <span class="s4">f&quot;but returned </span><span class="s3">{</span><span class="s1">actual_result_treedef.unflatten(actual_flat_results_aval)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">TypeError(msg)</span>

      <span class="s3">if </span><span class="s1">send_infeed:</span>
        <span class="s0"># Do not send the 0-sized arrays</span>
        <span class="s1">non_empty_canonical_flat_results = tuple(filter(</span><span class="s3">lambda </span><span class="s1">r: </span><span class="s3">not </span><span class="s1">_aval_is_empty(r)</span><span class="s3">,</span>
                                                        <span class="s1">canonical_flat_results))</span>
        <span class="s1">device.transfer_to_infeed(non_empty_canonical_flat_results)</span>
      <span class="s3">return </span><span class="s1">canonical_flat_results</span>

  <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
    <span class="s1">logger.error(</span><span class="s4">&quot;Outside call %s threw exception %s.&quot;</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">e)</span>
    <span class="s3">if </span><span class="s1">send_infeed:</span>
      <span class="s0"># Prepare some results to send in case of error. We are sending something</span>
      <span class="s0"># with a distinctive shape (int8[12345]), one that is unlikely to be what the device</span>
      <span class="s0"># expects. This should have the effect to abort the device computation,</span>
      <span class="s0"># with an error message that we recognize. On TPU there seem to be no</span>
      <span class="s0"># such check, and if we send anything at all the device computation will</span>
      <span class="s0"># use some garbage data. So, on TPU we prefer to not send anything and let</span>
      <span class="s0"># the computation hang.</span>
      <span class="s0"># TODO: implement a proper error handling for TPU</span>
      <span class="s3">if </span><span class="s1">device.platform != </span><span class="s4">&quot;tpu&quot;</span><span class="s1">:</span>
        <span class="s1">canonical_flat_results = [xla.canonicalize_dtype(np.arange(</span><span class="s5">12345</span><span class="s3">, </span><span class="s1">dtype=np.int8))]</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;Outside call consumer %s exception %s. Sending to infeed the error result.&quot;</span><span class="s3">,</span>
                     <span class="s1">callback</span><span class="s3">, </span><span class="s1">e)</span>
        <span class="s1">device.transfer_to_infeed(tuple(canonical_flat_results))</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;Outside call consumer %s exception %s. On TPU we do not send infeed.&quot;</span><span class="s3">,</span>
                     <span class="s1">callback</span><span class="s3">, </span><span class="s1">e)</span>
    <span class="s3">raise </span><span class="s1">e  </span><span class="s0"># Let the exception propagate</span>


<span class="s3">def </span><span class="s1">_add_transform(params: Dict</span><span class="s3">, </span><span class="s1">name: str</span><span class="s3">, </span><span class="s1">*transform_params) -&gt; Dict:</span>
  <span class="s2">&quot;&quot;&quot;Adds the `transform` to the params[&quot;transforms&quot;]. 
 
  Uses a tuple representation internally, will be unpacked before the 
  callback by _ConsumerCallable. 
  &quot;&quot;&quot;</span>
  <span class="s1">new_transform = (name</span><span class="s3">, </span><span class="s1">*transform_params)</span>
  <span class="s3">return </span><span class="s1">dict(</span>
      <span class="s1">params</span><span class="s3">, </span><span class="s1">transforms=(params.get(</span><span class="s4">&quot;transforms&quot;</span><span class="s3">, </span><span class="s1">()) + (new_transform</span><span class="s3">,</span><span class="s1">)))</span>


<span class="s3">def </span><span class="s1">_aval_is_empty(aval) -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">np.prod(aval.shape) == </span><span class="s5">0</span>

<span class="s3">def </span><span class="s1">_instantiate_zeros(tan</span><span class="s3">, </span><span class="s1">arg):</span>
  <span class="s2">&quot;&quot;&quot;Turn special ad.zero tangents into arrays of 0s for sending to host. 
  Args: 
    tan: the tangent. 
    arg: the argument for which we need to instantiate the tangent 
 
  Returns: tan if is is not ad.Zero, otherwise a 0 array of appropriate type 
    and shape 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">type(tan) </span><span class="s3">is not </span><span class="s1">ad.Zero:</span>
    <span class="s3">return </span><span class="s1">tan</span>
  <span class="s3">return </span><span class="s1">ad.instantiate_zeros_aval(tan.aval</span><span class="s3">, </span><span class="s1">tan)</span>

<span class="s3">def </span><span class="s1">_outside_call_jvp_rule(primals</span><span class="s3">, </span><span class="s1">tangents</span><span class="s3">, </span><span class="s1">**params):</span>
  <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">params</span>
  <span class="s3">if not </span><span class="s1">params[</span><span class="s4">&quot;identity&quot;</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;JVP rule is implemented only for id_tap, not for call.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s1">tangents_instantiated = tuple(map(_instantiate_zeros</span><span class="s3">, </span><span class="s1">tangents</span><span class="s3">, </span><span class="s1">primals))</span>

    <span class="s1">arg_treedef = params[</span><span class="s4">&quot;arg_treedef&quot;</span><span class="s1">]</span>
    <span class="s0"># The argument to the jvp tap is a pair of the tapped primals and tangents</span>
    <span class="s1">jvp_flat_args</span><span class="s3">, </span><span class="s1">jvp_arg_treedef = api.tree_flatten(</span>
        <span class="s1">(arg_treedef.unflatten(primals)</span><span class="s3">,</span>
         <span class="s1">arg_treedef.unflatten(tangents_instantiated)))</span>
    <span class="s1">out_all = outside_call_p.bind(</span>
        <span class="s1">*jvp_flat_args</span><span class="s3">,</span>
        <span class="s1">**dict(_add_transform(params</span><span class="s3">, </span><span class="s4">&quot;jvp&quot;</span><span class="s1">)</span><span class="s3">,</span>
               <span class="s1">arg_treedef=jvp_arg_treedef</span><span class="s3">,</span>
               <span class="s1">))</span>
    <span class="s1">out_primals_tapped</span><span class="s3">, </span><span class="s1">out_tangents_tapped = util.split_list(out_all</span><span class="s3">, </span><span class="s1">[len(primals)])</span>
    <span class="s3">return </span><span class="s1">tuple(out_primals_tapped)</span><span class="s3">, </span><span class="s1">tuple(out_tangents_tapped)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">out_primals_tapped = outside_call_p.bind(*primals</span><span class="s3">, </span><span class="s1">**params)</span>
    <span class="s3">return </span><span class="s1">tuple(out_primals_tapped)</span><span class="s3">, </span><span class="s1">tangents</span>


<span class="s1">ad.primitive_jvps[outside_call_p] = _outside_call_jvp_rule</span>


<span class="s3">def </span><span class="s1">_outside_call_partial_eval_rule(trace</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
  <span class="s0"># partial eval is used after jvp and before transpose.</span>
  <span class="s3">if not </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s0"># TODO: just remote the partial eval rule</span>
    <span class="s3">return </span><span class="s1">trace.default_process_primitive(outside_call_p</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">params)</span>
  <span class="s1">transforms = params.get(</span><span class="s4">&quot;transforms&quot;</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s3">if not </span><span class="s1">transforms </span><span class="s3">or </span><span class="s1">transforms[-</span><span class="s5">1</span><span class="s1">] != (</span><span class="s4">&quot;jvp&quot;</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s0"># We are not in the process of computing VJP</span>
    <span class="s3">return </span><span class="s1">trace.default_process_primitive(outside_call_p</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">params)</span>

  <span class="s0"># The args have been prepared by the id_tap_jvp_rule: primals, tangents. The</span>
  <span class="s0"># result is a pair of the primal outputs and output tangents.</span>
  <span class="s0"># One invariant that JAX requires is that if the primals arguments are known</span>
  <span class="s0"># then the primal outputs must be known. So, if the primal arguments are known</span>
  <span class="s0"># and some of the tangents are unknown, then we must split the tap into</span>
  <span class="s0"># one for the primals (thus the output will be considered known), and a</span>
  <span class="s0"># separate tap for the tangents.</span>
  <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">params</span>
  <span class="s3">if not </span><span class="s1">params[</span><span class="s4">&quot;identity&quot;</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;differentiation rules are implemented only for id_tap, not for call.&quot;</span><span class="s1">)</span>

  <span class="s3">assert </span><span class="s1">len(args) % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span>
  <span class="s1">nr_primals = len(args) // </span><span class="s5">2</span>
  <span class="s1">primals</span><span class="s3">, </span><span class="s1">tangents = util.split_list(args</span><span class="s3">, </span><span class="s1">[nr_primals])</span>
  <span class="s1">all_primals_known = all(p.is_known() </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">primals)</span>
  <span class="s1">some_tangents_unknown = any(</span><span class="s3">not </span><span class="s1">t.is_known() </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tangents)</span>

  <span class="s3">if not </span><span class="s1">(all_primals_known </span><span class="s3">and </span><span class="s1">some_tangents_unknown):</span>
    <span class="s3">return </span><span class="s1">trace.default_process_primitive(outside_call_p</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">params)</span>

  <span class="s1">prims</span><span class="s3">, </span><span class="s1">_ = params[</span><span class="s4">&quot;arg_treedef&quot;</span><span class="s1">].unflatten(args)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">primals_treedef = api.tree_flatten(prims)</span>

  <span class="s1">outs_known = trace.default_process_primitive(</span>
      <span class="s1">outside_call_p</span><span class="s3">, </span><span class="s1">primals</span><span class="s3">,</span>
      <span class="s1">dict(params</span><span class="s3">,</span>
           <span class="s1">arg_treedef=primals_treedef</span><span class="s3">,</span>
           <span class="s1">transforms=transforms[:-</span><span class="s5">1</span><span class="s1">]))</span>
  <span class="s0"># Now compute the unknowns using the whole tap, and merge them with the tapped ones</span>
  <span class="s1">outs_all_unknown = trace.default_process_primitive(outside_call_p</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">params)</span>
  <span class="s1">outs_primals_unknown</span><span class="s3">, </span><span class="s1">outs_tangents_unknown = util.split_list(</span>
      <span class="s1">outs_all_unknown</span><span class="s3">, </span><span class="s1">[nr_primals])</span>
  <span class="s1">outs_combined = (</span>
      <span class="s1">[pe.JaxprTracer(trace</span><span class="s3">, </span><span class="s1">pe.PartialVal.known(primal_known)</span><span class="s3">,</span>
                      <span class="s1">primal_unknown.recipe)</span>
       <span class="s3">for </span><span class="s1">primal_known</span><span class="s3">, </span><span class="s1">primal_unknown </span><span class="s3">in </span><span class="s1">util.safe_zip(outs_known</span><span class="s3">, </span><span class="s1">outs_primals_unknown)] +</span>
      <span class="s1">outs_tangents_unknown)</span>
  <span class="s3">return </span><span class="s1">tuple(outs_combined)</span>


<span class="s1">pe.custom_partial_eval_rules[outside_call_p] = _outside_call_partial_eval_rule</span>


<span class="s3">def </span><span class="s1">_outside_call_transpose_rule(cts</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**params):</span>
  <span class="s3">if not </span><span class="s1">params[</span><span class="s4">&quot;identity&quot;</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;differentiation rules are implemented only for id_tap, not for call.&quot;</span><span class="s1">)</span>
  <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">params</span>
  <span class="s3">assert </span><span class="s1">len(cts) == len(args)</span>
  <span class="s1">cts_instantiated = tuple(map(_instantiate_zeros</span><span class="s3">, </span><span class="s1">cts</span><span class="s3">, </span><span class="s1">args))</span>

  <span class="s0"># The args have been prepared by the id_tap_jvp_rule: tapped_primals, tapped_tangents, rest_primals, rest_tangents</span>
  <span class="s1">transforms = params.get(</span><span class="s4">&quot;transforms&quot;</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s3">if not </span><span class="s1">transforms </span><span class="s3">or </span><span class="s1">transforms[-</span><span class="s5">1</span><span class="s1">] != (</span><span class="s4">&quot;jvp&quot;</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s0"># TODO: I should understand better when can this happen. It seems to arise</span>
    <span class="s0"># in scan.</span>
    <span class="s3">return </span><span class="s1">outside_call_p.bind(</span>
        <span class="s1">*cts_instantiated</span><span class="s3">,</span>
        <span class="s1">**_add_transform(params</span><span class="s3">, </span><span class="s4">&quot;transpose&quot;</span><span class="s1">))</span>

  <span class="s3">if not </span><span class="s1">FLAGS.jax_host_callback_ad_transforms:</span>
    <span class="s3">assert False</span>

  <span class="s3">assert </span><span class="s1">len(args) % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span>
  <span class="s1">nr_primals = len(args) // </span><span class="s5">2</span>

  <span class="s1">args_unflat</span><span class="s3">, </span><span class="s1">tan_unflat = params[</span><span class="s4">&quot;arg_treedef&quot;</span><span class="s1">].unflatten(args)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">vjp_arg_treedef = api.tree_flatten(args_unflat)</span>
  <span class="s0"># We want to tap the cts_tapped_tangents</span>
  <span class="s1">cts_primals</span><span class="s3">, </span><span class="s1">cts_tangents = util.split_list(cts_instantiated</span><span class="s3">, </span><span class="s1">[nr_primals])</span>
  <span class="s1">cts_tangents_through_tap = outside_call_p.bind(</span>
      <span class="s1">*cts_tangents</span><span class="s3">,</span>
      <span class="s1">**dict(_add_transform(params</span><span class="s3">, </span><span class="s4">&quot;transpose&quot;</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s1">arg_treedef=vjp_arg_treedef))</span>
  <span class="s3">return </span><span class="s1">cts_primals + cts_tangents_through_tap</span>


<span class="s1">ad.primitive_transposes[outside_call_p] = _outside_call_transpose_rule</span>


<span class="s3">def </span><span class="s1">_outside_call_batching_rule(batched_args</span><span class="s3">, </span><span class="s1">batch_dims</span><span class="s3">, </span><span class="s1">**params):</span>
  <span class="s3">if not </span><span class="s1">params[</span><span class="s4">&quot;identity&quot;</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;batching rules are implemented only for id_tap, not for call.&quot;</span><span class="s1">)</span>
  <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">params</span>
  <span class="s1">new_params = _add_transform(params</span><span class="s3">, </span><span class="s4">&quot;batch&quot;</span><span class="s3">, </span><span class="s1">batch_dims)</span>
  <span class="s1">res = outside_call_p.bind(*batched_args</span><span class="s3">, </span><span class="s1">**new_params)</span>
  <span class="s3">return </span><span class="s1">res</span><span class="s3">, </span><span class="s1">batch_dims</span>


<span class="s1">batching.primitive_batchers[outside_call_p] = _outside_call_batching_rule</span>

<span class="s0">####</span>
<span class="s0">#### Jaxpr rewriting logic to thread the tokens through stateful primitives.</span>
<span class="s0">####</span>


<span class="s3">def </span><span class="s1">_rewrite_closed_jaxpr(cjaxpr: core.ClosedJaxpr</span><span class="s3">, </span><span class="s1">has_input_token: bool</span><span class="s3">,</span>
                          <span class="s1">has_output_token: bool) -&gt; core.ClosedJaxpr:</span>
  <span class="s2">&quot;&quot;&quot;Rewrites a ClosedJaxpr to thread the token, if needed.&quot;&quot;&quot;</span>
  <span class="s1">new_jaxpr = _rewrite_jaxpr(cjaxpr.jaxpr</span><span class="s3">, </span><span class="s1">has_input_token</span><span class="s3">, </span><span class="s1">has_output_token)</span>
  <span class="s3">return </span><span class="s1">core.ClosedJaxpr(new_jaxpr</span><span class="s3">, </span><span class="s1">cjaxpr.consts)</span>


<span class="s3">def </span><span class="s1">_rewrite_jaxpr(jaxpr: core.Jaxpr</span><span class="s3">, </span><span class="s1">has_input_token: bool</span><span class="s3">,</span>
                   <span class="s1">has_output_token: bool) -&gt; core.Jaxpr:</span>
  <span class="s2">&quot;&quot;&quot;Rewrite a Jaxpr to thread the token, if needed.&quot;&quot;&quot;</span>
  <span class="s3">assert </span><span class="s1">has_input_token </span><span class="s3">or not </span><span class="s1">has_output_token</span>

  <span class="s3">if not </span><span class="s1">has_input_token </span><span class="s3">and not </span><span class="s1">core.jaxpr_uses_outfeed(jaxpr):</span>
    <span class="s3">return </span><span class="s1">jaxpr</span>

  <span class="s1">mk_new_var = core.gensym([jaxpr])</span>

  <span class="s1">eqns: List[core.JaxprEqn] = []</span>
  <span class="s0"># store the incoming tokens</span>
  <span class="s1">last_token_var = mk_new_var(core.abstract_token)</span>
  <span class="s1">last_itoken_var = mk_new_var(core.abstract_token)</span>
  <span class="s3">if </span><span class="s1">has_input_token:</span>
    <span class="s1">invars = jaxpr.invars + [last_token_var</span><span class="s3">, </span><span class="s1">last_itoken_var]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">invars = jaxpr.invars</span>
    <span class="s0"># We need tokens but none is given in input; make one depending on all invars</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">core.new_jaxpr_eqn(jaxpr.invars</span><span class="s3">, </span><span class="s1">[last_token_var]</span><span class="s3">,</span>
                           <span class="s1">lax.create_token_p</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">core.no_effects</span><span class="s3">, </span><span class="s1">source_info_util.current()))</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">core.new_jaxpr_eqn(jaxpr.invars</span><span class="s3">, </span><span class="s1">[last_itoken_var]</span><span class="s3">,</span>
                           <span class="s1">lax.create_token_p</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">core.no_effects</span><span class="s3">, </span><span class="s1">source_info_util.current()))</span>

  <span class="s3">for </span><span class="s1">eqn </span><span class="s3">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s3">if not </span><span class="s1">core.primitive_uses_outfeed(eqn.primitive</span><span class="s3">, </span><span class="s1">eqn.params):</span>
      <span class="s1">eqns.append(eqn)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">output_token_var = mk_new_var(last_token_var.aval)</span>
      <span class="s1">output_itoken_var = mk_new_var(last_itoken_var.aval)</span>
      <span class="s1">_rewrite_eqn(eqn</span><span class="s3">, </span><span class="s1">eqns</span><span class="s3">, </span><span class="s1">last_token_var</span><span class="s3">, </span><span class="s1">output_token_var</span><span class="s3">,</span>
                   <span class="s1">last_itoken_var</span><span class="s3">, </span><span class="s1">output_itoken_var</span><span class="s3">, </span><span class="s1">mk_new_var)</span>
      <span class="s1">last_token_var = output_token_var</span>
      <span class="s1">last_itoken_var = output_itoken_var</span>

  <span class="s1">outvars = jaxpr.outvars + ([last_token_var</span><span class="s3">, </span><span class="s1">last_itoken_var] </span><span class="s3">if </span><span class="s1">has_output_token </span><span class="s3">else </span><span class="s1">[])</span>
  <span class="s1">new_jaxpr = core.Jaxpr(jaxpr.constvars</span><span class="s3">, </span><span class="s1">invars</span><span class="s3">, </span><span class="s1">outvars</span><span class="s3">, </span><span class="s1">eqns</span><span class="s3">, </span><span class="s1">jaxpr.effects)</span>
  <span class="s3">return </span><span class="s1">new_jaxpr</span>


<span class="s3">def </span><span class="s1">_rewrite_eqn(eqn: core.JaxprEqn</span><span class="s3">, </span><span class="s1">eqns: List[core.JaxprEqn]</span><span class="s3">,</span>
                 <span class="s1">input_token_var: core.Var</span><span class="s3">, </span><span class="s1">output_token_var: core.Var</span><span class="s3">,</span>
                 <span class="s1">input_itoken_var: core.Var</span><span class="s3">, </span><span class="s1">output_itoken_var: core.Var</span><span class="s3">,</span>
                 <span class="s1">mk_new_var: Callable[[core.AbstractValue]</span><span class="s3">, </span><span class="s1">core.Var]):</span>
  <span class="s2">&quot;&quot;&quot;Rewrite an `eqn` and append equations to `eqns`. 
 
  This is only called if the current primitive uses outfeed. 
  Assume that the current token is in `input_token_var` and the resulting 
  token must end in `output_token_var`. 
 
  Append the result of rewriting to `eqns`. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">outside_call_p:</span>
    <span class="s3">assert </span><span class="s4">&quot;has_token&quot; </span><span class="s3">not in </span><span class="s1">eqn.params</span>
    <span class="s1">eqns.append(eqn.replace(invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
                            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
                            <span class="s1">params=dict(eqn.params</span><span class="s3">, </span><span class="s1">has_token=</span><span class="s3">True</span><span class="s1">)))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">lax.while_p:</span>
    <span class="s1">cond_jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">body_jaxpr</span><span class="s3">, </span><span class="s1">_ = util.split_dict(</span>
        <span class="s1">eqn.params</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s4">&quot;cond_jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;cond_nconsts&quot;</span><span class="s3">, </span><span class="s4">&quot;body_jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;body_nconsts&quot;</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">core.jaxpr_uses_outfeed(cond_jaxpr.jaxpr):</span>
      <span class="s1">_rewrite_while_outfeed_cond(eqn</span><span class="s3">, </span><span class="s1">eqns</span><span class="s3">, </span><span class="s1">input_token_var</span><span class="s3">, </span><span class="s1">output_token_var</span><span class="s3">,</span>
                                  <span class="s1">input_itoken_var</span><span class="s3">, </span><span class="s1">output_itoken_var</span><span class="s3">,</span>
                                  <span class="s1">mk_new_var)</span>
      <span class="s3">return</span>

    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">body_jaxpr=_rewrite_closed_jaxpr(body_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">cond_jaxpr=_rewrite_closed_jaxpr(cond_jaxpr</span><span class="s3">, True, False</span><span class="s1">))))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">lax.cond_p:</span>
    <span class="s1">branches</span><span class="s3">, </span><span class="s1">linear = util.split_dict(eqn.params</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;branches&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s1">])</span>
    <span class="s1">index</span><span class="s3">, </span><span class="s1">*operands = eqn.invars</span>
    <span class="s1">new_invars = [index</span><span class="s3">, </span><span class="s1">*operands</span><span class="s3">, </span><span class="s1">input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=new_invars</span><span class="s3">, </span><span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">branches=tuple(</span>
                    <span class="s1">_rewrite_closed_jaxpr(jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">jaxpr </span><span class="s3">in </span><span class="s1">branches)</span><span class="s3">,</span>
                <span class="s1">linear=(*linear</span><span class="s3">, False, False</span><span class="s1">))))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">lax.scan_p:</span>
    <span class="s1">num_consts</span><span class="s3">, </span><span class="s1">num_carry</span><span class="s3">, </span><span class="s1">carry_jaxpr</span><span class="s3">, </span><span class="s1">linear</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = util.split_dict(</span>
        <span class="s1">eqn.params</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s4">&quot;num_consts&quot;</span><span class="s3">, </span><span class="s4">&quot;num_carry&quot;</span><span class="s3">, </span><span class="s4">&quot;jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s3">, </span><span class="s4">&quot;reverse&quot;</span><span class="s3">, </span><span class="s4">&quot;length&quot;</span><span class="s3">,</span>
         <span class="s4">&quot;unroll&quot;</span><span class="s1">])</span>
    <span class="s0"># We add the tokens right at the end of carry</span>
    <span class="s1">nr_const_and_carry = num_consts + num_carry</span>
    <span class="s1">new_invars = eqn.invars[</span><span class="s5">0</span><span class="s1">:nr_const_and_carry] + [</span>
        <span class="s1">input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var] + eqn.invars[nr_const_and_carry:]</span>
    <span class="s1">new_jaxpr = _rewrite_closed_jaxpr(carry_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span>
    <span class="s0"># The rewrite has put the token at end, it has to be at end of carry</span>
    <span class="s1">new_jaxpr_invars = new_jaxpr.jaxpr.invars</span>
    <span class="s1">new_jaxpr_invars = (</span>
        <span class="s1">new_jaxpr_invars[</span><span class="s5">0</span><span class="s1">:nr_const_and_carry] + new_jaxpr_invars[-</span><span class="s5">2</span><span class="s1">:] +</span>
        <span class="s1">new_jaxpr_invars[nr_const_and_carry:-</span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">new_jaxpr = new_jaxpr.replace(jaxpr=new_jaxpr.jaxpr.replace(invars=new_jaxpr_invars))</span>

    <span class="s1">new_jaxpr_outvars = new_jaxpr.jaxpr.outvars</span>
    <span class="s1">new_jaxpr_outvars = (</span>
        <span class="s1">new_jaxpr_outvars[</span><span class="s5">0</span><span class="s1">:num_carry] + new_jaxpr_outvars[-</span><span class="s5">2</span><span class="s1">:] +</span>
        <span class="s1">new_jaxpr_outvars[num_carry:-</span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">new_jaxpr = new_jaxpr.replace(jaxpr=new_jaxpr.jaxpr.replace(outvars=new_jaxpr_outvars))</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=new_invars</span><span class="s3">,</span>
            <span class="s0"># Output token is at the end of carry result</span>
            <span class="s1">outvars=(eqn.outvars[</span><span class="s5">0</span><span class="s1">:num_carry] + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var] +</span>
                     <span class="s1">eqn.outvars[num_carry:])</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">jaxpr=new_jaxpr</span><span class="s3">,</span>
                <span class="s1">num_carry=num_carry + </span><span class="s5">2</span><span class="s3">,</span>
                <span class="s1">linear=linear[</span><span class="s5">0</span><span class="s1">:nr_const_and_carry] + (</span><span class="s3">False, False</span><span class="s1">) + linear[nr_const_and_carry:])))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">pxla.xla_pmap_p:</span>
    <span class="s0"># We broadcast the input token into an array of tokens</span>
    <span class="s1">call_jaxpr = cast(core.Jaxpr</span><span class="s3">, </span><span class="s1">eqn.params[</span><span class="s4">&quot;call_jaxpr&quot;</span><span class="s1">])</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">call_jaxpr=_rewrite_jaxpr(call_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">donated_invars=eqn.params[</span><span class="s4">&quot;donated_invars&quot;</span><span class="s1">] + (</span><span class="s3">False, False</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s0"># Sharding/unsharding of tokens in pmap_translation are special</span>
                <span class="s0"># cased to just pass-through the token</span>
                <span class="s1">in_axes=eqn.params[</span><span class="s4">&quot;in_axes&quot;</span><span class="s1">] + (</span><span class="s3">None, None</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">out_axes=eqn.params[</span><span class="s4">&quot;out_axes&quot;</span><span class="s1">] + (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">custom_derivatives.custom_jvp_call_p:</span>
    <span class="s1">fun_jaxpr = eqn.params[</span><span class="s4">&quot;call_jaxpr&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">unreachable_thunk():</span>
      <span class="s3">assert False, </span><span class="s4">&quot;Should not be reached&quot;</span>

    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">call_jaxpr=_rewrite_closed_jaxpr(fun_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">jvp_jaxpr_thunk=unreachable_thunk</span>
            <span class="s1">)))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">custom_derivatives.custom_vjp_call_jaxpr_p:</span>
    <span class="s1">fun_jaxpr = eqn.params[</span><span class="s4">&quot;fun_jaxpr&quot;</span><span class="s1">]</span>
    <span class="s1">new_invars = [*eqn.invars</span><span class="s3">, </span><span class="s1">input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span>

    <span class="s3">def </span><span class="s1">unreachable_thunk():</span>
      <span class="s3">assert False, </span><span class="s4">&quot;Should not be reached&quot;</span>

    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=new_invars</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">fun_jaxpr=_rewrite_closed_jaxpr(fun_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">fwd_jaxpr_thunk=unreachable_thunk</span><span class="s3">,</span>
                <span class="s0"># The following are illegal values for the parameters, they</span>
                <span class="s0"># should not be needed because this rewrite is just before</span>
                <span class="s0"># compilation to XLA, which does not use those parameters.</span>
                <span class="s1">bwd=</span><span class="s4">&quot;illegal param&quot;</span><span class="s3">,</span>
                <span class="s1">out_trees=</span><span class="s4">&quot;illegal param&quot;</span><span class="s1">)))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">pjit.pjit_p:</span>
    <span class="s1">jaxpr = cast(core.ClosedJaxpr</span><span class="s3">, </span><span class="s1">eqn.params[</span><span class="s4">&quot;jaxpr&quot;</span><span class="s1">])</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">jaxpr=_rewrite_closed_jaxpr(jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">donated_invars=eqn.params[</span><span class="s4">&quot;donated_invars&quot;</span><span class="s1">] + (</span><span class="s3">False, False</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">in_shardings=(eqn.params[</span><span class="s4">&quot;in_shardings&quot;</span><span class="s1">] +</span>
                              <span class="s1">(pjit._UNSPECIFIED</span><span class="s3">, </span><span class="s1">pjit._UNSPECIFIED))</span><span class="s3">,</span>
                <span class="s1">out_shardings=(eqn.params[</span><span class="s4">&quot;out_shardings&quot;</span><span class="s1">] +</span>
                               <span class="s1">(pjit._UNSPECIFIED</span><span class="s3">, </span><span class="s1">pjit._UNSPECIFIED))</span><span class="s3">,</span>
            <span class="s1">)))</span>
  <span class="s3">elif </span><span class="s1">eqn.primitive </span><span class="s3">is </span><span class="s1">ad_checkpoint.remat_p:</span>
    <span class="s1">jaxpr_ = cast(core.Jaxpr</span><span class="s3">, </span><span class="s1">eqn.params[</span><span class="s4">&quot;jaxpr&quot;</span><span class="s1">])</span>
    <span class="s1">eqns.append(</span>
        <span class="s1">eqn.replace(</span>
            <span class="s1">invars=eqn.invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
            <span class="s1">outvars=eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var]</span><span class="s3">,</span>
            <span class="s1">params=dict(</span>
                <span class="s1">eqn.params</span><span class="s3">,</span>
                <span class="s1">jaxpr=_rewrite_jaxpr(jaxpr_</span><span class="s3">, True, True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;outfeed rewrite </span><span class="s3">{</span><span class="s1">eqn.primitive</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_rewrite_while_outfeed_cond(eqn: core.JaxprEqn</span><span class="s3">, </span><span class="s1">eqns: List[core.JaxprEqn]</span><span class="s3">,</span>
                                <span class="s1">input_token_var: core.Var</span><span class="s3">,</span>
                                <span class="s1">output_token_var: core.Var</span><span class="s3">,</span>
                                <span class="s1">input_itoken_var: core.Var</span><span class="s3">,</span>
                                <span class="s1">output_itoken_var: core.Var</span><span class="s3">,</span>
                                <span class="s1">mk_new_var: Callable):</span>
  <span class="s2">&quot;&quot;&quot;Rewrite a while whose cond has outfeed&quot;&quot;&quot;</span>
  <span class="s1">cond_jaxpr</span><span class="s3">, </span><span class="s1">cond_nconsts</span><span class="s3">, </span><span class="s1">body_jaxpr</span><span class="s3">, </span><span class="s1">body_nconsts = util.split_dict(</span>
      <span class="s1">eqn.params</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;cond_jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;cond_nconsts&quot;</span><span class="s3">, </span><span class="s4">&quot;body_jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;body_nconsts&quot;</span><span class="s1">])</span>
  <span class="s1">transformed_cond_jaxpr = _rewrite_closed_jaxpr(cond_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span>
  <span class="s1">carry_invars = eqn.invars[cond_nconsts + body_nconsts:]</span>
  <span class="s0"># pred1, token1, itoken1 = rewrite(COND)(cond_consts, carry_invars, input_token, input_itoken)</span>
  <span class="s1">pred1_and_token1 = [</span>
      <span class="s1">mk_new_var(ov.aval) </span><span class="s3">for </span><span class="s1">ov </span><span class="s3">in </span><span class="s1">transformed_cond_jaxpr.jaxpr.outvars</span>
  <span class="s1">]</span>
  <span class="s1">eqns.append(</span>
      <span class="s1">core.new_jaxpr_eqn(</span>
          <span class="s1">eqn.invars[</span><span class="s5">0</span><span class="s1">:cond_nconsts] + carry_invars + [input_token_var</span><span class="s3">, </span><span class="s1">input_itoken_var]</span><span class="s3">,</span>
          <span class="s1">pred1_and_token1</span><span class="s3">, </span><span class="s1">core.call_p</span><span class="s3">,</span>
          <span class="s1">dict(</span>
              <span class="s1">call_jaxpr=transformed_cond_jaxpr.jaxpr</span><span class="s3">,</span>
              <span class="s1">name=</span><span class="s4">&quot;cond_before&quot;</span><span class="s1">)</span><span class="s3">,</span>
          <span class="s1">transformed_cond_jaxpr.jaxpr.effects</span><span class="s3">,</span>
          <span class="s1">eqn.source_info))</span>
  <span class="s0"># Make a new cond &quot;lambda pred, carry, token, itoken: pred&quot;</span>
  <span class="s1">new_cond_pred_invar = mk_new_var(cond_jaxpr.out_avals[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s1">new_cond_invars = (</span>
      <span class="s1">[new_cond_pred_invar] + [mk_new_var(cv.aval) </span><span class="s3">for </span><span class="s1">cv </span><span class="s3">in </span><span class="s1">carry_invars] +</span>
      <span class="s1">[mk_new_var(input_token_var.aval)</span><span class="s3">,</span>
       <span class="s1">mk_new_var(input_itoken_var.aval)])</span>
  <span class="s1">new_cond_jaxpr = core.ClosedJaxpr(</span>
      <span class="s1">core.Jaxpr([]</span><span class="s3">, </span><span class="s1">new_cond_invars</span><span class="s3">, </span><span class="s1">[new_cond_pred_invar]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">set())</span><span class="s3">, </span><span class="s1">[])</span>
  <span class="s0"># Make a new body:</span>
  <span class="s0">#   &quot;lambda cond_constvars, body_constvars, pred, carry, token, itoken:</span>
  <span class="s0">#        carry2, token2, itoken2 = rewrite(BODY)(body_constvars, carry, token, itoken)</span>
  <span class="s0">#        pred2, token3, itoken3 = rewrite(COND)(cond_constvars, carry2, token2, itoken2)</span>
  <span class="s0">#        (pred2, carry2, token3, itoken3)</span>
  <span class="s1">transformed_body_jaxpr = _rewrite_closed_jaxpr(body_jaxpr</span><span class="s3">, True, True</span><span class="s1">)</span>
  <span class="s1">new_body_invars_cond_constvars = [</span>
      <span class="s1">mk_new_var(v.aval) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">eqn.invars[</span><span class="s5">0</span><span class="s1">:cond_nconsts]</span>
  <span class="s1">]</span>
  <span class="s1">new_body_invars_body_constvars = [</span>
      <span class="s1">mk_new_var(v.aval)</span>
      <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">eqn.invars[cond_nconsts:cond_nconsts + body_nconsts]</span>
  <span class="s1">]</span>
  <span class="s1">new_body_invars_pred = mk_new_var(cond_jaxpr.out_avals[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s1">new_body_invars_carry = [mk_new_var(cv.aval) </span><span class="s3">for </span><span class="s1">cv </span><span class="s3">in </span><span class="s1">carry_invars]</span>
  <span class="s1">new_body_invars_token = mk_new_var(input_token_var.aval)</span>
  <span class="s1">new_body_invars_itoken = mk_new_var(input_itoken_var.aval)</span>

  <span class="s1">new_body_carry2 = [mk_new_var(cv.aval) </span><span class="s3">for </span><span class="s1">cv </span><span class="s3">in </span><span class="s1">carry_invars]</span>
  <span class="s1">new_body_token2 = mk_new_var(input_token_var.aval)</span>
  <span class="s1">new_body_itoken2 = mk_new_var(input_itoken_var.aval)</span>
  <span class="s1">new_body_pred2 = mk_new_var(cond_jaxpr.out_avals[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s1">new_body_token3 = mk_new_var(input_token_var.aval)</span>
  <span class="s1">new_body_itoken3 = mk_new_var(input_itoken_var.aval)</span>

  <span class="s1">new_body_eqns = [</span>
      <span class="s1">core.new_jaxpr_eqn(</span>
          <span class="s1">new_body_invars_body_constvars + new_body_invars_carry +</span>
          <span class="s1">[new_body_invars_token</span><span class="s3">, </span><span class="s1">new_body_invars_itoken]</span><span class="s3">,</span>
          <span class="s1">new_body_carry2 + [new_body_token2</span><span class="s3">, </span><span class="s1">new_body_itoken2]</span><span class="s3">,</span>
          <span class="s1">core.call_p</span><span class="s3">,</span>
          <span class="s1">dict(</span>
              <span class="s1">call_jaxpr=transformed_body_jaxpr.jaxpr</span><span class="s3">,</span>
              <span class="s1">name=</span><span class="s4">&quot;body&quot;</span><span class="s1">)</span><span class="s3">,</span>
          <span class="s1">transformed_body_jaxpr.effects</span><span class="s3">,</span>
          <span class="s1">eqn.source_info)</span><span class="s3">,</span>
      <span class="s1">core.new_jaxpr_eqn(</span>
          <span class="s1">new_body_invars_cond_constvars + new_body_carry2 + [new_body_token2</span><span class="s3">, </span><span class="s1">new_body_itoken2]</span><span class="s3">,</span>
          <span class="s1">[new_body_pred2</span><span class="s3">, </span><span class="s1">new_body_token3</span><span class="s3">, </span><span class="s1">new_body_itoken3]</span><span class="s3">, </span><span class="s1">core.call_p</span><span class="s3">,</span>
          <span class="s1">dict(</span>
              <span class="s1">call_jaxpr=transformed_cond_jaxpr.jaxpr</span><span class="s3">,</span>
              <span class="s1">name=</span><span class="s4">&quot;cond_body&quot;</span><span class="s1">)</span><span class="s3">,</span>
          <span class="s1">transformed_cond_jaxpr.effects</span><span class="s3">,</span>
          <span class="s1">eqn.source_info)</span>
  <span class="s1">]</span>
  <span class="s1">effects = core.join_effects(*(eqn.effects </span><span class="s3">for </span><span class="s1">eqn </span><span class="s3">in </span><span class="s1">new_body_eqns))</span>
  <span class="s1">new_body_jaxpr = core.ClosedJaxpr(</span>
      <span class="s1">core.Jaxpr([]</span><span class="s3">, </span><span class="s1">(new_body_invars_cond_constvars +</span>
                      <span class="s1">new_body_invars_body_constvars + [new_body_invars_pred] +</span>
                      <span class="s1">new_body_invars_carry + [new_body_invars_token</span><span class="s3">, </span><span class="s1">new_body_invars_itoken])</span><span class="s3">,</span>
                 <span class="s1">([new_body_pred2] + new_body_carry2 + [new_body_token3</span><span class="s3">, </span><span class="s1">new_body_itoken3])</span><span class="s3">,</span>
                 <span class="s1">new_body_eqns</span><span class="s3">, </span><span class="s1">effects)</span><span class="s3">, </span><span class="s1">[])</span>

  <span class="s1">pred_out = mk_new_var(cond_jaxpr.out_avals[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s1">eqns.append(</span>
      <span class="s1">core.new_jaxpr_eqn(</span>
          <span class="s1">(eqn.invars[</span><span class="s5">0</span><span class="s1">:cond_nconsts + body_nconsts] + [pred1_and_token1[</span><span class="s5">0</span><span class="s1">]] +</span>
           <span class="s1">carry_invars + pred1_and_token1[</span><span class="s5">1</span><span class="s1">:])</span><span class="s3">,</span>
          <span class="s1">([pred_out] + eqn.outvars + [output_token_var</span><span class="s3">, </span><span class="s1">output_itoken_var])</span><span class="s3">,</span>
          <span class="s1">lax.while_p</span><span class="s3">,</span>
          <span class="s1">dict(</span>
              <span class="s1">cond_jaxpr=new_cond_jaxpr</span><span class="s3">,</span>
              <span class="s1">cond_nconsts=</span><span class="s5">0</span><span class="s3">,</span>
              <span class="s1">body_jaxpr=new_body_jaxpr</span><span class="s3">,</span>
              <span class="s1">body_nconsts=cond_nconsts + body_nconsts)</span><span class="s3">,</span>
          <span class="s1">new_body_jaxpr.effects</span><span class="s3">,</span>
          <span class="s1">eqn.source_info))</span>


<span class="s0"># We need an identity primitive to simplify rewriting</span>
<span class="s1">id_p = core.Primitive(</span><span class="s4">&quot;id&quot;</span><span class="s1">)</span>
<span class="s1">id_p.multiple_results = </span><span class="s3">True</span>
<span class="s1">id_p.def_impl(</span><span class="s3">lambda </span><span class="s1">*args: args)</span>
<span class="s1">id_p.def_abstract_eval(</span><span class="s3">lambda </span><span class="s1">*args: args)</span>
<span class="s1">xla.register_translation(id_p</span><span class="s3">, lambda </span><span class="s1">ctx</span><span class="s3">, </span><span class="s1">avals_in</span><span class="s3">, </span><span class="s1">avals_out</span><span class="s3">, </span><span class="s1">*args: args)</span>

<span class="s1">dispatch.outfeed_rewriter = </span><span class="s3">lambda </span><span class="s1">j: _rewrite_jaxpr(j</span><span class="s3">, False, False</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">CallbackException(Exception):</span>
  <span class="s2">&quot;&quot;&quot;Signals that some callback function had exceptions. 
 
  Raised by :func:`barrier_wait`. See the :mod:`jax.experimental.host_callback` 
  module documentation for details. 
  &quot;&quot;&quot;</span>
  <span class="s3">pass</span>

<span class="s1">TapFunctionException = CallbackException  </span><span class="s0"># For backwards compatibility</span>

<span class="s3">class </span><span class="s1">_CallbackHandlerData:</span>
  <span class="s2">&quot;&quot;&quot;Keep track of the outfeed receiver data.&quot;&quot;&quot;</span>
  <span class="s1">receiver: Any</span>
  <span class="s1">initialized: bool</span>
  <span class="s1">on_exit: bool</span>
  <span class="s1">lock: threading.Lock</span>
  <span class="s1">last_callback_exception: Optional[Tuple[Exception</span><span class="s3">, </span><span class="s1">str]]</span>
  <span class="s1">clients: Tuple[XlaLocalClient</span><span class="s3">, </span><span class="s1">...]</span>
  <span class="s1">devices: Tuple[XlaDevice</span><span class="s3">, </span><span class="s1">...]</span>
  <span class="s1">consumer_registry: Dict[Callable</span><span class="s3">, </span><span class="s1">int]</span>
  <span class="s1">consumer_registry_by_id: Dict[int</span><span class="s3">, </span><span class="s1">Callable]</span>

  <span class="s3">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.receiver = </span><span class="s3">None  </span><span class="s0"># Initialize lazily, when first needed</span>
    <span class="s1">self.initialized = </span><span class="s3">False</span>
    <span class="s1">self.on_exit = </span><span class="s3">False</span>
    <span class="s1">self.lock = threading.Lock()</span>
    <span class="s1">self.last_callback_exception = </span><span class="s3">None</span>
    <span class="s1">self.clients = ()</span>
    <span class="s1">self.devices = ()</span>
    <span class="s0"># The consumer registries must be live for the lifetime of the program,</span>
    <span class="s0"># because we may have cached compilations that embed consumer ids, and we</span>
    <span class="s0"># do not want the id reused for other shapes.</span>
    <span class="s0"># Used only for the outfeed mechanism.</span>
    <span class="s1">self.callback_registry = dict()</span>
    <span class="s1">self.callback_registry_by_id = dict()</span>
    <span class="s0"># For now we keep here the keep_alives for the emit_python_callback. This is</span>
    <span class="s0"># a leak. We ought to attach these to the executable.</span>
    <span class="s1">self.keep_alives = []</span>

  <span class="s3">def </span><span class="s1">stop(self):</span>
    <span class="s2">&quot;&quot;&quot;Wait for all pending outfeeds and stop the receiver.&quot;&quot;&quot;</span>
    <span class="s1">self.receiver = </span><span class="s3">None  </span><span class="s0"># GC will trigger the destructor</span>
    <span class="s1">self.initialized = </span><span class="s3">False</span>
    <span class="s1">self.clients = ()</span>
    <span class="s1">self.devices = ()</span>
    <span class="s0"># Do not clear the consumer registries.</span>


<span class="s1">_callback_handler_data = _CallbackHandlerData()</span>


<span class="s0"># This function is called from C++; it must not allow exceptions through.</span>
<span class="s3">def </span><span class="s1">_callback_input_received(device</span><span class="s3">, </span><span class="s1">consumer_id</span><span class="s3">, </span><span class="s1">arrays: Tuple):</span>
  <span class="s1">array_repr = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">f&quot;(</span><span class="s3">{</span><span class="s1">a.dtype</span><span class="s3">}{</span><span class="s1">a.shape</span><span class="s3">}</span><span class="s4">)&quot; </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arrays])</span>
  <span class="s1">logger.debug(</span><span class="s4">&quot;Callback input received on device %s for consumer %s arrays: %s&quot;</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">, </span><span class="s1">consumer_id</span><span class="s3">, </span><span class="s1">array_repr)</span>
  <span class="s1">callback = _callback_handler_data.callback_registry_by_id.get(consumer_id)</span>
  <span class="s3">assert </span><span class="s1">callback </span><span class="s3">is not None, </span><span class="s4">&quot;We should have crashed in the runtime&quot;</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">callback(arrays</span><span class="s3">, </span><span class="s1">device)</span>
  <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
    <span class="s1">formatted_e = traceback.format_exc()</span>
    <span class="s1">logger.error(</span><span class="s4">&quot;Postponing exception raised in callback function: %s&quot;</span><span class="s3">, </span><span class="s1">formatted_e)</span>
    <span class="s1">_callback_handler_data.last_callback_exception = (e</span><span class="s3">, </span><span class="s1">formatted_e)</span>


<span class="s3">def </span><span class="s1">_register_callback(callback: Callable) -&gt; int:</span>
  <span class="s2">&quot;&quot;&quot;Registers a callback function, cache by hash of callback. 
 
  The callback is a function to be invoked as `callback(arrays, device)`. 
  &quot;&quot;&quot;</span>
  <span class="s1">callback_id = _callback_handler_data.callback_registry.get(callback)</span>
  <span class="s3">if </span><span class="s1">callback_id </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">callback_id</span>
  <span class="s1">callback_id = hash(callback) &amp; </span><span class="s5">0xFFFFFFFC  </span><span class="s0"># pybind11 has trouble here with large ints</span>
  <span class="s1">callback_id += </span><span class="s5">1  </span><span class="s0"># Reserve the consumer ID 0</span>
  <span class="s3">assert </span><span class="s1">callback_id </span><span class="s3">not in </span><span class="s1">_callback_handler_data.callback_registry</span><span class="s3">, </span><span class="s1">(</span>
      <span class="s4">&quot;callback id collision&quot;</span><span class="s1">)</span>
  <span class="s1">_callback_handler_data.callback_registry[callback] = callback_id</span>
  <span class="s1">_callback_handler_data.callback_registry_by_id[callback_id] = callback</span>
  <span class="s3">return </span><span class="s1">callback_id</span>


<span class="s3">def </span><span class="s1">_initialize_outfeed_receiver(</span>
    <span class="s1">max_callback_queue_size_bytes: int = int(</span><span class="s5">256 </span><span class="s1">* </span><span class="s5">1e6</span><span class="s1">)):</span>
  <span class="s2">&quot;&quot;&quot;Creates and starts the outfeed_receiver. 
 
  This function is called lazily only when we compile an id_tap. 
 
  Args: 
    * clients: the list of clients (backends) on whose devices to listen on. 
    * max_callback_queue_size_bytes: an optional integer to bound the maximum 
      size of arrays in the callback queue. When this limit is reached the 
      device listener pauses. 
  &quot;&quot;&quot;</span>
  <span class="s1">outfeed_receiver_module = xla_extension.outfeed_receiver</span>

  <span class="s3">with </span><span class="s1">_callback_handler_data.lock:</span>
    <span class="s3">if </span><span class="s1">_callback_handler_data.initialized:</span>
      <span class="s3">return</span>

    <span class="s0"># By default, all devices on all supported backends.</span>
    <span class="s1">clients = [backend </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">backend </span><span class="s3">in </span><span class="s1">xb.backends().items()</span>
               <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;cuda&quot;</span><span class="s3">, </span><span class="s4">&quot;rocm&quot;</span><span class="s3">, </span><span class="s4">&quot;tpu&quot;</span><span class="s1">)]</span>
    <span class="s1">devices = list(</span>
        <span class="s1">itertools.chain(*[backend.local_devices() </span><span class="s3">for </span><span class="s1">backend </span><span class="s3">in </span><span class="s1">clients]))</span>
    <span class="s1">_callback_handler_data.clients = clients  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">_callback_handler_data.devices = devices  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">clients_with_outfeed = [c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">clients </span><span class="s3">if </span><span class="s1">_use_outfeed(c.platform)]</span>
    <span class="s3">for </span><span class="s1">client </span><span class="s3">in </span><span class="s1">clients_with_outfeed:</span>
      <span class="s1">_raise_if_using_outfeed_with_pjrt_c_api(client)</span>
    <span class="s3">if </span><span class="s1">clients_with_outfeed:</span>
      <span class="s1">devices_with_outfeed = list(</span>
        <span class="s1">itertools.chain(*[backend.local_devices() </span><span class="s3">for </span><span class="s1">backend </span><span class="s3">in </span><span class="s1">clients_with_outfeed]))</span>
      <span class="s3">if </span><span class="s1">logger.isEnabledFor(logging.DEBUG):</span>
        <span class="s1">device_repr = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([str(d) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">devices_with_outfeed])</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;Starting outfeed_receiver for %s. max_callback_queue_size_bytes=%s&quot;</span><span class="s3">,</span>
                       <span class="s1">device_repr</span><span class="s3">, </span><span class="s1">max_callback_queue_size_bytes)</span>
      <span class="s1">_callback_handler_data.receiver = outfeed_receiver_module.start(</span>
          <span class="s1">_callback_input_received</span><span class="s3">, </span><span class="s1">tuple(clients_with_outfeed)</span><span class="s3">,</span>
          <span class="s1">max_callback_queue_size_bytes</span><span class="s3">,</span>
          <span class="s1">xb.get_compile_options(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">).executable_build_options)  </span><span class="s0"># type:ignore</span>

    <span class="s3">def </span><span class="s1">exit_handler():</span>
      <span class="s0"># Prevent logging usage during compilation, gives errors under pytest</span>
      <span class="s1">dispatch._on_exit = </span><span class="s3">True  </span><span class="s0"># type: ignore[protected-access]</span>
      <span class="s3">if not </span><span class="s1">_callback_handler_data.on_exit:</span>
        <span class="s1">_callback_handler_data.on_exit = </span><span class="s3">True</span>
        <span class="s1">barrier_wait(</span><span class="s4">&quot;at_exit&quot;</span><span class="s1">)</span>

    <span class="s1">atexit.register(exit_handler)  </span><span class="s0"># We wait as long as we have callbacks</span>
    <span class="s1">_callback_handler_data.initialized = </span><span class="s3">True</span>


<span class="s3">def </span><span class="s1">barrier_wait(logging_name: Optional[str] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Blocks the calling thread until all current outfeed is processed. 
 
  Waits until all callbacks from computations already running on all devices 
  have been received and processed by the Python callbacks. Raises 
  CallbackException if there were exceptions while processing the callbacks. 
 
  This works by enqueueing a special tap computation to all devices to which 
  we are listening for outfeed. Once all those tap computations are done, we 
  return from barrier_wait. 
 
  Note: If any of the devices are busy and cannot accept new computations, 
  this will deadlock. 
 
  Args: 
    logging_name: an optional string that will be used in the logging statements 
      for this invocation. See `Debugging` in the module documentation. 
 
  For more details see the :mod:`jax.experimental.host_callback` module documentation. 
  &quot;&quot;&quot;</span>
  <span class="s1">logging_name = logging_name </span><span class="s3">or </span><span class="s4">&quot;&quot;</span>
  <span class="s1">logger.debug(</span><span class="s4">&quot;barrier_wait[%s]: start&quot;</span><span class="s3">, </span><span class="s1">logging_name)</span>

  <span class="s1">lock = threading.Lock()</span>
  <span class="s1">cv = threading.Condition(lock=lock)</span>
  <span class="s1">devices_at_barrier = []  </span><span class="s0"># Protected by lock</span>
  <span class="s3">def </span><span class="s1">barrier_tap_received(dev_idx</span><span class="s3">, </span><span class="s1">_):</span>
    <span class="s1">device = _callback_handler_data.devices[dev_idx]</span>
    <span class="s1">logger.debug(</span>
      <span class="s4">&quot;barrier_wait[%s]: at barrier_tap for device %s. Thread %s&quot;</span><span class="s3">,</span>
      <span class="s1">logging_name</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">threading.current_thread()</span>
    <span class="s1">)</span>
    <span class="s3">with </span><span class="s1">lock:</span>
      <span class="s1">devices_at_barrier.append(device)</span>
      <span class="s3">if </span><span class="s1">logger.isEnabledFor(logging.DEBUG):</span>
        <span class="s1">waiting_for_devices = [d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">_callback_handler_data.devices</span>
                               <span class="s3">if </span><span class="s1">d </span><span class="s3">not in </span><span class="s1">devices_at_barrier]</span>
        <span class="s1">logger.debug(</span>
          <span class="s4">&quot;barrier_wait[%s]: still waiting for %s devices at barrier (%s)&quot;</span><span class="s3">,</span>
          <span class="s1">logging_name</span><span class="s3">, </span><span class="s1">len(waiting_for_devices)</span><span class="s3">, </span><span class="s1">waiting_for_devices</span>
        <span class="s1">)</span>
      <span class="s1">cv.notify()</span>

  <span class="s3">for </span><span class="s1">d_idx</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(_callback_handler_data.devices):</span>
    <span class="s1">logger.debug(</span><span class="s4">&quot;barrier_wait[%s]: enqueueing barrier on device %s&quot;</span><span class="s3">, </span><span class="s1">logging_name</span><span class="s3">, </span><span class="s1">d)</span>
    <span class="s1">x_on_dev = api.device_put(d_idx</span><span class="s3">, </span><span class="s1">device=d)</span>
    <span class="s1">api.jit(</span><span class="s3">lambda </span><span class="s1">x: id_tap(barrier_tap_received</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">device=d)(x_on_dev)</span>

  <span class="s1">logger.debug(</span><span class="s4">&quot;barrier_wait[%s]: waiting for callbacks&quot;</span><span class="s3">, </span><span class="s1">logging_name)</span>

  <span class="s3">with </span><span class="s1">lock:</span>
    <span class="s1">cv.wait_for(</span><span class="s3">lambda</span><span class="s1">: len(devices_at_barrier) == len(_callback_handler_data.devices))</span>

  <span class="s1">logger.debug(</span><span class="s4">&quot;barrier_wait[%s]: done&quot;</span><span class="s3">, </span><span class="s1">logging_name)</span>

  <span class="s3">if </span><span class="s1">_callback_handler_data.last_callback_exception </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">last_exception</span><span class="s3">, </span><span class="s1">formatted_last_exception = _callback_handler_data.last_callback_exception</span>
    <span class="s1">_callback_handler_data.last_callback_exception = </span><span class="s3">None</span>
    <span class="s3">raise </span><span class="s1">CallbackException(</span>
        <span class="s4">&quot;There were exceptions during callback processing. &quot;</span>
        <span class="s4">f&quot;Last one was: </span><span class="s3">{</span><span class="s1">formatted_last_exception</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">last_exception</span>


<span class="s3">def </span><span class="s1">stop_outfeed_receiver():</span>
  <span class="s2">&quot;&quot;&quot;Stops the outfeed receiver runtime. 
 
  This waits for all outfeeds from computations already running on all devices, 
  and then stops the outfeed receiver runtime. The runtime will be restarted 
  next time you use a tap function. 
 
  It should not be necessary to use this function, unless you want to start 
  using lax.outfeed directly after having used host callbacks. 
  &quot;&quot;&quot;</span>
  <span class="s1">_callback_handler_data.stop()</span>
</pre>
</body>
</html>