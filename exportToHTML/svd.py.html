<html>
<head>
<title>svd.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
svd.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2022 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License</span>

<span class="s2">&quot;&quot;&quot;A JIT-compatible library for QDWH-based singular value decomposition. 
 
QDWH is short for QR-based dynamically weighted Halley iteration. The Halley 
iteration implemented through QR decmopositions is numerically stable and does 
not require solving a linear system involving the iteration matrix or 
computing its inversion. This is desirable for multicore and heterogeneous 
computing systems. 
 
References: 
Nakatsukasa, Yuji, and Nicholas J. Higham. 
&quot;Stable and efficient spectral divide and conquer algorithms for the symmetric 
eigenvalue decomposition and the SVD.&quot; SIAM Journal on Scientific Computing 35, 
no. 3 (2013): A1325-A1349. 
https://epubs.siam.org/doi/abs/10.1137/120876605 
 
Nakatsukasa, Yuji, Zhaojun Bai, and Fran√ßois Gygi. 
&quot;Optimizing Halley's iteration for computing the matrix polar decomposition.&quot; 
SIAM Journal on Matrix Analysis and Applications 31, no. 5 (2010): 2700-2720. 
https://epubs.siam.org/doi/abs/10.1137/090774999 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">jax</span>
<span class="s3">import </span><span class="s1">jax.numpy </span><span class="s3">as </span><span class="s1">jnp</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>


<span class="s1">@functools.partial(jax.jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_zero_svd(a: Any</span><span class="s3">,</span>
              <span class="s1">full_matrices: bool</span><span class="s3">,</span>
              <span class="s1">compute_uv: bool = </span><span class="s3">True</span><span class="s1">) -&gt; Union[Any</span><span class="s3">, </span><span class="s1">Sequence[Any]]:</span>
  <span class="s2">&quot;&quot;&quot;SVD on matrix of all zeros.&quot;&quot;&quot;</span>
  <span class="s1">m</span><span class="s3">, </span><span class="s1">n = a.shape</span>
  <span class="s1">k = min(m</span><span class="s3">, </span><span class="s1">n)</span>
  <span class="s1">s = jnp.zeros(shape=(k</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=a.real.dtype)</span>
  <span class="s3">if </span><span class="s1">compute_uv:</span>
    <span class="s3">if </span><span class="s1">full_matrices:</span>
      <span class="s1">u = jnp.eye(m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">dtype=a.dtype)</span>
      <span class="s1">vh = jnp.eye(n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype=a.dtype)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">u = jnp.eye(m</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">dtype=a.dtype)</span>
      <span class="s1">vh = jnp.eye(k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype=a.dtype)</span>
    <span class="s3">return </span><span class="s1">(u</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">vh)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">s</span>


<span class="s1">@functools.partial(jax.jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_svd_tall_and_square_input(</span>
    <span class="s1">a: Any</span><span class="s3">, </span><span class="s1">hermitian: bool</span><span class="s3">, </span><span class="s1">compute_uv: bool</span><span class="s3">, </span><span class="s1">max_iterations: int</span>
<span class="s1">) -&gt; Union[Any</span><span class="s3">, </span><span class="s1">Sequence[Any]]:</span>
  <span class="s2">&quot;&quot;&quot;Singular value decomposition for m x n matrix and m &gt;= n. 
 
  Args: 
    a: A matrix of shape `m x n` with `m &gt;= n`. 
    hermitian: True if `a` is Hermitian. 
    compute_uv: Whether to compute also `u` and `v` in addition to `s`. 
    max_iterations: The predefined maximum number of iterations of QDWH. 
 
  Returns: 
    A 3-tuple (`u`, `s`, `v`), where `u` is a unitary matrix of shape `m x n`, 
    `s` is vector of length `n` containing the singular values in the descending 
    order, `v` is a unitary matrix of shape `n x n`, and 
    `a = (u * s) @ v.T.conj()`. For `compute_uv=False`, only `s` is returned. 
  &quot;&quot;&quot;</span>

  <span class="s1">u</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = lax.linalg.qdwh(a</span><span class="s3">, </span><span class="s1">is_hermitian=hermitian</span><span class="s3">,</span>
                               <span class="s1">max_iterations=max_iterations)</span>

  <span class="s0"># TODO: Uses `eigvals_only=True` if `compute_uv=False`.</span>
  <span class="s1">v</span><span class="s3">, </span><span class="s1">s = lax.linalg.eigh(h)</span>

  <span class="s0"># Flips the singular values in descending order.</span>
  <span class="s1">s_out = jnp.flip(s)</span>

  <span class="s3">if not </span><span class="s1">compute_uv:</span>
    <span class="s3">return </span><span class="s1">s_out</span>

  <span class="s0"># Reorders eigenvectors.</span>
  <span class="s1">v_out = jnp.fliplr(v)</span>

  <span class="s1">u_out = u @ v_out</span>

  <span class="s0"># Makes correction if computed `u` from qdwh is not unitary.</span>
  <span class="s0"># Section 5.5 of Nakatsukasa, Yuji, and Nicholas J. Higham. &quot;Stable and</span>
  <span class="s0"># efficient spectral divide and conquer algorithms for the symmetric</span>
  <span class="s0"># eigenvalue decomposition and the SVD.&quot; SIAM Journal on Scientific Computing</span>
  <span class="s0"># 35, no. 3 (2013): A1325-A1349.</span>
  <span class="s3">def </span><span class="s1">correct_rank_deficiency(u_out):</span>
    <span class="s1">u_out</span><span class="s3">, </span><span class="s1">r = lax.linalg.qr(u_out</span><span class="s3">, </span><span class="s1">full_matrices=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">u_out = u_out @ jnp.diag(lax.sign(jnp.diag(r)))</span>
    <span class="s3">return </span><span class="s1">u_out</span>

  <span class="s1">eps = float(jnp.finfo(a.dtype).eps)</span>
  <span class="s1">u_out = lax.cond(s[</span><span class="s4">0</span><span class="s1">] &lt; a.shape[</span><span class="s4">1</span><span class="s1">] * eps * s_out[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                   <span class="s1">correct_rank_deficiency</span><span class="s3">,</span>
                   <span class="s3">lambda </span><span class="s1">u_out: u_out</span><span class="s3">,</span>
                   <span class="s1">operand=(u_out))</span>

  <span class="s3">return </span><span class="s1">(u_out</span><span class="s3">, </span><span class="s1">s_out</span><span class="s3">, </span><span class="s1">v_out)</span>


<span class="s1">@functools.partial(jax.jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_qdwh_svd(a: Any</span><span class="s3">,</span>
              <span class="s1">full_matrices: bool</span><span class="s3">,</span>
              <span class="s1">compute_uv: bool = </span><span class="s3">True,</span>
              <span class="s1">hermitian: bool = </span><span class="s3">False,</span>
              <span class="s1">max_iterations: int = </span><span class="s4">10</span><span class="s1">) -&gt; Union[Any</span><span class="s3">, </span><span class="s1">Sequence[Any]]:</span>
  <span class="s2">&quot;&quot;&quot;Singular value decomposition. 
 
  Args: 
    a: A matrix of shape `m x n`. 
    full_matrices: If True, `u` and `vh` have the shapes `m x m` and `n x n`, 
      respectively. If False, the shapes are `m x k` and `k x n`, respectively, 
      where `k = min(m, n)`. 
    compute_uv: Whether to compute also `u` and `v` in addition to `s`. 
    hermitian: True if `a` is Hermitian. 
    max_iterations: The predefined maximum number of iterations of QDWH. 
 
  Returns: 
    A 3-tuple (`u`, `s`, `vh`), where `u` and `vh` are unitary matrices, 
    `s` is vector of length `k` containing the singular values in the 
    non-increasing order, and `k = min(m, n)`. The shapes of `u` and `vh` 
    depend on the value of `full_matrices`. For `compute_uv=False`, 
    only `s` is returned. 
  &quot;&quot;&quot;</span>
  <span class="s1">m</span><span class="s3">, </span><span class="s1">n = a.shape</span>

  <span class="s1">is_flip = </span><span class="s3">False</span>
  <span class="s3">if </span><span class="s1">m &lt; n:</span>
    <span class="s1">a = a.T.conj()</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = a.shape</span>
    <span class="s1">is_flip = </span><span class="s3">True</span>

  <span class="s1">reduce_to_square = </span><span class="s3">False</span>
  <span class="s3">if </span><span class="s1">full_matrices:</span>
    <span class="s1">q_full</span><span class="s3">, </span><span class="s1">a_full = lax.linalg.qr(a</span><span class="s3">, </span><span class="s1">full_matrices=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">q = q_full[:</span><span class="s3">, </span><span class="s1">:n]</span>
    <span class="s1">u_out_null = q_full[:</span><span class="s3">, </span><span class="s1">n:]</span>
    <span class="s1">a = a_full[:n</span><span class="s3">, </span><span class="s1">:]</span>
    <span class="s1">reduce_to_square = </span><span class="s3">True</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s0"># The constant `1.15` comes from Yuji Nakatsukasa's implementation</span>
    <span class="s0"># https://www.mathworks.com/matlabcentral/fileexchange/36830-symmetric-eigenvalue-decomposition-and-the-svd?s_tid=FX_rc3_behav</span>
    <span class="s3">if </span><span class="s1">m &gt; </span><span class="s4">1.15 </span><span class="s1">* n:</span>
      <span class="s1">q</span><span class="s3">, </span><span class="s1">a = lax.linalg.qr(a</span><span class="s3">, </span><span class="s1">full_matrices=</span><span class="s3">False</span><span class="s1">)</span>
      <span class="s1">reduce_to_square = </span><span class="s3">True</span>

  <span class="s3">if not </span><span class="s1">compute_uv:</span>
    <span class="s3">with </span><span class="s1">jax.default_matmul_precision(</span><span class="s5">'float32'</span><span class="s1">):</span>
      <span class="s3">return </span><span class="s1">_svd_tall_and_square_input(a</span><span class="s3">, </span><span class="s1">hermitian</span><span class="s3">, </span><span class="s1">compute_uv</span><span class="s3">,</span>
                                        <span class="s1">max_iterations)</span>

  <span class="s3">with </span><span class="s1">jax.default_matmul_precision(</span><span class="s5">'float32'</span><span class="s1">):</span>
    <span class="s1">u_out</span><span class="s3">, </span><span class="s1">s_out</span><span class="s3">, </span><span class="s1">v_out = _svd_tall_and_square_input(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">hermitian</span><span class="s3">, </span><span class="s1">compute_uv</span><span class="s3">, </span><span class="s1">max_iterations)</span>
    <span class="s3">if </span><span class="s1">reduce_to_square:</span>
      <span class="s1">u_out = q @ u_out</span>

  <span class="s3">if </span><span class="s1">full_matrices:</span>
    <span class="s1">u_out = jnp.hstack((u_out</span><span class="s3">, </span><span class="s1">u_out_null))</span>

  <span class="s3">if </span><span class="s1">is_flip:</span>
    <span class="s3">return</span><span class="s1">(v_out</span><span class="s3">, </span><span class="s1">s_out</span><span class="s3">, </span><span class="s1">u_out.T.conj())</span>

  <span class="s3">return </span><span class="s1">(u_out</span><span class="s3">, </span><span class="s1">s_out</span><span class="s3">, </span><span class="s1">v_out.T.conj())</span>


<span class="s1">@functools.partial(jax.jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">svd(a: Any</span><span class="s3">,</span>
        <span class="s1">full_matrices: bool</span><span class="s3">,</span>
        <span class="s1">compute_uv: bool = </span><span class="s3">True,</span>
        <span class="s1">hermitian: bool = </span><span class="s3">False,</span>
        <span class="s1">max_iterations: int = </span><span class="s4">10</span><span class="s1">) -&gt; Union[Any</span><span class="s3">, </span><span class="s1">Sequence[Any]]:</span>
  <span class="s2">&quot;&quot;&quot;Singular value decomposition. 
 
  Args: 
    a: A matrix of shape `m x n`. 
    full_matrices: If True, `u` and `vh` have the shapes `m x m` and `n x n`, 
      respectively. If False, the shapes are `m x k` and `k x n`, respectively, 
      where `k = min(m, n)`. 
    compute_uv: Whether to compute also `u` and `v` in addition to `s`. 
    hermitian: True if `a` is Hermitian. 
    max_iterations: The predefined maximum number of iterations of QDWH. 
 
  Returns: 
    A 3-tuple (`u`, `s`, `vh`), where `u` and `vh` are unitary matrices, 
    `s` is vector of length `k` containing the singular values in the 
    non-increasing order, and `k = min(m, n)`. The shapes of `u` and `vh` 
    depend on the value of `full_matrices`. For `compute_uv=False`, 
    only `s` is returned. 
  &quot;&quot;&quot;</span>
  <span class="s1">full_matrices = core.concrete_or_error(</span>
      <span class="s1">bool</span><span class="s3">, </span><span class="s1">full_matrices</span><span class="s3">, </span><span class="s5">'The `full_matrices` argument must be statically '</span>
      <span class="s5">'specified to use `svd` within JAX transformations.'</span><span class="s1">)</span>

  <span class="s1">compute_uv = core.concrete_or_error(</span>
      <span class="s1">bool</span><span class="s3">, </span><span class="s1">compute_uv</span><span class="s3">, </span><span class="s5">'The `compute_uv` argument must be statically '</span>
      <span class="s5">'specified to use `svd` within JAX transformations.'</span><span class="s1">)</span>

  <span class="s1">hermitian = core.concrete_or_error(</span>
      <span class="s1">bool</span><span class="s3">, </span><span class="s1">hermitian</span><span class="s3">, </span><span class="s5">'The `hermitian` argument must be statically '</span>
      <span class="s5">'specified to use `qdwh` within JAX transformations.'</span><span class="s1">)</span>

  <span class="s1">max_iterations = core.concrete_or_error(</span>
      <span class="s1">int</span><span class="s3">, </span><span class="s1">max_iterations</span><span class="s3">, </span><span class="s5">'The `max_iterations` argument must be statically '</span>
      <span class="s5">'specified to use `qdwh` within JAX transformations.'</span><span class="s1">)</span>

  <span class="s0"># QDWH algorithm fails at zero-matrix `A` and produces all NaNs, which can</span>
  <span class="s0"># be seen from a dynamically weighted Halley (DWH) iteration:</span>
  <span class="s0"># X_{k+1} = X_k(a_k I + b_k {X_k}^H X_k)(I + c_k {X_k}^H X_k)^{‚àí1} and</span>
  <span class="s0"># X_0 = A/alpha, where alpha = ||A||_2, the triplet (a_k, b_k, c_k) are</span>
  <span class="s0"># weighting parameters, and X_k denotes the k^{th} iterate.</span>
  <span class="s3">return </span><span class="s1">jax.lax.cond(jnp.all(a == </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                      <span class="s1">functools.partial(_zero_svd</span><span class="s3">, </span><span class="s1">full_matrices=full_matrices</span><span class="s3">,</span>
                                        <span class="s1">compute_uv=compute_uv)</span><span class="s3">,</span>
                      <span class="s1">functools.partial(_qdwh_svd</span><span class="s3">, </span><span class="s1">full_matrices=full_matrices</span><span class="s3">,</span>
                                        <span class="s1">compute_uv=compute_uv</span><span class="s3">,</span>
                                        <span class="s1">hermitian=hermitian</span><span class="s3">,</span>
                                        <span class="s1">max_iterations=max_iterations)</span><span class="s3">,</span>
                      <span class="s1">operand=(a))</span>
</pre>
</body>
</html>