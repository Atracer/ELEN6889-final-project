<html>
<head>
<title>random.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
random.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">dtypes</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">vmap</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">random</span>
<span class="s2">from </span><span class="s1">jax.util </span><span class="s2">import </span><span class="s1">split_list</span>
<span class="s2">import </span><span class="s1">jax.numpy </span><span class="s2">as </span><span class="s1">jnp</span>
<span class="s2">from </span><span class="s1">jax.experimental </span><span class="s2">import </span><span class="s1">sparse</span>


<span class="s2">def </span><span class="s1">random_bcoo(key</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">dtype=jnp.float_</span><span class="s2">, </span><span class="s1">indices_dtype=</span><span class="s2">None,</span>
                <span class="s1">nse=</span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">n_batch=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">n_dense=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">unique_indices=</span><span class="s2">True,</span>
                <span class="s1">sorted_indices=</span><span class="s2">False, </span><span class="s1">generator=random.uniform</span><span class="s2">, </span><span class="s1">**kwds):</span>
  <span class="s4">&quot;&quot;&quot;Generate a random BCOO matrix. 
 
  Args: 
    key : random.PRNGKey to be passed to ``generator`` function. 
    shape : tuple specifying the shape of the array to be generated. 
    dtype : dtype of the array to be generated. 
    indices_dtype: dtype of the BCOO indicies. 
    nse : number of specified elements in the matrix, or if 0 &lt; nse &lt; 1, a 
      fraction of sparse dimensions to be specified (default: 0.2). 
    n_batch : number of batch dimensions. must satisfy ``n_batch &gt;= 0`` and 
      ``n_batch + n_dense &lt;= len(shape)``. 
    n_dense : number of batch dimensions. must satisfy ``n_dense &gt;= 0`` and 
      ``n_batch + n_dense &lt;= len(shape)``. 
    unique_indices : boolean specifying whether indices should be unique 
      (default: True). 
    sorted_indices : boolean specifying whether indices should be row-sorted in 
      lexicographical order (default: False). 
    generator : function for generating random values accepting a key, shape, 
      and dtype. It defaults to :func:`jax.random.uniform`, and may be any 
      function with a similar signature. 
    **kwds : additional keyword arguments to pass to ``generator``. 
 
  Returns: 
    arr : a sparse.BCOO array with the specified properties. 
  &quot;&quot;&quot;</span>
  <span class="s1">shape = tuple(map(operator.index</span><span class="s2">, </span><span class="s1">shape))</span>
  <span class="s1">n_batch = operator.index(n_batch)</span>
  <span class="s1">n_dense = operator.index(n_dense)</span>
  <span class="s2">if </span><span class="s1">n_batch &lt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">n_dense &lt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">n_batch + n_dense &gt; len(shape):</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Invalid </span><span class="s2">{</span><span class="s1">n_batch=</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">n_dense=</span><span class="s2">} </span><span class="s5">for </span><span class="s2">{</span><span class="s1">shape=</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
  <span class="s1">n_sparse = len(shape) - n_batch - n_dense</span>
  <span class="s1">batch_shape</span><span class="s2">, </span><span class="s1">sparse_shape</span><span class="s2">, </span><span class="s1">dense_shape = map(tuple</span><span class="s2">, </span><span class="s1">split_list(shape</span><span class="s2">, </span><span class="s1">[n_batch</span><span class="s2">, </span><span class="s1">n_sparse]))</span>
  <span class="s1">batch_size = math.prod(batch_shape)</span>
  <span class="s1">sparse_size = math.prod(sparse_shape)</span>
  <span class="s2">if not </span><span class="s3">0 </span><span class="s1">&lt;= nse &lt; sparse_size:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;got </span><span class="s2">{</span><span class="s1">nse=</span><span class="s2">}</span><span class="s5">, expected to be between 0 and </span><span class="s2">{</span><span class="s1">sparse_size</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s3">0 </span><span class="s1">&lt; nse &lt; </span><span class="s3">1</span><span class="s1">:</span>
    <span class="s1">nse = int(math.ceil(nse * sparse_size))</span>
  <span class="s1">nse = operator.index(nse)</span>

  <span class="s1">data_shape = batch_shape + (nse</span><span class="s2">,</span><span class="s1">) + dense_shape</span>
  <span class="s1">indices_shape = batch_shape + (nse</span><span class="s2">, </span><span class="s1">n_sparse)</span>
  <span class="s2">if </span><span class="s1">indices_dtype </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">indices_dtype = dtypes.canonicalize_dtype(jnp.int_)</span>
  <span class="s2">if </span><span class="s1">sparse_size &gt; jnp.iinfo(indices_dtype).max:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">indices_dtype=</span><span class="s2">} </span><span class="s5">does not have enough range to generate &quot;</span>
                     <span class="s5">f&quot;sparse indices of size </span><span class="s2">{</span><span class="s1">sparse_size</span><span class="s2">}</span><span class="s5">.&quot;</span><span class="s1">)</span>
  <span class="s1">@vmap</span>
  <span class="s2">def </span><span class="s1">_indices(key):</span>
    <span class="s2">if not </span><span class="s1">sparse_shape:</span>
      <span class="s2">return </span><span class="s1">jnp.empty((nse</span><span class="s2">, </span><span class="s1">n_sparse)</span><span class="s2">, </span><span class="s1">dtype=indices_dtype)</span>
    <span class="s1">flat_ind = random.choice(key</span><span class="s2">, </span><span class="s1">sparse_size</span><span class="s2">, </span><span class="s1">shape=(nse</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">replace=</span><span class="s2">not </span><span class="s1">unique_indices).astype(indices_dtype)</span>
    <span class="s2">return </span><span class="s1">jnp.column_stack(jnp.unravel_index(flat_ind</span><span class="s2">, </span><span class="s1">sparse_shape))</span>

  <span class="s1">keys = random.split(key</span><span class="s2">, </span><span class="s1">batch_size + </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s1">data_key</span><span class="s2">, </span><span class="s1">index_keys = keys[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">keys[</span><span class="s3">1</span><span class="s1">:]</span>
  <span class="s1">data = generator(data_key</span><span class="s2">, </span><span class="s1">shape=data_shape</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">**kwds)</span>
  <span class="s1">indices = _indices(index_keys).reshape(indices_shape)</span>
  <span class="s1">mat = sparse.BCOO((data</span><span class="s2">, </span><span class="s1">indices)</span><span class="s2">, </span><span class="s1">shape=shape)</span>
  <span class="s2">return </span><span class="s1">mat.sort_indices() </span><span class="s2">if </span><span class="s1">sorted_indices </span><span class="s2">else </span><span class="s1">mat</span>
</pre>
</body>
</html>