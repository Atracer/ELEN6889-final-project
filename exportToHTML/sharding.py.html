<html>
<head>
<title>sharding.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sharding.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Mapping</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">Tuple)</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client </span><span class="s2">as </span><span class="s1">xc</span>

<span class="s1">Shape = Tuple[int</span><span class="s2">, </span><span class="s1">...]</span>
<span class="s1">Device = xc.Device</span>
<span class="s1">Index = Tuple[slice</span><span class="s2">, </span><span class="s1">...]</span>
<span class="s1">XLADeviceAssignment = Sequence[Device]</span>


<span class="s1">@util.use_cpp_class(xc.Sharding)</span>
<span class="s2">class </span><span class="s1">Sharding:</span>
  <span class="s3">&quot;&quot;&quot;Abstract ``Sharding`` interface which describes how a ``jax.Array`` is laid out 
  across devices. 
  &quot;&quot;&quot;</span>

  <span class="s0"># Abstract methods below that subclasses should implement.</span>
  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">device_set(self) -&gt; Set[Device]:</span>
    <span class="s3">&quot;&quot;&quot;A ``set`` of global devices that this ``Sharding`` spans. 
 
    In multi-controller JAX, the set of devices is global, i.e., includes 
    non-addressable devices from other processes. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Subclasses should implement this method.'</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">devices_indices_map(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">global_shape: Shape) -&gt; Mapping[Device</span><span class="s2">, </span><span class="s1">Optional[Index]]:</span>
    <span class="s3">&quot;&quot;&quot;A global mapping from device to the slice of the global data it contains. 
 
    The devices in this mapping are global devices i.e. includes 
    non-addressable devices from other processes. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Subclasses should implement this method.'</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">shard_shape(self</span><span class="s2">, </span><span class="s1">global_shape: Shape) -&gt; Shape:</span>
    <span class="s3">&quot;&quot;&quot;Returns the shape of the data on each device. 
 
    The shard shape returned by this function is calculated from the global 
    shape (it takes as an input) and the properties of the sharding. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Subclasses should implement this method.'</span><span class="s1">)</span>

  <span class="s2">def </span><span class="s1">is_equivalent_to(self</span><span class="s2">, </span><span class="s1">other: Sharding</span><span class="s2">, </span><span class="s1">ndim: int) -&gt; bool:</span>
    <span class="s3">&quot;&quot;&quot;Returns True if two shardings put the same logical array 
    (sharded/unsharded) on the same device(s). 
 
    For example, every XLACompatibleSharding lowers to GSPMDSharding which 
    is a general representation. So `jax.sharding.NamedSharding` is equivalent 
    to `jax.sharding.PositionalSharding` if both of them lower to the same 
    GSPMDSharding. 
    &quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Subclasses should implement this method.'</span><span class="s1">)</span>

  <span class="s0">#############################################################################</span>
  <span class="s0"># Default implementations below that all subclasses will inherit.</span>

  <span class="s1">@functools.cached_property</span>
  <span class="s2">def </span><span class="s1">addressable_devices(self) -&gt; Set[Device]:</span>
    <span class="s3">&quot;&quot;&quot;A set of devices that are addressable by the current process.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.device_set</span>
            <span class="s2">if </span><span class="s1">d.process_index == d.client.process_index()}</span>

  <span class="s1">@functools.cached_property</span>
  <span class="s2">def </span><span class="s1">is_fully_addressable(self) -&gt; bool:</span>
    <span class="s3">&quot;&quot;&quot;True if the current process can address all of the devices in device_set. 
    &quot;&quot;&quot;</span>
    <span class="s0"># The pytype disable is because pytype can't recognize a cached property.</span>
    <span class="s2">return </span><span class="s1">len(self.device_set) == len(self.addressable_devices)  </span><span class="s0"># type: ignore</span>

  <span class="s1">@functools.lru_cache(maxsize=</span><span class="s5">4096</span><span class="s1">)</span>
  <span class="s2">def </span><span class="s1">addressable_devices_indices_map(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">global_shape: Shape) -&gt; Mapping[Device</span><span class="s2">, </span><span class="s1">Optional[Index]]:</span>
    <span class="s3">&quot;&quot;&quot;A mapping from addressable device to the slice of global data it contains. 
 
    ``addressable_devices_indices_map`` contains that part of 
    ``device_indices_map`` that applies to the addressable devices. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">{d: ind </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">self.devices_indices_map(global_shape).items()</span>
            <span class="s2">if </span><span class="s1">d.process_index == d.client.process_index()}</span>
</pre>
</body>
</html>