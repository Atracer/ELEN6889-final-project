<html>
<head>
<title>primitive_harness.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
primitive_harness.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;Defines test inputs and invocations for JAX primitives. 
 
A primitive harness encodes one use case for one JAX numeric primitives. It 
describes how to generate the inputs and parameters and how to invoke the 
JAX primitive. A primitive harness can be used in multiple kinds of tests. 
For example, we can use the harnesses to check 
that each primitive is compiled correctly, or that we can apply a certain 
transformation, e.g., `vmap`. 
 
See the `Harness` class below for how to define a harness, describing one 
use case of one primitive. 
 
Some use cases are known to be partially implemented 
in JAX, e.g., because of an implementation limitation. We do have harnesses 
for those cases too, but there is a mechanism to filter them out. 
Instead of writing this information as conditions inside one 
particular test, we write them as `Limitation` objects that can be reused in 
multiple tests and can also be used to generate documentation, e.g., 
the report of [unsupported and 
partially-implemented JAX 
primitives](https://github.com/google/jax/blob/main/jax/experimental/jax2tf/g3doc/jax_primitives_coverage.md) 
 
The limitations are used to filter out from tests the harnesses that are known 
to fail. A Limitation is specific to a harness. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">(Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">,</span>
                    <span class="s1">NamedTuple</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union)</span>

<span class="s3">from </span><span class="s1">absl </span><span class="s3">import </span><span class="s1">testing</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">import </span><span class="s1">jax</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">config</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">jnp</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">ad_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dispatch</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">prng</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">test_util </span><span class="s3">as </span><span class="s1">jtu</span>
<span class="s3">from </span><span class="s1">jax._src.lax </span><span class="s3">import </span><span class="s1">control_flow </span><span class="s3">as </span><span class="s1">lax_control_flow</span>
<span class="s3">from </span><span class="s1">jax._src.lax </span><span class="s3">import </span><span class="s1">windowed_reductions </span><span class="s3">as </span><span class="s1">lax_windowed_reductions</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">xla_client</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">random </span><span class="s3">as </span><span class="s1">jax_random</span>

<span class="s1">FLAGS = config.FLAGS</span>

<span class="s1">Rng = Any  </span><span class="s0"># A random number generator</span>
<span class="s1">DType = Any</span>


<span class="s3">class </span><span class="s1">RandArg(NamedTuple):</span>
  <span class="s2">&quot;&quot;&quot;Descriptor for a randomly generated argument. 
 
  See description of `Harness`. 
  &quot;&quot;&quot;</span>
  <span class="s1">shape: Tuple[int</span><span class="s3">, </span><span class="s1">...]</span>
  <span class="s1">dtype: DType</span>


<span class="s3">class </span><span class="s1">StaticArg(NamedTuple):</span>
  <span class="s2">&quot;&quot;&quot;Descriptor for a static argument. 
 
  See description of `Harness`. 
  &quot;&quot;&quot;</span>
  <span class="s1">value: Any</span>


<span class="s3">class </span><span class="s1">CustomArg(NamedTuple):</span>
  <span class="s2">&quot;&quot;&quot;Descriptor for a dynamic argument generated from a PRNG factory. 
 
  See description of `Harness`. 
  &quot;&quot;&quot;</span>
  <span class="s1">make: Callable[[Rng]</span><span class="s3">, </span><span class="s1">Any]  </span><span class="s0"># Called with a Rng to make a tensor</span>


<span class="s1">ArgDescriptor = Union[RandArg</span><span class="s3">, </span><span class="s1">StaticArg</span><span class="s3">, </span><span class="s1">CustomArg</span><span class="s3">, </span><span class="s1">Any]</span>


<span class="s3">class </span><span class="s1">Harness:</span>
  <span class="s2">&quot;&quot;&quot;Specifies inputs and callable for a primitive. 
 
  See the module docstring for an introduction to harnesses. 
 
  A harness is conceptually a callable and a list of arguments, that together 
  exercise a use case. The harness can optionally have additional parameters 
  that can be used by the test. 
 
  The arguments are specified through argument descriptors. An argument 
  descriptor can be: 
    * a numeric value or ndarray, or 
    * an instance of ``RandArg(shape, dtype)`` to be used with a PRNG to 
    generate random tensor of the given shape and type, or 
    * an instance of ``CustomArg(fun)`` to be used with a PRNG, or 
    * an instance of ``StaticArg(value)``. Often these are the non-array 
      arguments, e.g., a shape. 
 
  The given callable will be passed one argument corresponding to each 
  argument descriptor, e.g., `harness.fun(* harness.args_maker(rng))`. 
  However, in many applications we only care about the non-static arguments. 
  For that purpose, you can use `harness.dyn_fun(* 
  harness.dyn_args_maked(rng))`, 
  where `harness.dyn_fun` is `harness.fun` specialized to the static arguments. 
 
  For example, a harness for ``lax.take(arr, indices, axis=None)`` may want 
  to expose as external (non-static) argument the array and the indices, and 
  keep the axis as a static argument (technically specializing the `take` to 
  a axis): 
 
    Harness(lax.slice_p, 
            f&quot;take_axis={axis}&quot;, 
            lax.take, 
            [RandArg((2, 4), np.float32), np.array([-1, 0, 1]), 
            StaticArg(axis)], 
            axis=axis) 
 
  Each harness can have a list of Limitations that describe the cases when 
  the harness may not be fully implemented. 
  &quot;&quot;&quot;</span>
  <span class="s0"># The group name most often is the primitive name.</span>
  <span class="s1">group_name: str</span>
  <span class="s0"># Descriptive name of the harness, used as a testcase_name. Unique in a group.</span>
  <span class="s1">name: str</span>
  <span class="s0"># The function taking all arguments (static and dynamic).</span>
  <span class="s1">fun: Callable</span>
  <span class="s0"># Describes how to construct arguments, see the class docstring.</span>
  <span class="s1">arg_descriptors: Sequence[ArgDescriptor]</span>
  <span class="s1">dtype: DType</span>
  <span class="s0"># A set of limitations describing the cases that are not supported or</span>
  <span class="s0"># partially implemented in JAX for this harness.</span>
  <span class="s1">jax_unimplemented: Sequence[</span><span class="s4">&quot;Limitation&quot;</span><span class="s1">]</span>
  <span class="s1">rng_factory: Callable</span>
  <span class="s0"># Carry some arbitrary parameters that the test can access.</span>
  <span class="s1">params: Dict[str</span><span class="s3">, </span><span class="s1">Any]</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">group_name</span><span class="s3">,</span>
               <span class="s1">name</span><span class="s3">,</span>
               <span class="s1">fun</span><span class="s3">,</span>
               <span class="s1">arg_descriptors</span><span class="s3">,</span>
               <span class="s1">*</span><span class="s3">,</span>
               <span class="s1">dtype</span><span class="s3">,</span>
               <span class="s1">rng_factory=jtu.rand_default</span><span class="s3">,</span>
               <span class="s1">jax_unimplemented: Sequence[</span><span class="s4">&quot;Limitation&quot;</span><span class="s1">] = ()</span><span class="s3">,</span>
               <span class="s1">**params):</span>
    <span class="s2">&quot;&quot;&quot;See class docstring.&quot;&quot;&quot;</span>
    <span class="s1">self.group_name = group_name</span>
    <span class="s1">self.name = name</span>
    <span class="s1">self.fun = fun  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">self.arg_descriptors = arg_descriptors</span>
    <span class="s1">self.rng_factory = rng_factory  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">self.jax_unimplemented = jax_unimplemented</span>
    <span class="s1">self.dtype = dtype</span>
    <span class="s1">self.params = params</span>

  <span class="s3">def </span><span class="s1">__str__(self):</span>
    <span class="s3">return </span><span class="s1">self.fullname</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">fullname(self):</span>
    <span class="s3">return </span><span class="s1">self.name </span><span class="s3">if </span><span class="s1">self.group_name </span><span class="s3">is None else </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">self.group_name</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">self.name</span><span class="s3">}</span><span class="s4">&quot;</span>

  <span class="s3">def </span><span class="s1">_arg_maker(self</span><span class="s3">, </span><span class="s1">arg_descriptor</span><span class="s3">, </span><span class="s1">rng: Rng):</span>
    <span class="s3">if </span><span class="s1">isinstance(arg_descriptor</span><span class="s3">, </span><span class="s1">StaticArg):</span>
      <span class="s3">return </span><span class="s1">arg_descriptor.value</span>
    <span class="s3">if </span><span class="s1">isinstance(arg_descriptor</span><span class="s3">, </span><span class="s1">RandArg):</span>
      <span class="s3">return </span><span class="s1">self.rng_factory(rng)(arg_descriptor.shape</span><span class="s3">, </span><span class="s1">arg_descriptor.dtype)</span>
    <span class="s3">if </span><span class="s1">isinstance(arg_descriptor</span><span class="s3">, </span><span class="s1">CustomArg):</span>
      <span class="s3">return </span><span class="s1">arg_descriptor.make(rng)</span>

    <span class="s3">return </span><span class="s1">arg_descriptor</span>

  <span class="s3">def </span><span class="s1">args_maker(self</span><span class="s3">, </span><span class="s1">rng: Rng) -&gt; Sequence:</span>
    <span class="s2">&quot;&quot;&quot;All-argument maker, including the static ones.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">[self._arg_maker(ad</span><span class="s3">, </span><span class="s1">rng) </span><span class="s3">for </span><span class="s1">ad </span><span class="s3">in </span><span class="s1">self.arg_descriptors]</span>

  <span class="s3">def </span><span class="s1">dyn_args_maker(self</span><span class="s3">, </span><span class="s1">rng: Rng) -&gt; Sequence:</span>
    <span class="s2">&quot;&quot;&quot;A dynamic-argument maker, for use with `dyn_fun`.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">[</span>
        <span class="s1">self._arg_maker(ad</span><span class="s3">, </span><span class="s1">rng)</span>
        <span class="s3">for </span><span class="s1">ad </span><span class="s3">in </span><span class="s1">self.arg_descriptors</span>
        <span class="s3">if not </span><span class="s1">isinstance(ad</span><span class="s3">, </span><span class="s1">StaticArg)</span>
    <span class="s1">]</span>

  <span class="s3">def </span><span class="s1">dyn_fun(self</span><span class="s3">, </span><span class="s1">*dyn_args):</span>
    <span class="s2">&quot;&quot;&quot;Invokes `fun` given just the dynamic arguments.&quot;&quot;&quot;</span>
    <span class="s1">all_args = self._args_from_dynargs(dyn_args)</span>
    <span class="s3">return </span><span class="s1">self.fun(*all_args)</span>

  <span class="s3">def </span><span class="s1">_args_from_dynargs(self</span><span class="s3">, </span><span class="s1">dyn_args: Sequence) -&gt; Sequence:</span>
    <span class="s2">&quot;&quot;&quot;All arguments, including the static ones.&quot;&quot;&quot;</span>
    <span class="s1">next_dynamic_argnum = </span><span class="s5">0</span>
    <span class="s1">all_args = []</span>
    <span class="s3">for </span><span class="s1">ad </span><span class="s3">in </span><span class="s1">self.arg_descriptors:</span>
      <span class="s3">if </span><span class="s1">isinstance(ad</span><span class="s3">, </span><span class="s1">StaticArg):</span>
        <span class="s1">all_args.append(ad.value)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">all_args.append(dyn_args[next_dynamic_argnum])</span>
        <span class="s1">next_dynamic_argnum += </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s1">all_args</span>

  <span class="s3">def </span><span class="s1">filter(self</span><span class="s3">,</span>
             <span class="s1">device_under_test: str</span><span class="s3">,</span>
             <span class="s1">*</span><span class="s3">,</span>
             <span class="s1">include_jax_unimpl: bool = </span><span class="s3">False,</span>
             <span class="s1">one_containing: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; bool:</span>
    <span class="s3">if not </span><span class="s1">include_jax_unimpl:</span>
      <span class="s3">if </span><span class="s1">any([</span>
          <span class="s1">device_under_test </span><span class="s3">in </span><span class="s1">l.devices</span>
          <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">self.jax_unimplemented</span>
          <span class="s3">if </span><span class="s1">l.filter(device=device_under_test</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
      <span class="s1">]):</span>
        <span class="s3">return False</span>

    <span class="s3">if </span><span class="s1">one_containing </span><span class="s3">is not None and </span><span class="s1">one_containing </span><span class="s3">not in </span><span class="s1">self.fullname:</span>
      <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">dtypes_to_str(dtype_list: Sequence[DType]</span><span class="s3">, </span><span class="s1">empty_means_all=</span><span class="s3">False</span><span class="s1">) -&gt; str:</span>
  <span class="s2">&quot;&quot;&quot;User-friendly description of a set of dtypes&quot;&quot;&quot;</span>
  <span class="s3">if not </span><span class="s1">dtype_list </span><span class="s3">and </span><span class="s1">empty_means_all:</span>
    <span class="s3">return </span><span class="s4">&quot;all&quot;</span>

  <span class="s1">names = {np.dtype(dt).name </span><span class="s3">for </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">dtype_list}</span>
  <span class="s1">signed = {</span><span class="s4">&quot;int8&quot;</span><span class="s3">, </span><span class="s4">&quot;int16&quot;</span><span class="s3">, </span><span class="s4">&quot;int32&quot;</span><span class="s3">, </span><span class="s4">&quot;int64&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">signed]):</span>
    <span class="s1">names = (names - signed) | {</span><span class="s4">&quot;signed&quot;</span><span class="s1">}</span>
  <span class="s1">integers = {</span><span class="s4">&quot;uint8&quot;</span><span class="s3">, </span><span class="s4">&quot;uint16&quot;</span><span class="s3">, </span><span class="s4">&quot;uint32&quot;</span><span class="s3">, </span><span class="s4">&quot;uint64&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">integers]):</span>
    <span class="s1">names = (names - integers) | {</span><span class="s4">&quot;unsigned&quot;</span><span class="s1">}</span>
  <span class="s1">integer = {</span><span class="s4">&quot;signed&quot;</span><span class="s3">, </span><span class="s4">&quot;unsigned&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">integer]):</span>
    <span class="s1">names = (names - integer) | {</span><span class="s4">&quot;integer&quot;</span><span class="s1">}</span>

  <span class="s1">floating = {</span><span class="s4">&quot;bfloat16&quot;</span><span class="s3">, </span><span class="s4">&quot;float16&quot;</span><span class="s3">, </span><span class="s4">&quot;float32&quot;</span><span class="s3">, </span><span class="s4">&quot;float64&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">floating]):</span>
    <span class="s1">names = (names - floating) | {</span><span class="s4">&quot;floating&quot;</span><span class="s1">}</span>

  <span class="s1">complex = {</span><span class="s4">&quot;complex64&quot;</span><span class="s3">, </span><span class="s4">&quot;complex128&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">complex]):</span>
    <span class="s1">names = (names - complex) | {</span><span class="s4">&quot;complex&quot;</span><span class="s1">}</span>

  <span class="s1">inexact = {</span><span class="s4">&quot;floating&quot;</span><span class="s3">, </span><span class="s4">&quot;complex&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">inexact]):</span>
    <span class="s1">names = (names - inexact) | {</span><span class="s4">&quot;inexact&quot;</span><span class="s1">}</span>

  <span class="s1">all_types = {</span><span class="s4">&quot;integer&quot;</span><span class="s3">, </span><span class="s4">&quot;inexact&quot;</span><span class="s3">, </span><span class="s4">&quot;bool&quot;</span><span class="s1">}</span>
  <span class="s3">if </span><span class="s1">all([t </span><span class="s3">in </span><span class="s1">names </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">all_types]):</span>
    <span class="s1">names = (names - all_types) | {</span><span class="s4">&quot;all&quot;</span><span class="s1">}</span>

  <span class="s3">return </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(sorted(list(names)))</span>


<span class="s0">##### All harnesses in this file.</span>
<span class="s1">all_harnesses: List[Harness] = []</span>


<span class="s3">def </span><span class="s1">define(</span>
    <span class="s1">group_name</span><span class="s3">,  </span><span class="s0"># Should be the primitive name, as much as possible</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">fun</span><span class="s3">,</span>
    <span class="s1">arg_descriptors</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">,</span>
    <span class="s1">rng_factory=jtu.rand_default</span><span class="s3">,</span>
    <span class="s1">jax_unimplemented: Sequence[</span><span class="s4">&quot;Limitation&quot;</span><span class="s1">] = ()</span><span class="s3">,</span>
    <span class="s1">**params):</span>
  <span class="s2">&quot;&quot;&quot;Defines a harness and stores it in `all_harnesses`. See Harness.&quot;&quot;&quot;</span>
  <span class="s1">group_name = str(group_name)</span>
  <span class="s1">h = Harness(</span>
      <span class="s1">group_name</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">fun</span><span class="s3">,</span>
      <span class="s1">arg_descriptors</span><span class="s3">,</span>
      <span class="s1">rng_factory=rng_factory</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=jax_unimplemented</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">**params)</span>
  <span class="s1">all_harnesses.append(h)</span>


<span class="s3">class </span><span class="s1">Limitation:</span>
  <span class="s2">&quot;&quot;&quot;Encodes conditions under which a harness is limited, e.g., not runnable in JAX. 
 
  See the module docstring for an introduction to harnesses and limitations. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">description: str</span><span class="s3">,</span>
      <span class="s1">*</span><span class="s3">,</span>
      <span class="s1">enabled: bool = </span><span class="s3">True,</span>
      <span class="s1">devices: Union[str</span><span class="s3">, </span><span class="s1">Sequence[str]] = (</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s3">, </span><span class="s4">&quot;tpu&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">dtypes: Sequence[DType] = ()</span><span class="s3">,</span>
      <span class="s1">skip_run: bool = </span><span class="s3">False,</span>
  <span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Args: 
 
      description: text to augment the harness group name with the description 
      of the limitation. Used for reports. 
      enabled: whether this limitation is enabled for the harness in which 
        it appears. This is only used during testing to know whether to ignore 
        harness errors. Use this sparingly, prefer `devices` and 
        `dtypes` for enabled conditions that are included in reports. 
      devices: a device type (string) or a sequence of device types 
        for which this applies. By default, it applies to all devices types. 
        Used for filtering during harness execution, and for reports. 
      dtypes: the sequence of dtypes for which this applies. An empty sequence 
        denotes all dtypes. Used for filtering during harness execution, and 
        for reports. 
      skip_run: this harness should not even be invoked (typically because it 
        results in a crash). This should be rare. 
    &quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(description</span><span class="s3">, </span><span class="s1">str)</span><span class="s3">, </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">description</span><span class="s3">}</span><span class="s4">&quot;</span>
    <span class="s1">self.description = description</span>
    <span class="s1">self.skip_run = skip_run</span>
    <span class="s3">if </span><span class="s1">isinstance(devices</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s1">devices = (devices</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">devices = tuple(devices)</span>
    <span class="s1">self.devices = devices</span>
    <span class="s3">assert </span><span class="s1">isinstance(dtypes</span><span class="s3">, </span><span class="s1">Iterable)</span>
    <span class="s1">dtypes = tuple(dtypes)</span>
    <span class="s1">self.dtypes = dtypes</span>
    <span class="s1">self.enabled = enabled  </span><span class="s0"># Does it apply to the current harness?</span>

  <span class="s3">def </span><span class="s1">__str__(self):</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s4">f&quot;</span><span class="s3">\&quot;{</span><span class="s1">self.description</span><span class="s3">}\&quot; </span><span class="s4">devices=</span><span class="s3">{</span><span class="s1">self.devices</span><span class="s3">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;dtypes=</span><span class="s3">{</span><span class="s1">[np.dtype(dt).name </span><span class="s3">for </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">self.dtypes]</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s4">&quot; (skip_run) &quot; </span><span class="s3">if </span><span class="s1">self.skip_run </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s1">))</span>

  <span class="s1">__repr__ = __str__</span>

  <span class="s3">def </span><span class="s1">filter(self</span><span class="s3">,</span>
             <span class="s1">device: Optional[str] = </span><span class="s3">None,</span>
             <span class="s1">dtype: Optional[DType] = </span><span class="s3">None</span><span class="s1">) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Check that a limitation is enabled for the given dtype and device.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">(self.enabled </span><span class="s3">and</span>
            <span class="s1">(</span><span class="s3">not </span><span class="s1">self.dtypes </span><span class="s3">or </span><span class="s1">dtype </span><span class="s3">is None or </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">self.dtypes) </span><span class="s3">and</span>
            <span class="s1">(device </span><span class="s3">is None or </span><span class="s1">device </span><span class="s3">in </span><span class="s1">self.devices))</span>


<span class="s3">def </span><span class="s1">parameterized(harnesses: Iterable[Harness]</span><span class="s3">,</span>
                  <span class="s1">*</span><span class="s3">,</span>
                  <span class="s1">one_containing: Optional[str] = </span><span class="s3">None,</span>
                  <span class="s1">include_jax_unimpl: bool = </span><span class="s3">False</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Decorator for tests. 
 
  The tests receive a `harness` argument. 
 
  The `JAX_TEST_HARNESS_ONE_CONTAINING` environment variable is useful for 
  debugging. If given, then picks only one harness whose name contains the 
  string. The whole set of parameterized tests is reduced to one test, 
  whose name is not decorated to make it easier to pick with an IDE for 
  running. 
  &quot;&quot;&quot;</span>
  <span class="s1">one_containing = one_containing </span><span class="s3">or </span><span class="s1">os.environ.get(</span>
      <span class="s4">&quot;JAX_TEST_HARNESS_ONE_CONTAINING&quot;</span><span class="s1">)</span>
  <span class="s1">cases = tuple(</span>
      <span class="s0"># Change the testcase name to include the harness name.</span>
      <span class="s1">dict(</span>
          <span class="s1">testcase_name=harness.fullname </span><span class="s3">if </span><span class="s1">one_containing </span><span class="s3">is None else </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
          <span class="s1">harness=harness) </span><span class="s3">for </span><span class="s1">harness </span><span class="s3">in </span><span class="s1">harnesses </span><span class="s3">if </span><span class="s1">harness.filter(</span>
              <span class="s1">jtu.device_under_test()</span><span class="s3">,</span>
              <span class="s1">one_containing=one_containing</span><span class="s3">,</span>
              <span class="s1">include_jax_unimpl=include_jax_unimpl))</span>
  <span class="s3">if </span><span class="s1">one_containing </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">if not </span><span class="s1">cases:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s4">f&quot;Cannot find test case with name containing </span><span class="s3">{</span><span class="s1">one_containing</span><span class="s3">}</span><span class="s4">.&quot;</span>
          <span class="s4">&quot;Names are:&quot;</span>
          <span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join([harness.fullname </span><span class="s3">for </span><span class="s1">harness </span><span class="s3">in </span><span class="s1">harnesses]))</span>
    <span class="s1">cases = cases[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">if not </span><span class="s1">cases:</span>
    <span class="s0"># We filtered out all the harnesses.</span>
    <span class="s3">return </span><span class="s1">jtu.skip_on_devices(jtu.device_under_test())</span>
  <span class="s3">return </span><span class="s1">testing.parameterized.named_parameters(*cases)</span>


<span class="s0">###############################################################################</span>
<span class="s0">###                    Harness definitions                                  ###</span>
<span class="s0">###############################################################################</span>


<span class="s3">def </span><span class="s1">_make_unary_elementwise_harness(*</span><span class="s3">, </span><span class="s1">prim</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype):</span>
  <span class="s1">define(</span>
      <span class="s1">str(prim)</span><span class="s3">,</span>
      <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">prim.bind</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">prim=prim</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">shape=shape)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">(set(jtu.dtypes.all) -</span>
              <span class="s1">set(jtu.dtypes.all_unsigned + jtu.dtypes.boolean)):</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.abs_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating + jtu.dtypes.complex:</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.acosh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.asinh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.atanh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.acos_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.atan_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.asin_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.cos_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.cosh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.exp_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.expm1_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.log_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.log1p_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.rsqrt_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.sin_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.sinh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.sqrt_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.tan_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.tanh_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.logistic_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.bessel_i0e_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.bessel_i1e_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.ceil_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.erf_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.erf_inv_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.erfc_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.floor_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.is_finite_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.lgamma_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.digamma_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.cbrt_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.boolean):</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.neg_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">_make_unary_elementwise_harness(prim=lax.sign_p</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">define(</span>
      <span class="s1">str(lax.sign_p)</span><span class="s3">,</span>
      <span class="s4">f&quot;special_0_dtype=</span><span class="s3">{</span><span class="s1">jtu.dtype_str(dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.sign_p.bind</span><span class="s3">, </span><span class="s1">[StaticArg(np.zeros((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=dtype))]</span><span class="s3">,</span>
      <span class="s1">prim=lax.sign_p</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_make_round_harness(name</span><span class="s3">,</span>
                        <span class="s1">*</span><span class="s3">,</span>
                        <span class="s1">shape=(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                        <span class="s1">rounding_method=lax.RoundingMethod.AWAY_FROM_ZERO</span><span class="s3">,</span>
                        <span class="s1">operand=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">operand = operand </span><span class="s3">if </span><span class="s1">operand </span><span class="s3">is not None else </span><span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;round&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(operand.shape</span><span class="s3">, </span><span class="s1">operand.dtype)</span><span class="s3">}</span><span class="s4">_roundingmethod=</span><span class="s3">{</span><span class="s1">rounding_method</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.round</span><span class="s3">, </span><span class="s1">[operand</span><span class="s3">, </span><span class="s1">StaticArg(rounding_method)]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">operand=operand</span><span class="s3">,</span>
      <span class="s1">rounding_method=rounding_method)</span>


<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s1">_make_round_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">rounding_method </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">lax.RoundingMethod.AWAY_FROM_ZERO</span><span class="s3">, </span><span class="s1">lax.RoundingMethod.TO_NEAREST_EVEN</span>
<span class="s1">]:</span>
  <span class="s1">operand = np.array([[</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.2</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">1.7</span><span class="s3">, </span><span class="s5">2.5</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[-</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.5</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.7</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.5</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span>
  <span class="s1">_make_round_harness(</span>
      <span class="s4">&quot;rounding_methods&quot;</span><span class="s3">, </span><span class="s1">operand=operand</span><span class="s3">, </span><span class="s1">rounding_method=rounding_method)</span>


<span class="s3">def </span><span class="s1">_make_convert_element_type_harness(name</span><span class="s3">,</span>
                                       <span class="s1">*</span><span class="s3">,</span>
                                       <span class="s1">shape=(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)</span><span class="s3">,</span>
                                       <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                       <span class="s1">new_dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;convert_element_type&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_olddtype=</span><span class="s3">{</span><span class="s1">jtu.dtype_str(dtype)</span><span class="s3">}</span><span class="s4">_newdtype=</span><span class="s3">{</span><span class="s1">jtu.dtype_str(new_dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">arg: (lax.convert_element_type_p.bind(</span>
          <span class="s1">arg</span><span class="s3">, </span><span class="s1">new_dtype=np.dtype(new_dtype)</span><span class="s3">, </span><span class="s1">weak_type=</span><span class="s3">False</span><span class="s1">))</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">new_dtype=new_dtype)</span>


<span class="s3">for </span><span class="s1">old_dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s0"># TODO(bchetioui): JAX behaves weirdly when old_dtype corresponds to floating</span>
  <span class="s0"># point numbers and new_dtype is an unsigned integer. See issue</span>
  <span class="s0"># https://github.com/google/jax/issues/5082 for details.</span>
  <span class="s3">for </span><span class="s1">new_dtype </span><span class="s3">in </span><span class="s1">(jtu.dtypes.all</span>
                    <span class="s3">if not </span><span class="s1">(dtypes.issubdtype(old_dtype</span><span class="s3">, </span><span class="s1">np.floating) </span><span class="s3">or</span>
                            <span class="s1">dtypes.issubdtype(old_dtype</span><span class="s3">, </span><span class="s1">np.complexfloating))</span>
                    <span class="s3">else </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.all_unsigned)):</span>
    <span class="s1">_make_convert_element_type_harness(</span>
        <span class="s4">&quot;dtypes_to_dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=old_dtype</span><span class="s3">, </span><span class="s1">new_dtype=new_dtype)</span>


<span class="s3">def </span><span class="s1">_make_integer_pow_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.int32</span><span class="s3">, </span><span class="s1">y=</span><span class="s5">3</span><span class="s1">):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;integer_pow&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">y=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.integer_pow</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">StaticArg(y)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">y=y)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">jtu.dtypes.all </span><span class="s3">if </span><span class="s1">d </span><span class="s3">not in </span><span class="s1">jtu.dtypes.boolean]:</span>
  <span class="s0"># Validate dtypes and y values for some special cases.</span>
  <span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">range(-</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">np.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer) </span><span class="s3">and </span><span class="s1">y &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">continue  </span><span class="s0"># No negative powers for integers</span>
    <span class="s1">_make_integer_pow_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">y=y)</span>
  <span class="s0"># Validate overflow behavior by dtype. 127</span>
  <span class="s1">_make_integer_pow_harness(</span><span class="s4">&quot;overflow&quot;</span><span class="s3">, </span><span class="s1">y=</span><span class="s5">127</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s0"># Validate negative y by dtype</span>
  <span class="s1">_make_integer_pow_harness(</span><span class="s4">&quot;negative_overflow&quot;</span><span class="s3">, </span><span class="s1">y=-</span><span class="s5">127</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_make_pow_harness(name</span><span class="s3">,</span>
                      <span class="s1">*</span><span class="s3">,</span>
                      <span class="s1">shapes=((</span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s1">))</span><span class="s3">,</span>
                      <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                      <span class="s1">lhs=</span><span class="s3">None,</span>
                      <span class="s1">rhs=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">lhs = RandArg(shapes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">if </span><span class="s1">lhs </span><span class="s3">is None else </span><span class="s1">lhs</span>
  <span class="s1">rhs = RandArg(shapes[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">if </span><span class="s1">rhs </span><span class="s3">is None else </span><span class="s1">rhs</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;pow&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs.shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs.shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.pow</span><span class="s3">, </span><span class="s1">[lhs</span><span class="s3">, </span><span class="s1">rhs]</span><span class="s3">,</span>
      <span class="s1">lhs=lhs</span><span class="s3">,</span>
      <span class="s1">rhs=rhs</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s0"># Validate dtypes</span>
  <span class="s1">_make_pow_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate broadcasting behavior</span>
<span class="s3">for </span><span class="s1">shapes </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcasting lhs</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">, </span><span class="s1">())</span><span class="s3">,  </span><span class="s0"># broadcasting rhs</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcasting lhs on a specific axis</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">6</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcasting rhs on a specific axis</span>
<span class="s1">]:</span>
  <span class="s1">_make_pow_harness(</span><span class="s4">&quot;broadcast&quot;</span><span class="s3">, </span><span class="s1">shapes=shapes)</span>


<span class="s3">def </span><span class="s1">_make_reshape_harness(name</span><span class="s3">,</span>
                          <span class="s1">*</span><span class="s3">,</span>
                          <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">new_sizes=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dimensions=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;reshape&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_newsizes=</span><span class="s3">{</span><span class="s1">new_sizes</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimensions=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.reshape</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
       <span class="s1">StaticArg(new_sizes)</span><span class="s3">,</span>
       <span class="s1">StaticArg(dimensions)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">new_sizes=new_sizes</span><span class="s3">,</span>
      <span class="s1">dimensions=dimensions)</span>


<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_reshape_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate new_sizes</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">new_sizes</span><span class="s3">, </span><span class="s1">dimensions </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># merging two dimensions</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">15</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># changing leading dimension</span>
<span class="s1">]:</span>
  <span class="s1">_make_reshape_harness(</span>
      <span class="s4">&quot;new_sizes&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">new_sizes=new_sizes</span><span class="s3">, </span><span class="s1">dimensions=dimensions)</span>
<span class="s0"># Validate dimensions collapsing order</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">new_sizes</span><span class="s3">, </span><span class="s1">dimensions </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># transpose shape (0, 1, 2) into (2, 1, 0)</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># transpose shape (0, 1, 2) into (2, 0, 1)</span>
<span class="s1">]:</span>
  <span class="s1">_make_reshape_harness(</span>
      <span class="s4">&quot;dimensions&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">new_sizes=new_sizes</span><span class="s3">, </span><span class="s1">dimensions=dimensions)</span>


<span class="s3">def </span><span class="s1">_make_rev_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32</span><span class="s3">, </span><span class="s1">dimensions=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;rev&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimensions=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.rev</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">StaticArg(dimensions)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">dimensions=dimensions)</span>


<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_rev_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Validate dimensions</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dimensions </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">())</span><span class="s3">,  </span><span class="s0"># empty dimensions</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># some dimensions</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># all dimensions (ordered)</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># all dimensions (unordered)</span>
<span class="s1">]:</span>
  <span class="s1">_make_rev_harness(</span><span class="s4">&quot;dimensions&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">dimensions=dimensions)</span>


<span class="s3">def </span><span class="s1">_make_device_put_harness(name</span><span class="s3">,</span>
                             <span class="s1">*</span><span class="s3">,</span>
                             <span class="s1">shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">,</span>
                             <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                             <span class="s1">device=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">_device_fn = </span><span class="s3">lambda</span><span class="s1">: jax.devices(device)[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">device </span><span class="s3">is not None else None</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;device_put&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">device=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">x: dispatch.device_put_p.bind(x</span><span class="s3">, </span><span class="s1">device=_device_fn()</span><span class="s3">, </span><span class="s1">src=</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">device=device)</span>


<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_device_put_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Validate devices</span>
<span class="s1">_make_device_put_harness(</span><span class="s4">&quot;devices&quot;</span><span class="s3">, </span><span class="s1">device=</span><span class="s4">&quot;cpu&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_make_bitcast_convert_type_harness(name</span><span class="s3">,</span>
                                       <span class="s1">*</span><span class="s3">,</span>
                                       <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                                       <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                       <span class="s1">new_dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;bitcast_convert_type&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_newdtype=</span><span class="s3">{</span><span class="s1">np.dtype(new_dtype).name</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">x: lax.bitcast_convert_type_p.bind(x</span><span class="s3">,</span>
                                                <span class="s1">new_dtype=np.dtype(new_dtype))</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">new_dtype=new_dtype)</span>


<span class="s3">def </span><span class="s1">_can_bitcast(dtype</span><span class="s3">, </span><span class="s1">target_dtype):</span>

  <span class="s3">def </span><span class="s1">_to_equivalence_class(dtype):</span>
    <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
      <span class="s3">return </span><span class="s1">dtypes.iinfo(dtype).bits</span>
    <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
      <span class="s3">return </span><span class="s1">dtypes.finfo(dtype).bits</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">assert </span><span class="s1">dtype == np.bool_ </span><span class="s3">or </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)</span>
      <span class="s0"># Complex and boolean types can only be cast to themselves</span>
      <span class="s3">return </span><span class="s1">np.dtype(dtype).name</span>

  <span class="s3">return </span><span class="s1">_to_equivalence_class(dtype) == _to_equivalence_class(target_dtype)</span>


<span class="s0"># Validate dtypes combinations</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s3">for </span><span class="s1">new_dtype </span><span class="s3">in </span><span class="s1">filter(partial(_can_bitcast</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">jtu.dtypes.all):</span>
    <span class="s1">_make_bitcast_convert_type_harness(</span>
        <span class="s4">&quot;dtypes_to_new_dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">new_dtype=new_dtype)</span>


<span class="s3">def </span><span class="s1">_make_add_any_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shapes=((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">ad_util.add_any_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shapes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shapes[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">ad_util.add_jaxvals_p.bind</span><span class="s3">,</span>
      <span class="s1">list(map(</span><span class="s3">lambda </span><span class="s1">s: RandArg(s</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">shapes))</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">shapes=shapes)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.boolean):</span>
  <span class="s1">_make_add_any_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">shape: Tuple[int</span><span class="s3">, </span><span class="s1">...] = (</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span>
  <span class="s1">define(</span>
      <span class="s1">ad_util.stop_gradient_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">ad_util.stop_gradient_p.bind</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>

<span class="s1">_LAX_COMPARATORS = dict(eq=jnp.equal</span><span class="s3">, </span><span class="s1">ne=jnp.not_equal</span><span class="s3">,</span>
                        <span class="s1">ge=jnp.greater_equal</span><span class="s3">, </span><span class="s1">gt=jnp.greater</span><span class="s3">,</span>
                        <span class="s1">le=jnp.less_equal</span><span class="s3">, </span><span class="s1">lt=jnp.less)</span>


<span class="s3">def </span><span class="s1">_make_comparator_harness(name</span><span class="s3">,</span>
                             <span class="s1">*</span><span class="s3">,</span>
                             <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                             <span class="s1">op=lax.eq_p</span><span class="s3">,</span>
                             <span class="s1">op_name=</span><span class="s4">&quot;eq&quot;</span><span class="s3">,</span>
                             <span class="s1">lhs_shape=()</span><span class="s3">,</span>
                             <span class="s1">rhs_shape=()):</span>
  <span class="s1">define(</span>
      <span class="s1">op_name</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">*args: op(*args)</span><span class="s3">,</span>
      <span class="s1">[RandArg(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
       <span class="s1">RandArg(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">op=op</span><span class="s3">,</span>
      <span class="s1">op_name=op_name</span><span class="s3">,</span>
      <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
      <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>


<span class="s3">for </span><span class="s1">op_name</span><span class="s3">, </span><span class="s1">op </span><span class="s3">in </span><span class="s1">_LAX_COMPARATORS.items():</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">(jtu.dtypes.all </span><span class="s3">if </span><span class="s1">op </span><span class="s3">in </span><span class="s1">[lax.eq_p</span><span class="s3">, </span><span class="s1">lax.ne_p] </span><span class="s3">else</span>
                <span class="s1">set(jtu.dtypes.all)):</span>
    <span class="s0"># Validate dtypes</span>
    <span class="s1">_make_comparator_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">op=op</span><span class="s3">, </span><span class="s1">op_name=op_name)</span>

  <span class="s0"># Validate broadcasting behavior</span>
  <span class="s3">for </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast scalar</span>
      <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast along specific axis</span>
  <span class="s1">]:</span>
    <span class="s1">_make_comparator_harness(</span>
        <span class="s4">&quot;broadcasting&quot;</span><span class="s3">, </span><span class="s1">lhs_shape=lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">op=op</span><span class="s3">, </span><span class="s1">op_name=op_name)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">shape = (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;zeros_like&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">ad_util.zeros_like_p.bind</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_integer + jtu.dtypes.all_unsigned:</span>
  <span class="s1">arg = np.array([-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;population_count&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">jtu.dtype_str(dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.population_count</span><span class="s3">, </span><span class="s1">[arg]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_get_max_identity(dtype):</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.inexact):</span>
    <span class="s3">return </span><span class="s1">np.array(-np.inf</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">np.array(dtypes.iinfo(dtype).min</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.bool_):</span>
    <span class="s3">return </span><span class="s1">np.array(</span><span class="s3">False, </span><span class="s1">np.bool_)</span>


<span class="s3">def </span><span class="s1">_get_min_identity(dtype):</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.inexact):</span>
    <span class="s3">return </span><span class="s1">np.array(np.inf</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">np.array(dtypes.iinfo(dtype).max</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.bool_):</span>
    <span class="s3">return </span><span class="s1">np.array(</span><span class="s3">True, </span><span class="s1">np.bool_)</span>


<span class="s3">def </span><span class="s1">_make_argminmax_harness(prim</span><span class="s3">,</span>
                            <span class="s1">name</span><span class="s3">,</span>
                            <span class="s1">*</span><span class="s3">,</span>
                            <span class="s1">shape=(</span><span class="s5">15</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">dtype=jnp.float32</span><span class="s3">,</span>
                            <span class="s1">axes=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">index_dtype=np.int32</span><span class="s3">,</span>
                            <span class="s1">arr=</span><span class="s3">None,</span>
                            <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">):</span>
  <span class="s1">arr = arr </span><span class="s3">if </span><span class="s1">arr </span><span class="s3">is not None else </span><span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape = arr.dtype</span><span class="s3">, </span><span class="s1">arr.shape</span>
  <span class="s1">index_dtype = dtypes.canonicalize_dtype(index_dtype)</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">prim</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">axes=</span><span class="s3">}</span><span class="s4">_indexdtype=</span><span class="s3">{</span><span class="s1">index_dtype</span><span class="s3">}</span><span class="s4">_enablexla=</span><span class="s3">{</span><span class="s1">enable_xla</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">arg: prim.bind(arg</span><span class="s3">, </span><span class="s1">axes=axes</span><span class="s3">, </span><span class="s1">index_dtype=index_dtype)</span><span class="s3">, </span><span class="s1">[arr]</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">axes=axes</span><span class="s3">,</span>
        <span class="s1">index_dtype=index_dtype</span><span class="s3">,</span>
        <span class="s1">prim=prim</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s3">for </span><span class="s1">prim </span><span class="s3">in </span><span class="s1">[lax.argmin_p</span><span class="s3">, </span><span class="s1">lax.argmax_p]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.complex):</span>
    <span class="s0"># Validate dtypes for each primitive</span>
    <span class="s1">_make_argminmax_harness(prim</span><span class="s3">, </span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

  <span class="s0"># Validate axes for each primitive; non major axis</span>
  <span class="s1">_make_argminmax_harness(prim</span><span class="s3">, </span><span class="s4">&quot;axes&quot;</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">18</span><span class="s3">, </span><span class="s5">12</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axes=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span>

  <span class="s0"># Validate index dtype for each primitive</span>
  <span class="s3">for </span><span class="s1">index_dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_integer + jtu.dtypes.all_unsigned:</span>
    <span class="s1">_make_argminmax_harness(prim</span><span class="s3">, </span><span class="s4">&quot;index_dtype&quot;</span><span class="s3">, </span><span class="s1">index_dtype=index_dtype)</span>

  <span class="s0"># Some special cases, with equal elements and NaN</span>
  <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">operand </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(</span><span class="s4">&quot;nan_0&quot;</span><span class="s3">, </span><span class="s1">np.array([np.nan</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">-np.nan</span><span class="s3">, </span><span class="s1">-np.nan]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;nan_1&quot;</span><span class="s3">, </span><span class="s1">np.array([np.nan</span><span class="s3">, </span><span class="s1">-np.nan</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;inf_0&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;inf_1&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;inf_2&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;inf_3&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;nan_inf_0&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;nan_inf_1&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;equal&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">2.</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, </span><span class="s5">2.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.int32))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;singleton&quot;</span><span class="s3">, </span><span class="s1">np.array([</span><span class="s5">1.</span><span class="s1">]</span><span class="s3">, </span><span class="s1">np.float32))</span><span class="s3">,</span>
      <span class="s1">]:</span>
    <span class="s1">_make_argminmax_harness(prim</span><span class="s3">, </span><span class="s4">f&quot;special_</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">shape=operand.shape</span><span class="s3">,</span>
                            <span class="s1">arr=operand)</span>

<span class="s0"># TODO(bchetioui): the below documents a limitation of argmin and argmax when a</span>
<span class="s0"># dimension of the input is too large. However, it is not categorizable as it</span>
<span class="s0"># seems that the converter fails before reaching the actual primitive call. This</span>
<span class="s0"># suggests that we may need to harden the converter to handle inputs this big.</span>
<span class="s0"># + tuple( # Document limitation in case of too large axis</span>
<span class="s0">#  _make_argminmax_harness(&quot;overflow_axis&quot;, prim=prim,</span>
<span class="s0">#                          arr=np.ones((2**31,), dtype=np.uint8))</span>
<span class="s0">#  for prim in [lax.argmin_p, lax.argmax_p]</span>
<span class="s0"># )</span>


<span class="s3">def </span><span class="s1">_make_iota_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32</span><span class="s3">, </span><span class="s1">dimension=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.iota_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimension=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dim:</span>
      <span class="s1">(lax.iota_p.bind(dtype=np.dtype(dtype)</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">dimension=dim))</span><span class="s3">,</span>
      <span class="s1">[StaticArg(dtype)</span><span class="s3">,</span>
       <span class="s1">StaticArg(shape)</span><span class="s3">,</span>
       <span class="s1">StaticArg(dimension)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">dimension=dimension)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.boolean):</span>
  <span class="s1">_make_iota_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate broadcasting</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dimension </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># broadcasting along non-major dimension</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># broadcasting along dimension == 1</span>
<span class="s1">]:</span>
  <span class="s1">_make_iota_harness(</span><span class="s4">&quot;broadcasting&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">dimension=dimension)</span>


<span class="s3">def </span><span class="s1">_make_div_rem_harness(prim</span><span class="s3">,</span>
                          <span class="s1">name</span><span class="s3">,</span>
                          <span class="s1">*</span><span class="s3">,</span>
                          <span class="s1">shapes=((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
                          <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                          <span class="s1">arrs=(</span><span class="s3">None, None</span><span class="s1">)):</span>
  <span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs = arrs</span>

  <span class="s3">def </span><span class="s1">_make_non_zero(rng):</span>
    <span class="s3">return </span><span class="s1">jtu.rand_nonzero(rng)(shapes[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span>

  <span class="s1">lhs = RandArg(shapes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">if </span><span class="s1">lhs </span><span class="s3">is None else </span><span class="s1">lhs</span>
  <span class="s1">rhs_shape = rhs.shape </span><span class="s3">if </span><span class="s1">rhs </span><span class="s3">is not None else </span><span class="s1">shapes[</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">rhs_dtype = rhs.dtype </span><span class="s3">if </span><span class="s1">rhs </span><span class="s3">is not None else </span><span class="s1">dtype</span>
  <span class="s1">rhs = CustomArg(_make_non_zero) </span><span class="s3">if </span><span class="s1">rhs </span><span class="s3">is None else </span><span class="s1">rhs</span>

  <span class="s1">define(</span>
      <span class="s1">prim</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs.shape</span><span class="s3">, </span><span class="s1">lhs.dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs_shape</span><span class="s3">, </span><span class="s1">rhs_dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">prim.bind</span><span class="s3">, </span><span class="s1">[lhs</span><span class="s3">, </span><span class="s1">rhs]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">lhs=lhs</span><span class="s3">,</span>
      <span class="s1">rhs=rhs</span><span class="s3">,</span>
      <span class="s1">prim=prim)</span>


<span class="s3">for </span><span class="s1">prim </span><span class="s3">in </span><span class="s1">[lax.div_p</span><span class="s3">, </span><span class="s1">lax.rem_p]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.boolean) - (</span>
      <span class="s1">set() </span><span class="s3">if </span><span class="s1">prim </span><span class="s3">is </span><span class="s1">lax.div_p </span><span class="s3">else </span><span class="s1">set(jtu.dtypes.complex)):</span>
    <span class="s1">_make_div_rem_harness(prim</span><span class="s3">, </span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

  <span class="s0"># Validate broadcasting</span>
  <span class="s3">for </span><span class="s1">shapes </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast dividend</span>
      <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast divisor</span>
  <span class="s1">]:</span>
    <span class="s1">_make_div_rem_harness(prim</span><span class="s3">, </span><span class="s4">&quot;broadcast&quot;</span><span class="s3">, </span><span class="s1">shapes=shapes)</span>

  <span class="s0"># Validate singularity points</span>
  <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">arrs </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(</span><span class="s4">&quot;positive_by_0&quot;</span><span class="s3">, </span><span class="s1">(np.ones(</span>
          <span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s1">np.zeros((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)))</span><span class="s3">,</span>
      <span class="s0"># TODO: this fails on CPU, different result</span>
      <span class="s0"># (&quot;positive_by_0_int32&quot;, (np.ones((2,), dtype=np.int32),</span>
      <span class="s0">#                         np.zeros((2,), dtype=np.int32))),</span>
      <span class="s1">(</span><span class="s4">&quot;negative_by_0&quot;</span><span class="s3">, </span><span class="s1">(-np.ones(</span>
          <span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s1">np.zeros((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;0_by_0&quot;</span><span class="s3">, </span><span class="s1">(np.zeros(</span>
          <span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s1">np.zeros((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32)))</span><span class="s3">,</span>
      <span class="s1">(</span><span class="s4">&quot;inf_by_inf&quot;</span><span class="s3">, </span><span class="s1">(np.array([np.inf]</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">,</span>
                      <span class="s1">np.array([np.inf]</span><span class="s3">, </span><span class="s1">dtype=np.float32)))</span><span class="s3">,</span>
  <span class="s1">]:</span>
    <span class="s1">_make_div_rem_harness(prim</span><span class="s3">, </span><span class="s4">f&quot;singularity_</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">arrs=arrs)</span>


<span class="s3">def </span><span class="s1">_make_binary_elementwise_harnesses(prim</span><span class="s3">,</span>
                                       <span class="s1">dtypes</span><span class="s3">,</span>
                                       <span class="s1">default_dtype=np.float32</span><span class="s3">,</span>
                                       <span class="s1">broadcasting_dtypes=</span><span class="s3">None,</span>
                                       <span class="s1">jax_unimplemented=</span><span class="s3">lambda </span><span class="s1">**kwargs: []):</span>

  <span class="s3">def </span><span class="s1">_make(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shapes=((</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">))</span><span class="s3">, </span><span class="s1">dtype):</span>
    <span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape = shapes</span>
    <span class="s1">define(</span>
        <span class="s1">prim</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">prim.bind</span><span class="s3">, </span><span class="s1">[RandArg(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
                    <span class="s1">RandArg(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=jax_unimplemented(</span>
            <span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">prim=prim</span><span class="s3">, </span><span class="s1">shapes=shapes)</span><span class="s3">,</span>
        <span class="s1">prim=prim</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">shapes=shapes)</span>
  <span class="s1">broadcasting_dtypes = broadcasting_dtypes </span><span class="s3">or </span><span class="s1">(default_dtype</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">(</span>
      <span class="s0"># Validate dtypes</span>
      <span class="s1">tuple(_make(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype) </span><span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">dtypes) +</span>
      <span class="s0"># Validate broadcasting</span>
      <span class="s1">tuple(_make(</span><span class="s4">&quot;broadcasting&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shapes=shapes)</span>
            <span class="s3">for </span><span class="s1">shapes </span><span class="s3">in </span><span class="s1">[</span>
              <span class="s1">((</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">20</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcasting rhs</span>
              <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcasting lhs</span>
            <span class="s1">]</span>
            <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">broadcasting_dtypes)</span>
  <span class="s1">)</span>


<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.add_p</span><span class="s3">, </span><span class="s1">dtypes=set(jtu.dtypes.all) - set(jtu.dtypes.boolean))</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.mul_p</span><span class="s3">, </span><span class="s1">dtypes=set(jtu.dtypes.all) - set(jtu.dtypes.boolean))</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.atan2_p</span><span class="s3">, </span><span class="s1">dtypes=jtu.dtypes.all_floating)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.igamma_p</span><span class="s3">, </span><span class="s1">dtypes=jtu.dtypes.all_floating)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.igammac_p</span><span class="s3">, </span><span class="s1">dtypes=jtu.dtypes.all_floating)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.nextafter_p</span><span class="s3">, </span><span class="s1">dtypes=jtu.dtypes.all_floating)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.and_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned +</span>
    <span class="s1">jtu.dtypes.boolean)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.or_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned +</span>
    <span class="s1">jtu.dtypes.boolean)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.xor_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned +</span>
    <span class="s1">jtu.dtypes.boolean)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.shift_left_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.shift_right_logical_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.shift_right_arithmetic_p</span><span class="s3">,</span>
    <span class="s1">default_dtype=np.int32</span><span class="s3">,</span>
    <span class="s1">dtypes=jtu.dtypes.all_integer + jtu.dtypes.all_unsigned)</span>

<span class="s1">_make_binary_elementwise_harnesses(</span>
    <span class="s1">prim=lax.sub_p</span><span class="s3">, </span><span class="s1">dtypes=set(jtu.dtypes.all) - set(jtu.dtypes.boolean))</span>

<span class="s3">for </span><span class="s1">minmax_p </span><span class="s3">in </span><span class="s1">[lax.min_p</span><span class="s3">, </span><span class="s1">lax.max_p]:</span>
  <span class="s1">_make_binary_elementwise_harnesses(</span>
      <span class="s1">prim=minmax_p</span><span class="s3">, </span><span class="s1">dtypes=jtu.dtypes.all</span><span class="s3">,</span>
      <span class="s1">broadcasting_dtypes=(np.float32</span><span class="s3">, </span><span class="s1">np.complex64</span><span class="s3">, </span><span class="s1">np.complex128))</span>
  <span class="s0"># Validate special cases nan/inf/-inf</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating + jtu.dtypes.complex:</span>
    <span class="s1">define(</span>
        <span class="s1">minmax_p</span><span class="s3">,</span>
        <span class="s4">f&quot;inf_nan_</span><span class="s3">{</span><span class="s1">jtu.dtype_str(dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">minmax_p.bind</span><span class="s3">, </span><span class="s1">[np.array([[np.nan</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">np.nan]</span><span class="s3">,</span>
                                  <span class="s1">[np.inf</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">np.inf]</span><span class="s3">,</span>
                                  <span class="s1">[-np.inf</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s1">-np.inf]]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
                        <span class="s1">np.array([[np.nan</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-np.inf]</span><span class="s3">,</span>
                                  <span class="s1">[np.nan</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-np.inf]</span><span class="s3">,</span>
                                  <span class="s1">[np.nan</span><span class="s3">, </span><span class="s1">np.inf</span><span class="s3">, </span><span class="s1">-np.inf]]</span><span class="s3">, </span><span class="s1">dtype=dtype)]</span><span class="s3">,</span>
        <span class="s1">prim=minmax_p</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s3">def </span><span class="s1">_make_broadcast_in_dim_harness(name</span><span class="s3">,</span>
                                   <span class="s1">*</span><span class="s3">,</span>
                                   <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                   <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                   <span class="s1">outshape=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                   <span class="s1">broadcast_dimensions=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.broadcast_in_dim_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">outshape=</span><span class="s3">}</span><span class="s4">_broadcastdimensions=</span><span class="s3">{</span><span class="s1">broadcast_dimensions</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">operand: lax.broadcast_in_dim_p.bind(</span>
          <span class="s1">operand</span><span class="s3">, </span><span class="s1">shape=outshape</span><span class="s3">, </span><span class="s1">broadcast_dimensions=broadcast_dimensions)</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">outshape=outshape</span><span class="s3">,</span>
      <span class="s1">broadcast_dimensions=broadcast_dimensions)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_broadcast_in_dim_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate parameter combinations</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">outshape</span><span class="s3">, </span><span class="s1">broadcast_dimensions </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">[(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># add major dimension</span>
    <span class="s1">[(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># add inner dimension</span>
    <span class="s1">[()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">()]</span><span class="s3">,  </span><span class="s0"># use scalar shape</span>
    <span class="s1">[(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># map size 1 dim to different output dim value</span>
<span class="s1">]:</span>
  <span class="s1">_make_broadcast_in_dim_harness(</span>
      <span class="s4">&quot;parameter_combinations&quot;</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">outshape=outshape</span><span class="s3">,</span>
      <span class="s1">broadcast_dimensions=broadcast_dimensions)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s3">for </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">arg2</span><span class="s3">, </span><span class="s1">arg3 </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(np.array([-</span><span class="s5">1.6</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.4</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.6</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
       <span class="s1">np.array([-</span><span class="s5">1.6</span><span class="s3">, </span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1.4</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.6</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
       <span class="s1">np.array([</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">2.4</span><span class="s3">, </span><span class="s5">1.6</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype))</span>
  <span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.regularized_incomplete_beta_p</span><span class="s3">,</span>
        <span class="s4">f&quot;_</span><span class="s3">{</span><span class="s1">jtu.dtype_str(dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">lax.betainc</span><span class="s3">, </span><span class="s1">[arg1</span><span class="s3">, </span><span class="s1">arg2</span><span class="s3">, </span><span class="s1">arg3]</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s0">## GATHER</span>
<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all):</span>
  <span class="s1">indices = np.array(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span>
  <span class="s1">shape = (</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s1">define(</span>
      <span class="s1">lax.gather_p</span><span class="s3">,</span>
      <span class="s4">f&quot;dtypes_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">_enable_xla=True&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis: jnp.take(a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis=axis)</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">,</span>
       <span class="s1">StaticArg(axis)]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">enable_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Construct gather harnesses using take</span>
<span class="s1">_gather_input = np.arange(</span><span class="s5">1000</span><span class="s3">, </span><span class="s1">dtype=np.float32).reshape((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span>
<span class="s3">for </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">index_oob</span><span class="s3">, </span><span class="s1">indices_name </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s0"># Ensure each set of indices has a distinct name</span>
    <span class="s1">(np.array(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;1&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(np.array([</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;2&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(np.array([</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;3&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(np.array([</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">, False, </span><span class="s4">&quot;3_uint32&quot;</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># uint32 indices</span>
    <span class="s1">(np.array([[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;4&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(np.array([[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">10</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, True, </span><span class="s4">&quot;5_oob&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s0"># Index out of bounds too high</span>
    <span class="s1">(np.array([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;6_neg&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s0"># Negative index is from the end</span>
    <span class="s1">(np.array([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">-</span><span class="s5">10</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, False, </span><span class="s4">&quot;7_neg&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s0"># Index out of bounds, but works</span>
    <span class="s1">(np.array([[[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[-</span><span class="s5">11</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, True, </span><span class="s4">&quot;8_neg_oob&quot;</span><span class="s1">)  </span><span class="s0"># Index out of bounds, too low</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;clip&quot;</span><span class="s3">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">]:</span>
        <span class="s1">define(</span>
            <span class="s1">lax.gather_p</span><span class="s3">,</span>
            <span class="s4">f&quot;from_take_</span><span class="s3">{</span><span class="s1">indices_name=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">mode=</span><span class="s3">!s}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mode: jnp.take(a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">mode=mode)</span><span class="s3">,</span>
            <span class="s1">[_gather_input</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">StaticArg(axis)</span><span class="s3">, </span><span class="s1">StaticArg(mode)]</span><span class="s3">,</span>
            <span class="s1">dtype=_gather_input.dtype</span><span class="s3">,</span>
            <span class="s1">enable_xla=enable_xla</span><span class="s3">,</span>
            <span class="s1">index_oob=index_oob</span><span class="s3">,</span>
            <span class="s1">mode=mode)</span>

<span class="s0"># Construct gather harnesses using array indexing and slicing.</span>
<span class="s3">for </span><span class="s1">slices</span><span class="s3">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;[0]&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;[0,1]&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s1">))</span><span class="s3">, </span><span class="s4">&quot;[:,:2,:]&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((slice(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;[2:5,5]&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">5</span><span class="s3">, </span><span class="s1">-</span><span class="s5">200</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;[-1,-5,-200]&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((slice(</span><span class="s5">5</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s5">300</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;[5:-2,300]&quot;</span><span class="s1">)</span><span class="s3">,</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.gather_p</span><span class="s3">,</span>
        <span class="s4">f&quot;from_slicing_</span><span class="s3">{</span><span class="s1">name=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">*s: jnp.array(arr).__getitem__(*s)</span><span class="s3">,</span>
        <span class="s1">[_gather_input</span><span class="s3">, </span><span class="s1">StaticArg(slices)]</span><span class="s3">,</span>
        <span class="s1">dtype=_gather_input.dtype</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>

<span class="s0"># Directly from lax.gather in lax_test.py.</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dnums</span><span class="s3">, </span><span class="s1">slice_sizes</span><span class="s3">, </span><span class="s1">needs_xla </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]])</span><span class="s3">,</span>
     <span class="s1">lax.GatherDimensionNumbers(</span>
         <span class="s1">offset_dims=()</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]])</span><span class="s3">,</span>
     <span class="s1">lax.GatherDimensionNumbers(</span>
         <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=()</span><span class="s3">,</span>
         <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]])</span><span class="s3">,</span>
     <span class="s1">lax.GatherDimensionNumbers(</span>
         <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.array([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]])</span><span class="s3">,</span>
     <span class="s1">lax.GatherDimensionNumbers(</span>
         <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,</span>
<span class="s1">]:</span>
  <span class="s1">dtype = np.float32</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">([</span><span class="s3">True</span><span class="s1">] </span><span class="s3">if </span><span class="s1">needs_xla </span><span class="s3">else </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]):</span>
    <span class="s1">define(</span>
        <span class="s1">lax.gather_p</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">shape=</span><span class="s3">}</span><span class="s4">_idxs_shape=</span><span class="s3">{</span><span class="s1">idxs.shape</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dnums=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">slice_sizes=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dnums</span><span class="s3">, </span><span class="s1">slice_sizes: lax.gather(</span>
            <span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dimension_numbers=dnums</span><span class="s3">, </span><span class="s1">slice_sizes=slice_sizes)</span><span class="s3">,</span>
        <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">,</span>
         <span class="s1">StaticArg(dnums)</span><span class="s3">,</span>
         <span class="s1">StaticArg(slice_sizes)]</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s0"># Test cases lax.gather with non-empty batch_dims. This is for instance</span>
<span class="s0"># triggered when executing `jax.vmap(lax.dynamic_slice)`.</span>
<span class="s0"># We currently only support the case where we have a single batch dimension.</span>
<span class="s1">dnums_2d = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># Batch dimension.</span>
    <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
<span class="s1">dnums_2d_2 = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=()</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># Only first dim is batch, collapse both.</span>
    <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
<span class="s1">dnums_3d = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># Batch dimension.</span>
    <span class="s1">start_index_map=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>

<span class="s3">for </span><span class="s1">op_shape</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">, </span><span class="s1">slice_sizes</span><span class="s3">, </span><span class="s1">dnums </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">dnums_2d)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,                            </span><span class="s1">dnums_2d_2)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s3">,           </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dnums_3d)</span><span class="s3">,</span>
    <span class="s0"># Test out of bounds behavior.</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,   </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">8</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s3">,         </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">dnums_2d)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">,           </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dnums_3d)]:</span>
  <span class="s1">start_indices = np.array(start_indices)</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.gather_p</span><span class="s3">,</span>
        <span class="s4">f&quot;batchdims_shape=</span><span class="s3">{</span><span class="s1">op_shape</span><span class="s3">}</span><span class="s4">_start_indices_shape=</span><span class="s3">{</span><span class="s1">start_indices.shape</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">slice_sizes=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dnums</span><span class="s3">, </span><span class="s1">slice_sizes: lax.gather(</span>
                  <span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dimension_numbers=dnums</span><span class="s3">, </span><span class="s1">slice_sizes=slice_sizes)</span><span class="s3">,</span>
        <span class="s1">[RandArg(op_shape</span><span class="s3">, </span><span class="s1">np.float32)</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">,</span>
        <span class="s1">StaticArg(dnums)</span><span class="s3">,</span>
        <span class="s1">StaticArg(slice_sizes)]</span><span class="s3">,</span>
        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s0"># Test cases lax.gather with non-empty 2D batch_dims. This is for instance</span>
<span class="s0"># triggered when executing `jax.vmap(jax.vmap(lax.dynamic_slice))`.</span>
<span class="s1">gather_2d_bd = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=()</span><span class="s3">, </span><span class="s1">start_index_map=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">gather_2d_bd_nid = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=()</span><span class="s3">, </span><span class="s1">start_index_map=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">gather_3d_bd = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=()</span><span class="s3">, </span><span class="s1">start_index_map=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s1">gather_2d_bd2 = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">collapsed_slice_dims=()</span><span class="s3">, </span><span class="s1">start_index_map=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
<span class="s1">)</span>

<span class="s3">for </span><span class="s1">op_shape</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">, </span><span class="s1">slice_sizes</span><span class="s3">, </span><span class="s1">dnums </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">gather_2d_bd</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># non-contigous 2d batch dims</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">gather_2d_bd</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># negative indices</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2147483647</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">gather_2d_bd</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># oob indices</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">gather_2d_bd_nid</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># start_index_map not identity</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">gather_2d_bd</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># oob behavior coming from slice_sizes</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">,</span><span class="s5">10</span><span class="s3">,</span><span class="s5">10</span><span class="s3">,</span><span class="s5">10</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">[[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span><span class="s5">0</span><span class="s1">]]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">,</span><span class="s5">2</span><span class="s3">,</span><span class="s5">2</span><span class="s3">,</span><span class="s5">2</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">gather_3d_bd)</span><span class="s3">,  </span><span class="s0"># test 3d batch dims</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">,</span><span class="s5">10</span><span class="s3">,</span><span class="s5">10</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">,</span><span class="s5">2</span><span class="s3">,</span><span class="s5">2</span><span class="s1">)</span><span class="s3">,    </span><span class="s1">gather_2d_bd2)</span><span class="s3">,  </span><span class="s0"># test contiguous 2d batch dims</span>
<span class="s1">]:</span>
  <span class="s1">start_indices = np.array(start_indices)</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s4">&quot;gather&quot;</span><span class="s3">,</span>
        <span class="s4">f&quot;op_shape=</span><span class="s3">{</span><span class="s1">op_shape</span><span class="s3">}</span><span class="s4">_offset_dims=</span><span class="s3">{</span><span class="s1">dnums.offset_dims</span><span class="s3">}</span><span class="s4">_start_index_map=</span><span class="s3">{</span><span class="s1">dnums.start_index_map</span><span class="s3">}</span><span class="s4">_start_indices_shape=</span><span class="s3">{</span><span class="s1">start_indices.shape</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">slice_sizes=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dnums</span><span class="s3">, </span><span class="s1">slice_sizes: lax.gather(</span>
            <span class="s1">op</span><span class="s3">, </span><span class="s1">idxs</span><span class="s3">, </span><span class="s1">dimension_numbers=dnums</span><span class="s3">, </span><span class="s1">slice_sizes=slice_sizes</span>
        <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">[</span>
            <span class="s1">RandArg(op_shape</span><span class="s3">, </span><span class="s1">np.float32)</span><span class="s3">,</span>
            <span class="s1">start_indices</span><span class="s3">,</span>
            <span class="s1">StaticArg(dnums)</span><span class="s3">,</span>
            <span class="s1">StaticArg(slice_sizes)</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla</span><span class="s3">,</span>
    <span class="s1">)</span>

<span class="s3">def </span><span class="s1">_make_scatter_harness(name</span><span class="s3">,</span>
                          <span class="s1">*</span><span class="s3">,</span>
                          <span class="s1">shape=(</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">f_lax=lax.scatter_min</span><span class="s3">,</span>
                          <span class="s1">indices_are_sorted=</span><span class="s3">False,</span>
                          <span class="s1">unique_indices=</span><span class="s3">False,</span>
                          <span class="s1">scatter_indices=np.array([[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]])</span><span class="s3">,</span>
                          <span class="s1">update_shape=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">mode=lax.GatherScatterMode.FILL_OR_DROP</span><span class="s3">,</span>
                          <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                          <span class="s1">dimension_numbers=(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
                          <span class="s1">enable_and_disable_xla=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">dimension_numbers = lax.ScatterDimensionNumbers(*dimension_numbers)</span>
  <span class="s1">xla_options = [</span><span class="s3">True, False</span><span class="s1">] </span><span class="s3">if </span><span class="s1">enable_and_disable_xla </span><span class="s3">else </span><span class="s1">[</span><span class="s3">True</span><span class="s1">]</span>

  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">xla_options:</span>
    <span class="s1">define(</span>
        <span class="s1">f_lax.__name__</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_scatterindices=</span><span class="s3">{</span><span class="s1">scatter_indices.tolist()</span><span class="s3">}</span><span class="s4">_updateshape=</span><span class="s3">{</span><span class="s1">update_shape</span><span class="s3">}</span><span class="s4">_updatewindowdims=</span><span class="s3">{</span><span class="s1">dimension_numbers.update_window_dims</span><span class="s3">}</span><span class="s4">_insertedwindowdims=</span><span class="s3">{</span><span class="s1">dimension_numbers.inserted_window_dims</span><span class="s3">}</span><span class="s4">_scatterdimstooperanddims=</span><span class="s3">{</span><span class="s1">dimension_numbers.scatter_dims_to_operand_dims</span><span class="s3">}</span><span class="s4">_indicesaresorted=</span><span class="s3">{</span><span class="s1">indices_are_sorted</span><span class="s3">}</span><span class="s4">_uniqueindices=</span><span class="s3">{</span><span class="s1">unique_indices</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">mode=</span><span class="s3">!s}</span><span class="s4">_enablexla=</span><span class="s3">{</span><span class="s1">enable_xla</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">partial(</span>
            <span class="s1">f_lax</span><span class="s3">,</span>
            <span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s3">,</span>
            <span class="s1">unique_indices=unique_indices</span><span class="s3">,</span>
            <span class="s1">mode=mode)</span><span class="s3">, </span><span class="s1">[</span>
                <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
                <span class="s1">StaticArg(scatter_indices)</span><span class="s3">,</span>
                <span class="s1">RandArg(update_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
                <span class="s1">StaticArg(dimension_numbers)</span>
            <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=[</span>
            <span class="s1">Limitation(</span>
                <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
                <span class="s1">dtypes=[np.bool_]</span><span class="s3">,</span>
                <span class="s1">enabled=(f_lax </span><span class="s3">in </span><span class="s1">[lax.scatter_add</span><span class="s3">, </span><span class="s1">lax.scatter_mul]))</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">f_lax=f_lax</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">scatter_indices=scatter_indices</span><span class="s3">,</span>
        <span class="s1">update_shape=update_shape</span><span class="s3">,</span>
        <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
        <span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s3">,</span>
        <span class="s1">unique_indices=unique_indices</span><span class="s3">,</span>
        <span class="s1">mode=mode</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s3">for </span><span class="s1">f_lax </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">lax.scatter</span><span class="s3">, </span><span class="s1">lax.scatter_add</span><span class="s3">, </span><span class="s1">lax.scatter_mul</span><span class="s3">, </span><span class="s1">lax.scatter_max</span><span class="s3">, </span><span class="s1">lax.scatter_min</span>
  <span class="s1">]:</span>
    <span class="s1">_make_scatter_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">f_lax=f_lax)</span>

<span class="s0"># Validate f_lax/update_jaxpr</span>
<span class="s0"># We explicitly decide against testing lax.scatter, as its reduction function</span>
<span class="s0"># is lambda x, y: y, which is not commutative and thus makes results</span>
<span class="s0"># non-deterministic when an index into the operand is updated several times.</span>

<span class="s0"># Validate shapes, dimension numbers and scatter indices. All are in bounds.</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">scatter_indices</span><span class="s3">, </span><span class="s1">update_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span>
<span class="s1">]:</span>
  <span class="s1">_make_scatter_harness(</span>
      <span class="s4">&quot;shapes_and_dimension_numbers&quot;</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">update_shape=update_shape</span><span class="s3">,</span>
      <span class="s1">scatter_indices=np.array(scatter_indices)</span><span class="s3">,</span>
      <span class="s1">dimension_numbers=dimension_numbers)</span>

<span class="s0"># Validate sorted indices</span>
<span class="s1">_make_scatter_harness(</span><span class="s4">&quot;indices_are_sorted&quot;</span><span class="s3">, </span><span class="s1">indices_are_sorted=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s0"># Validate unique_indices</span>
<span class="s0"># `unique_indices` does not affect correctness, only performance, and thus</span>
<span class="s0"># does not need to be tested here. If/when it will make sense to add a test</span>
<span class="s0"># with `unique_indices` = True, particular care will have to be taken with</span>
<span class="s0"># regards to the choice of parameters, as the results are only predictable</span>
<span class="s0"># when all the indices to be updated are pairwise non-overlapping. Identifying</span>
<span class="s0"># such cases is non-trivial.</span>
<span class="s0"># _make_scatter_harness(&quot;unique_indices&quot;, unique_indices=False)</span>

<span class="s0"># Validate different out-of-bounds modes</span>
<span class="s3">for </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(lax.GatherScatterMode.PROMISE_IN_BOUNDS</span><span class="s3">,</span>
             <span class="s1">lax.GatherScatterMode.FILL_OR_DROP):</span>
  <span class="s3">for </span><span class="s1">f_lax </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">lax.scatter_add</span><span class="s3">, </span><span class="s1">lax.scatter_mul</span><span class="s3">, </span><span class="s1">lax.scatter_max</span><span class="s3">, </span><span class="s1">lax.scatter_min</span><span class="s3">, </span><span class="s1">lax.scatter</span>
  <span class="s1">]:</span>
    <span class="s1">_make_scatter_harness(</span><span class="s4">&quot;modes_in_bounds&quot;</span><span class="s3">,</span>
                          <span class="s1">f_lax=f_lax</span><span class="s3">,</span>
                          <span class="s1">mode=mode)</span>
    <span class="s1">_make_scatter_harness(</span><span class="s4">&quot;modes_out_of_bounds&quot;</span><span class="s3">, </span><span class="s1">mode=mode</span><span class="s3">,</span>
                          <span class="s1">shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">f_lax=f_lax</span><span class="s3">,</span>
                          <span class="s1">scatter_indices=np.array([</span><span class="s5">10</span><span class="s1">])</span><span class="s3">,</span>
                          <span class="s1">update_shape=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dimension_numbers=((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
                          <span class="s1">enable_and_disable_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate no XLA scatters</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.complex) - set(jtu.dtypes.boolean):</span>
  <span class="s3">for </span><span class="s1">f_lax </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">lax.scatter_add</span><span class="s3">, </span><span class="s1">lax.scatter_mul</span><span class="s3">, </span><span class="s1">lax.scatter_max</span><span class="s3">, </span><span class="s1">lax.scatter_min</span><span class="s3">, </span><span class="s1">lax.scatter</span>
  <span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">scatter_indices</span><span class="s3">, </span><span class="s1">update_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># zero case</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">50</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">32</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># slice 2nd dim</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># slice 1st dim</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># 2nd and 3rd</span>
        <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># 1st and 3rd</span>
        <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># 2nd and 4th</span>
        <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># .at[((3,4),(5,5))] shapes</span>
        <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">3</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># .at[:, ((3,4),(5,5))] shapes</span>
        <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
         <span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># .at[:, ((3,4),(5,5)), 3] shapes</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">125</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
    <span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(lax.GatherScatterMode.PROMISE_IN_BOUNDS</span><span class="s3">,</span>
                   <span class="s1">lax.GatherScatterMode.FILL_OR_DROP):</span>
        <span class="s1">_make_scatter_harness(</span>
            <span class="s4">&quot;no_xla_unique_indices&quot;</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">f_lax=f_lax</span><span class="s3">,</span>
            <span class="s1">unique_indices=</span><span class="s3">True,</span>
            <span class="s1">scatter_indices=np.array(scatter_indices)</span><span class="s3">,</span>
            <span class="s1">update_shape=update_shape</span><span class="s3">,</span>
            <span class="s1">mode=mode</span><span class="s3">,</span>
            <span class="s1">dtype=dtype</span><span class="s3">,</span>
            <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
            <span class="s1">enable_and_disable_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate no XLA scatters with non-unique indices with an indexing depth of 1.</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.complex) - set(jtu.dtypes.boolean):</span>
  <span class="s0"># Note that lax.scatter currently does not work here.</span>
  <span class="s3">for </span><span class="s1">f_lax </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">lax.scatter_add</span><span class="s3">, </span><span class="s1">lax.scatter_mul</span><span class="s3">, </span><span class="s1">lax.scatter_max</span><span class="s3">, </span><span class="s1">lax.scatter_min</span>
  <span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">scatter_indices</span><span class="s3">, </span><span class="s1">update_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># .at[((0,0),)]</span>
        <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># .at[((1,0,1),)]</span>
        <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">2</span><span class="s1">]]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,  </span><span class="s0"># 2nd dim, .at[:, ((2,2,2),)]</span>
        <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">40</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
        <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">[</span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)))</span><span class="s3">,</span>
    <span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(lax.GatherScatterMode.PROMISE_IN_BOUNDS</span><span class="s3">,</span>
                   <span class="s1">lax.GatherScatterMode.FILL_OR_DROP):</span>
        <span class="s1">_make_scatter_harness(</span>
            <span class="s4">&quot;no_xla_non_unique_indices&quot;</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">f_lax=f_lax</span><span class="s3">,</span>
            <span class="s1">unique_indices=</span><span class="s3">False,</span>
            <span class="s1">scatter_indices=np.array(scatter_indices)</span><span class="s3">,</span>
            <span class="s1">update_shape=update_shape</span><span class="s3">,</span>
            <span class="s1">mode=mode</span><span class="s3">,</span>
            <span class="s1">dtype=dtype</span><span class="s3">,</span>
            <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
            <span class="s1">enable_and_disable_xla=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">arg_shape = (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>
  <span class="s3">for </span><span class="s1">pads </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># no padding</span>
      <span class="s1">[(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># only positive edge padding</span>
      <span class="s1">[(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># edge padding and interior padding</span>
      <span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># negative padding</span>
      <span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># add big dilation then remove from edges</span>
      <span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># remove everything in one dimension</span>
  <span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
      <span class="s1">define(</span>
        <span class="s1">lax.pad_p</span><span class="s3">,</span>
        <span class="s4">f&quot;inshape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(arg_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">pads=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">lax.pad</span><span class="s3">,</span>
        <span class="s1">[RandArg(arg_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
         <span class="s1">np.array(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
         <span class="s1">StaticArg(pads)]</span><span class="s3">,</span>
        <span class="s1">rng_factory=jtu.rand_small</span><span class="s3">,</span>
        <span class="s1">arg_shape=arg_shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">pads=pads</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s3">def </span><span class="s1">_make_select_n_harness(name</span><span class="s3">,</span>
                         <span class="s1">*</span><span class="s3">,</span>
                         <span class="s1">shape_pred=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">shape_args=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.select_n_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shapepred=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape_pred</span><span class="s3">, </span><span class="s1">np.bool_)</span><span class="s3">}</span><span class="s4">_shapeargs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.select_n</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">RandArg(shape_pred</span><span class="s3">, </span><span class="s1">np.bool_)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape_pred=shape_pred</span><span class="s3">,</span>
      <span class="s1">shape_args=shape_args</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>
  <span class="s1">define(</span>
      <span class="s1">lax.select_n_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shapepred=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape_pred</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">}</span><span class="s4">_shapeargs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.select_n</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">CustomArg(</span><span class="s3">lambda </span><span class="s1">rng: jtu.rand_int(rng</span><span class="s3">, </span><span class="s1">high=</span><span class="s5">3</span><span class="s1">)(shape_args</span><span class="s3">, </span><span class="s1">np.int32))</span><span class="s3">,</span>
          <span class="s1">RandArg(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape_args</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape_pred=shape_pred</span><span class="s3">,</span>
      <span class="s1">shape_args=shape_args</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_select_n_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate shapes</span>
<span class="s1">_make_select_n_harness(</span><span class="s4">&quot;shapes&quot;</span><span class="s3">, </span><span class="s1">shape_pred=()</span><span class="s3">, </span><span class="s1">shape_args=(</span><span class="s5">18</span><span class="s3">,</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">_make_transpose_harness(name</span><span class="s3">,</span>
                            <span class="s1">*</span><span class="s3">,</span>
                            <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">permutation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.transpose_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">permutation=</span><span class="s3">}</span><span class="s4">&quot;</span>
      <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">x: lax.transpose_p.bind(x</span><span class="s3">, </span><span class="s1">permutation=permutation)</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">permutation=permutation)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_transpose_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate permutations</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">permutation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># identity</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># transposition</span>
<span class="s1">]:</span>
  <span class="s1">_make_transpose_harness(</span><span class="s4">&quot;permutations&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">permutation=permutation)</span>


<span class="s0">## CUMREDUCE</span>
<span class="s3">def </span><span class="s1">_make_cumreduce_harness(name</span><span class="s3">,</span>
                            <span class="s1">*</span><span class="s3">,</span>
                            <span class="s1">f_jax=lax_control_flow.cummin</span><span class="s3">,</span>
                            <span class="s1">shape=(</span><span class="s5">8</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                            <span class="s1">axis=</span><span class="s5">0</span><span class="s3">,</span>
                            <span class="s1">reverse=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">limitations = []</span>
  <span class="s1">define(</span>
      <span class="s1">f_jax.__name__</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">reverse=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">f_jax</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
              <span class="s1">StaticArg(axis)</span><span class="s3">,</span>
              <span class="s1">StaticArg(reverse)]</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=limitations</span><span class="s3">,</span>
      <span class="s1">f_jax=f_jax</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">axis=axis</span><span class="s3">,</span>
      <span class="s1">reverse=reverse</span><span class="s3">,</span>
      <span class="s1">associative_scan_reductions=</span><span class="s3">False</span>
  <span class="s1">)</span>
  <span class="s1">define(</span>
      <span class="s1">f_jax.__name__</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_associative_scan_reductions_</span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">reverse=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">f_jax</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
              <span class="s1">StaticArg(axis)</span><span class="s3">,</span>
              <span class="s1">StaticArg(reverse)]</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=limitations</span><span class="s3">,</span>
      <span class="s1">f_jax=f_jax</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">axis=axis</span><span class="s3">,</span>
      <span class="s1">reverse=reverse</span><span class="s3">,</span>
      <span class="s1">associative_scan_reductions=</span><span class="s3">True</span>
  <span class="s1">)</span>

<span class="s0"># Validate dtypes for each function</span>
<span class="s3">for </span><span class="s1">f_jax </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">lax_control_flow.cummin</span><span class="s3">,</span>
    <span class="s1">lax_control_flow.cummax</span><span class="s3">,</span>
    <span class="s1">lax_control_flow.cumlogsumexp</span><span class="s3">,</span>
    <span class="s1">lax_control_flow.cumsum</span><span class="s3">,</span>
    <span class="s1">lax_control_flow.cumprod</span><span class="s3">,</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
    <span class="s0"># cumlogsumexp is only defined for floating point types.</span>
    <span class="s3">if </span><span class="s1">(f_jax == lax_control_flow.cumlogsumexp </span><span class="s3">and</span>
        <span class="s3">not </span><span class="s1">np.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating)):</span>
      <span class="s3">continue</span>
    <span class="s3">if </span><span class="s1">dtype == np.bool_:</span>
      <span class="s3">continue</span>
    <span class="s1">_make_cumreduce_harness(</span><span class="s4">&quot;dtype_by_fun&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">f_jax=f_jax)</span>

  <span class="s0"># Validate axis for each function</span>
  <span class="s1">shape = (</span><span class="s5">8</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span>
  <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">range(len(shape)):</span>
    <span class="s1">_make_cumreduce_harness(</span><span class="s4">&quot;axis_by_fun&quot;</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">f_jax=f_jax</span><span class="s3">, </span><span class="s1">shape=shape)</span>

  <span class="s0"># Validate reverse for each function</span>
  <span class="s1">_make_cumreduce_harness(</span><span class="s4">&quot;reverse&quot;</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True, </span><span class="s1">f_jax=f_jax)</span>


<span class="s0">### TOP_K</span>
<span class="s3">def </span><span class="s1">_make_top_k_harness(name</span><span class="s3">,</span>
                        <span class="s1">*</span><span class="s3">,</span>
                        <span class="s1">operand=</span><span class="s3">None,</span>
                        <span class="s1">shape=(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                        <span class="s1">k=</span><span class="s5">2</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">operand </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">operand = RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">define(</span>
      <span class="s1">lax.top_k_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_inshape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(operand.shape</span><span class="s3">, </span><span class="s1">operand.dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">k=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.top_k</span><span class="s3">, </span><span class="s1">[operand</span><span class="s3">, </span><span class="s1">StaticArg(k)]</span><span class="s3">,</span>
      <span class="s1">shape=operand.shape</span><span class="s3">,</span>
      <span class="s1">dtype=operand.dtype</span><span class="s3">,</span>
      <span class="s1">k=k)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - set(jtu.dtypes.complex):</span>
  <span class="s0"># Validate dtypes</span>
  <span class="s1">_make_top_k_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate implicit properties of the sort</span>
<span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">operand</span><span class="s3">, </span><span class="s1">k </span><span class="s3">in </span><span class="s1">[(</span><span class="s4">&quot;stability&quot;</span><span class="s3">,</span>
                          <span class="s1">np.array([</span><span class="s5">5</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">5</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">(</span><span class="s4">&quot;sort_inf_nan&quot;</span><span class="s3">,</span>
                          <span class="s1">np.array([+np.inf</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">-np.nan</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]</span><span class="s3">,</span>
                                   <span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)]:</span>
  <span class="s1">_make_top_k_harness(name</span><span class="s3">, </span><span class="s1">operand=operand</span><span class="s3">, </span><span class="s1">k=k)</span>


<span class="s0">### SORT</span>
<span class="s3">def </span><span class="s1">_make_sort_harness(name</span><span class="s3">,</span>
                       <span class="s1">*</span><span class="s3">,</span>
                       <span class="s1">operands=</span><span class="s3">None,</span>
                       <span class="s1">shape=(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                       <span class="s1">dimension=</span><span class="s5">0</span><span class="s3">,</span>
                       <span class="s1">is_stable=</span><span class="s3">False,</span>
                       <span class="s1">num_keys=</span><span class="s5">1</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">operands </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">operands = [RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span>
  <span class="s1">define(</span>
      <span class="s1">lax.sort_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_num_arrays=</span><span class="s3">{</span><span class="s1">len(operands)</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(operands[</span><span class="s5">0</span><span class="s1">].shape</span><span class="s3">, </span><span class="s1">operands[</span><span class="s5">0</span><span class="s1">].dtype)</span><span class="s3">}</span><span class="s4">_axis=</span><span class="s3">{</span><span class="s1">dimension</span><span class="s3">}</span><span class="s4">_isstable=</span><span class="s3">{</span><span class="s1">is_stable</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">num_keys=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">*args: lax.sort_p.bind(</span>
          <span class="s1">*args[:-</span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dimension=args[-</span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">is_stable=args[-</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">num_keys=args[-</span><span class="s5">1</span><span class="s1">]</span>
      <span class="s1">)</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">*operands</span><span class="s3">,</span>
          <span class="s1">StaticArg(dimension)</span><span class="s3">,</span>
          <span class="s1">StaticArg(is_stable)</span><span class="s3">,</span>
          <span class="s1">StaticArg(num_keys)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape=operands[</span><span class="s5">0</span><span class="s1">].shape</span><span class="s3">,</span>
      <span class="s1">dimension=dimension</span><span class="s3">,</span>
      <span class="s1">dtype=operands[</span><span class="s5">0</span><span class="s1">].dtype</span><span class="s3">,</span>
      <span class="s1">is_stable=is_stable</span><span class="s3">,</span>
      <span class="s1">num_keys=num_keys</span><span class="s3">,</span>
      <span class="s1">num_arrays=len(operands))</span>


<span class="s1">_lax_sort_multiple_array_shape = (</span><span class="s5">100</span><span class="s3">,</span><span class="s1">)</span>
<span class="s0"># In order to test lexicographic ordering and sorting stability, the first</span>
<span class="s0"># array contains only integers 0 and 1</span>
<span class="s1">_lax_sort_multiple_array_first_arg = (</span>
    <span class="s1">np.random.uniform(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">_lax_sort_multiple_array_shape).astype(np.int32))</span>

<span class="s0"># Validate dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_sort_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate dimensions</span>
<span class="s3">for </span><span class="s1">dimension </span><span class="s3">in </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]:</span>
  <span class="s1">_make_sort_harness(</span><span class="s4">&quot;dimensions&quot;</span><span class="s3">, </span><span class="s1">dimension=dimension)</span>
<span class="s0"># Validate stable sort</span>
<span class="s1">_make_sort_harness(</span><span class="s4">&quot;is_stable&quot;</span><span class="s3">, </span><span class="s1">is_stable=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s0"># Potential edge cases</span>
<span class="s3">for </span><span class="s1">operands</span><span class="s3">, </span><span class="s1">dimension </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">([np.array([+np.inf</span><span class="s3">, </span><span class="s1">np.nan</span><span class="s3">, </span><span class="s1">-np.nan</span><span class="s3">, </span><span class="s1">-np.inf</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.float32)]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">]:</span>
  <span class="s1">_make_sort_harness(</span><span class="s4">&quot;edge_cases&quot;</span><span class="s3">, </span><span class="s1">operands=operands</span><span class="s3">, </span><span class="s1">dimension=dimension)</span>

<span class="s0"># Validate multiple arrays, num_keys, and is_stable</span>
<span class="s3">for </span><span class="s1">is_stable </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">operands </span><span class="s3">in </span><span class="s1">(</span>
      <span class="s1">[</span>
          <span class="s1">_lax_sort_multiple_array_first_arg</span><span class="s3">,</span>
          <span class="s1">RandArg(_lax_sort_multiple_array_shape</span><span class="s3">, </span><span class="s1">np.int32)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">[</span>
          <span class="s1">_lax_sort_multiple_array_first_arg</span><span class="s3">,</span>
          <span class="s1">RandArg(_lax_sort_multiple_array_shape</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">,</span>
          <span class="s1">RandArg(_lax_sort_multiple_array_shape</span><span class="s3">, </span><span class="s1">np.float32)</span>
      <span class="s1">]</span><span class="s3">,</span>
  <span class="s1">):</span>
    <span class="s3">for </span><span class="s1">num_keys </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len(operands) + </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s1">_make_sort_harness(</span>
          <span class="s4">&quot;multiple_arrays&quot;</span><span class="s3">,</span>
          <span class="s1">operands=operands</span><span class="s3">,</span>
          <span class="s1">num_keys=num_keys</span><span class="s3">,</span>
          <span class="s1">is_stable=is_stable</span><span class="s3">,</span>
          <span class="s1">shape=_lax_sort_multiple_array_first_arg.shape</span><span class="s3">,</span>
          <span class="s1">dtype=_lax_sort_multiple_array_first_arg.dtype)</span>


<span class="s3">def </span><span class="s1">_make_cholesky_arg(shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">rng):</span>
  <span class="s1">a = jtu.rand_default(rng)(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">return </span><span class="s1">np.matmul(a</span><span class="s3">, </span><span class="s1">jnp.conj(np.swapaxes(a</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)))</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">200</span><span class="s3">, </span><span class="s5">200</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1000</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.linalg.cholesky_p</span><span class="s3">,</span>
        <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">*args: lax.linalg.cholesky_p.bind(*args)</span><span class="s3">,</span>
        <span class="s1">[CustomArg(partial(_make_cholesky_arg</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype))]</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=[</span>
            <span class="s1">Limitation(</span>
                <span class="s4">&quot;unimplemented&quot;</span><span class="s3">, </span><span class="s1">dtypes=[np.float16]</span><span class="s3">, </span><span class="s1">devices=(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s1">))</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating + jtu.dtypes.complex:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">200</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)]:</span>
    <span class="s3">for </span><span class="s1">full_matrices </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
      <span class="s1">define(</span>
          <span class="s1">lax.linalg.qr_p</span><span class="s3">,</span>
          <span class="s4">f&quot;multi_array_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_fullmatrices=</span><span class="s3">{</span><span class="s1">full_matrices</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
          <span class="s1">partial(lax.linalg.qr</span><span class="s3">, </span><span class="s1">full_matrices=full_matrices)</span><span class="s3">,</span>
          <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
          <span class="s0"># See jax._src.lib.lapack.geqrf for the list of compatible types</span>
          <span class="s1">jax_unimplemented=[</span>
              <span class="s1">Limitation(</span>
                  <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
                  <span class="s1">devices=(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s1">)</span><span class="s3">,</span>
                  <span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16])</span><span class="s3">,</span>
          <span class="s1">]</span><span class="s3">,</span>
          <span class="s1">shape=shape</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">full_matrices=full_matrices)</span>


<span class="s3">def </span><span class="s1">_make_fft_harness(name</span><span class="s3">,</span>
                      <span class="s1">*</span><span class="s3">,</span>
                      <span class="s1">shape=(</span><span class="s5">14</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">17</span><span class="s1">)</span><span class="s3">,</span>
                      <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                      <span class="s1">fft_type=xla_client.FftType.FFT</span><span class="s3">,</span>
                      <span class="s1">fft_lengths=(</span><span class="s5">17</span><span class="s3">,</span><span class="s1">)):</span>

  <span class="s3">def </span><span class="s1">_fft_rng_factory(dtype):</span>
    <span class="s1">_all_integers = (</span>
        <span class="s1">jtu.dtypes.all_integer + jtu.dtypes.all_unsigned + jtu.dtypes.boolean)</span>
    <span class="s0"># For integer types, use small values to keep the errors small</span>
    <span class="s3">if </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">_all_integers:</span>
      <span class="s3">return </span><span class="s1">jtu.rand_small</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">jtu.rand_default</span>

  <span class="s1">define(</span>
      <span class="s1">lax.fft_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_ffttype=</span><span class="s3">{</span><span class="s1">fft_type</span><span class="s3">}</span><span class="s4">_fftlengths=</span><span class="s3">{</span><span class="s1">fft_lengths</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">*args: lax.fft_p.bind(</span>
          <span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fft_type=args[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fft_lengths=args[</span><span class="s5">2</span><span class="s1">])</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
       <span class="s1">StaticArg(fft_type)</span><span class="s3">,</span>
       <span class="s1">StaticArg(fft_lengths)]</span><span class="s3">,</span>
      <span class="s1">rng_factory=_fft_rng_factory(dtype)</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">fft_type=fft_type</span><span class="s3">,</span>
      <span class="s1">fft_lengths=fft_lengths)</span>


<span class="s0"># FFT, IFFT, RFFT, IRFFT</span>
<span class="s3">for </span><span class="s1">fft_type </span><span class="s3">in </span><span class="s1">list(map(xla_client.FftType</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">])):</span>
  <span class="s0"># Validate dtypes per FFT type</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">(jtu.dtypes.floating</span>
                <span class="s3">if </span><span class="s1">fft_type == xla_client.FftType.RFFT </span><span class="s3">else </span><span class="s1">jtu.dtypes.complex):</span>
    <span class="s1">shape = (</span><span class="s5">14</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">17</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">fft_lengths </span><span class="s3">in </span><span class="s1">[</span>
        <span class="s1">(shape[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">fft_type != xla_client.FftType.IRFFT </span><span class="s3">else</span>
        <span class="s1">((shape[-</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">]:</span>
      <span class="s1">_make_fft_harness(</span>
          <span class="s4">&quot;dtypes&quot;</span><span class="s3">,</span>
          <span class="s1">shape=shape</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">fft_type=fft_type</span><span class="s3">,</span>
          <span class="s1">fft_lengths=fft_lengths)</span>

  <span class="s0"># Validate dimensions per FFT type</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">np.float32 </span><span class="s3">if </span><span class="s1">fft_type == xla_client.FftType.RFFT </span><span class="s3">else </span><span class="s1">np.complex64</span>
  <span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">dims </span><span class="s3">in </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">fft_lengths </span><span class="s3">in </span><span class="s1">[</span>
          <span class="s1">shape[-dims:] </span><span class="s3">if </span><span class="s1">fft_type != xla_client.FftType.IRFFT </span><span class="s3">else</span>
          <span class="s1">shape[-dims:-</span><span class="s5">1</span><span class="s1">] + ((shape[-</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span>
      <span class="s1">]:</span>
        <span class="s1">_make_fft_harness(</span>
            <span class="s4">&quot;dims&quot;</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">fft_type=fft_type</span><span class="s3">,</span>
            <span class="s1">fft_lengths=fft_lengths</span><span class="s3">,</span>
            <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating + jtu.dtypes.complex:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">29</span><span class="s3">, </span><span class="s5">29</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">53</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">29</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)]:</span>
    <span class="s3">for </span><span class="s1">full_matrices </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">compute_uv </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
        <span class="s1">define(</span>
            <span class="s1">lax.linalg.svd_p</span><span class="s3">,</span>
            <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_fullmatrices=</span><span class="s3">{</span><span class="s1">full_matrices</span><span class="s3">}</span><span class="s4">_computeuv=</span><span class="s3">{</span><span class="s1">compute_uv</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s3">lambda </span><span class="s1">*args: lax.linalg.svd_p.bind(</span>
                <span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">full_matrices=args[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">compute_uv=args[</span><span class="s5">2</span><span class="s1">])</span><span class="s3">, </span><span class="s1">[</span>
                    <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
                    <span class="s1">StaticArg(full_matrices)</span><span class="s3">,</span>
                    <span class="s1">StaticArg(compute_uv)</span>
                <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">jax_unimplemented=[</span>
                <span class="s1">Limitation(</span>
                    <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
                    <span class="s1">devices=(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16])</span><span class="s3">,</span>
            <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">dtype=dtype</span><span class="s3">,</span>
            <span class="s1">full_matrices=full_matrices</span><span class="s3">,</span>
            <span class="s1">compute_uv=compute_uv)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)]:</span>
    <span class="s3">for </span><span class="s1">compute_left_eigenvectors </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
      <span class="s3">for </span><span class="s1">compute_right_eigenvectors </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
        <span class="s1">define(</span>
            <span class="s1">lax.linalg.eig_p</span><span class="s3">,</span>
            <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_computelefteigenvectors=</span><span class="s3">{</span><span class="s1">compute_left_eigenvectors</span><span class="s3">}</span><span class="s4">_computerighteigenvectors=</span><span class="s3">{</span><span class="s1">compute_right_eigenvectors</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s1">partial(lax.linalg.eig</span><span class="s3">, </span><span class="s1">compute_left_eigenvectors=compute_left_eigenvectors</span><span class="s3">, </span><span class="s1">compute_right_eigenvectors=compute_right_eigenvectors)</span><span class="s3">,</span>
            <span class="s1">[</span>
                <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
            <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">jax_unimplemented=[</span>
                <span class="s1">Limitation(</span>
                    <span class="s4">&quot;only supported on CPU in JAX&quot;</span><span class="s3">, </span><span class="s1">devices=(</span><span class="s4">&quot;tpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s1">))</span><span class="s3">,</span>
                <span class="s1">Limitation(</span>
                    <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
                    <span class="s1">devices=</span><span class="s4">&quot;cpu&quot;</span><span class="s3">,</span>
                    <span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16])</span>
            <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">dtype=dtype</span><span class="s3">,</span>
            <span class="s1">compute_left_eigenvectors=compute_left_eigenvectors</span><span class="s3">,</span>
            <span class="s1">compute_right_eigenvectors=compute_right_eigenvectors)</span>


<span class="s3">def </span><span class="s1">_make_triangular_eigh_operand(shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">lower: bool</span><span class="s3">, </span><span class="s1">rng: Rng):</span>
  <span class="s0"># For testing eigh we use triangular matrices</span>
  <span class="s1">operand = jtu.rand_default(rng)(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s0"># Make operand self-adjoint</span>
  <span class="s1">operand = (operand + np.conj(np.swapaxes(operand</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">))) / </span><span class="s5">2</span>
  <span class="s0"># Make operand lower/upper triangular</span>
  <span class="s3">return </span><span class="s1">operand  </span><span class="s0"># np.tril(operand) if lower else np.triu(operand)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">50</span><span class="s3">, </span><span class="s5">50</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">20</span><span class="s1">)]:</span>
    <span class="s3">for </span><span class="s1">lower </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
      <span class="s1">define(</span>
          <span class="s1">lax.linalg.eigh_p</span><span class="s3">,</span>
          <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">lower=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
          <span class="s0"># Make operand lower/upper triangular</span>
          <span class="s3">lambda </span><span class="s1">operand</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">, </span><span class="s1">symmetrize_input: (lax.linalg.eigh(</span>
              <span class="s1">jnp.tril(operand)</span>
              <span class="s3">if </span><span class="s1">lower </span><span class="s3">else </span><span class="s1">jnp.triu(operand)</span><span class="s3">, </span><span class="s1">lower=lower</span><span class="s3">, </span><span class="s1">symmetrize_input=symmetrize_input))</span><span class="s3">,</span>
          <span class="s1">[</span>
              <span class="s1">CustomArg(</span>
                  <span class="s1">partial(_make_triangular_eigh_operand</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">lower))</span><span class="s3">,</span>
              <span class="s1">StaticArg(lower)</span><span class="s3">,</span>
              <span class="s1">StaticArg(</span><span class="s3">False</span><span class="s1">)</span>
          <span class="s1">]</span><span class="s3">,</span>
          <span class="s1">jax_unimplemented=[</span>
              <span class="s1">Limitation(</span>
                  <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
                  <span class="s1">devices=(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;gpu&quot;</span><span class="s1">)</span><span class="s3">,</span>
                  <span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16])</span><span class="s3">,</span>
          <span class="s1">]</span><span class="s3">,</span>
          <span class="s1">shape=shape</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">lower=lower)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># square</span>
      <span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># batched</span>
      <span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># non-square</span>
  <span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.linalg.lu_p</span><span class="s3">,</span>
        <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">lax.linalg.lu</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=[</span>
            <span class="s1">Limitation(</span><span class="s4">&quot;unimplemented&quot;</span><span class="s3">, </span><span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16])</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_make_triangular_solve_harness(name</span><span class="s3">,</span>
                                   <span class="s1">*</span><span class="s3">,</span>
                                   <span class="s1">left_side=</span><span class="s3">True,</span>
                                   <span class="s1">lower=</span><span class="s3">False,</span>
                                   <span class="s1">ab_shapes=((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
                                   <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                   <span class="s1">transpose_a=</span><span class="s3">False,</span>
                                   <span class="s1">conjugate_a=</span><span class="s3">False,</span>
                                   <span class="s1">unit_diagonal=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">a_shape</span><span class="s3">, </span><span class="s1">b_shape = ab_shapes</span>
  <span class="s1">f_lax = </span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b: (</span>
      <span class="s1">lax.linalg.triangular_solve_p.bind(</span>
          <span class="s1">a</span><span class="s3">,</span>
          <span class="s1">b</span><span class="s3">,</span>
          <span class="s1">left_side=left_side</span><span class="s3">,</span>
          <span class="s1">lower=lower</span><span class="s3">,</span>
          <span class="s1">transpose_a=transpose_a</span><span class="s3">,</span>
          <span class="s1">conjugate_a=conjugate_a</span><span class="s3">,</span>
          <span class="s1">unit_diagonal=unit_diagonal))</span>

  <span class="s1">define(</span>
      <span class="s1">lax.linalg.triangular_solve_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_a=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(a_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_b=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(b_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_leftside=</span><span class="s3">{</span><span class="s1">left_side</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">lower=</span><span class="s3">}</span><span class="s4">_transposea=</span><span class="s3">{</span><span class="s1">transpose_a</span><span class="s3">}</span><span class="s4">_conjugatea=</span><span class="s3">{</span><span class="s1">conjugate_a</span><span class="s3">}</span><span class="s4">_unitdiagonal=</span><span class="s3">{</span><span class="s1">unit_diagonal</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">f_lax</span><span class="s3">, </span><span class="s1">[RandArg(a_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
              <span class="s1">RandArg(b_shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=[</span>
          <span class="s1">Limitation(</span><span class="s4">&quot;unimplemented&quot;</span><span class="s3">, </span><span class="s1">devices=</span><span class="s4">&quot;gpu&quot;</span><span class="s3">, </span><span class="s1">dtypes=[np.float16])</span><span class="s3">,</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">a_shape=a_shape</span><span class="s3">,</span>
      <span class="s1">b_shape=b_shape</span><span class="s3">,</span>
      <span class="s1">left_side=left_side</span><span class="s3">,</span>
      <span class="s1">lower=lower</span><span class="s3">,</span>
      <span class="s1">tranpose_a=transpose_a</span><span class="s3">,</span>
      <span class="s1">conjugate_a=conjugate_a</span><span class="s3">,</span>
      <span class="s1">unit_diagonal=unit_diagonal)</span>


<span class="s0"># Validate dtypes</span>
<span class="s0"># This first harness runs the tests for all dtypes using default values for</span>
<span class="s0"># all the other parameters, except unit_diagonal (to ensure that</span>
<span class="s0"># tf.linalg.set_diag works reliably for all dtypes). Variations of other</span>
<span class="s0"># parameters can thus safely skip testing their corresponding default value.</span>
<span class="s0"># Note that this validates solving on the left.</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">unit_diagonal </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s1">_make_triangular_solve_harness(</span>
        <span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">unit_diagonal=unit_diagonal)</span>

<span class="s0"># Validate shapes when solving on the right</span>
<span class="s3">for </span><span class="s1">ab_shapes </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># standard</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">8</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">8</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># batched</span>
<span class="s1">]:</span>
  <span class="s1">_make_triangular_solve_harness(</span>
      <span class="s4">&quot;shapes_right&quot;</span><span class="s3">, </span><span class="s1">ab_shapes=ab_shapes</span><span class="s3">, </span><span class="s1">left_side=</span><span class="s3">False</span><span class="s1">)</span>
<span class="s0"># Validate transformations of a complex matrix</span>
<span class="s3">for </span><span class="s1">lower </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">transpose_a </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">conjugate_a </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
      <span class="s1">_make_triangular_solve_harness(</span>
          <span class="s4">&quot;complex_transformations&quot;</span><span class="s3">,</span>
          <span class="s1">dtype=np.complex64</span><span class="s3">,</span>
          <span class="s1">lower=lower</span><span class="s3">,</span>
          <span class="s1">transpose_a=transpose_a</span><span class="s3">,</span>
          <span class="s1">conjugate_a=conjugate_a)</span>

<span class="s0"># Validate transformations of a real matrix</span>
<span class="s3">for </span><span class="s1">lower </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">transpose_a </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s0"># conjugate_a is irrelevant for real dtypes, and is thus omitted</span>
    <span class="s1">_make_triangular_solve_harness(</span>
        <span class="s4">&quot;real_transformations&quot;</span><span class="s3">,</span>
        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
        <span class="s1">lower=lower</span><span class="s3">,</span>
        <span class="s1">transpose_a=transpose_a)</span>


<span class="s3">def </span><span class="s1">_make_linear_solve_harnesses():</span>

  <span class="s3">def </span><span class="s1">linear_solve(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">solve</span><span class="s3">, </span><span class="s1">transpose_solve=</span><span class="s3">None, </span><span class="s1">symmetric=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s1">matvec = partial(lax.dot</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">precision=lax.Precision.HIGHEST)</span>
    <span class="s3">return </span><span class="s1">lax.custom_linear_solve(matvec</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">solve</span><span class="s3">, </span><span class="s1">transpose_solve</span><span class="s3">, </span><span class="s1">symmetric)</span>

  <span class="s3">def </span><span class="s1">explicit_jacobian_solve(matvec</span><span class="s3">, </span><span class="s1">b):</span>
    <span class="s3">return </span><span class="s1">lax.stop_gradient(jnp.linalg.solve(jax.jacobian(matvec)(b)</span><span class="s3">, </span><span class="s1">b))</span>

  <span class="s3">def </span><span class="s1">_make_harness(name</span><span class="s3">,</span>
                    <span class="s1">*</span><span class="s3">,</span>
                    <span class="s1">shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                    <span class="s1">symmetric=</span><span class="s3">False,</span>
                    <span class="s1">solvers=(explicit_jacobian_solve</span><span class="s3">, </span><span class="s1">explicit_jacobian_solve)):</span>
    <span class="s1">solve</span><span class="s3">, </span><span class="s1">transpose_solve = solvers</span>
    <span class="s1">transpose_solve_name = transpose_solve.__name__ </span><span class="s3">if </span><span class="s1">transpose_solve </span><span class="s3">else None</span>

    <span class="s3">def </span><span class="s1">_make_first_argument(rng):</span>
      <span class="s1">a = jtu.rand_default(rng)(shape</span><span class="s3">, </span><span class="s1">dtype)</span>
      <span class="s3">if </span><span class="s1">symmetric:</span>
        <span class="s1">a = a + a.T</span>
      <span class="s3">return </span><span class="s1">a</span>

    <span class="s1">define(</span>
        <span class="s1">lax.linear_solve_p</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_a=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_b=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_solve=</span><span class="s3">{</span><span class="s1">solve.__name__</span><span class="s3">}</span><span class="s4">_transposesolve=</span><span class="s3">{</span><span class="s1">transpose_solve_name</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">symmetric=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">linear_solve</span><span class="s3">, </span><span class="s1">[</span>
            <span class="s1">CustomArg(_make_first_argument)</span><span class="s3">,</span>
            <span class="s1">RandArg(shape[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
            <span class="s1">StaticArg(solve)</span><span class="s3">,</span>
            <span class="s1">StaticArg(transpose_solve)</span><span class="s3">,</span>
            <span class="s1">StaticArg(symmetric)</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">solve=solve</span><span class="s3">,</span>
        <span class="s1">transpose_solve=transpose_solve</span><span class="s3">,</span>
        <span class="s1">symmetric=symmetric)</span>

  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
    <span class="s3">if not </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16]:</span>
      <span class="s1">_make_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s0"># Validate symmetricity</span>
  <span class="s1">_make_harness(</span><span class="s4">&quot;symmetric&quot;</span><span class="s3">, </span><span class="s1">symmetric=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s0"># Validate removing transpose_solve</span>
  <span class="s1">_make_harness(</span><span class="s4">&quot;transpose_solve&quot;</span><span class="s3">, </span><span class="s1">solvers=(explicit_jacobian_solve</span><span class="s3">, None</span><span class="s1">))</span>


<span class="s1">_make_linear_solve_harnesses()</span>

<span class="s0"># tridiagonal_solve_p</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[np.float32</span><span class="s3">, </span><span class="s1">np.float64]:</span>
  <span class="s1">define(</span>
      <span class="s1">lax.linalg.tridiagonal_solve_p</span><span class="s3">,</span>
      <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.linalg.tridiagonal_solve</span><span class="s3">,</span>
      <span class="s1">[ np.array([</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">3.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
        <span class="s1">np.ones(</span><span class="s5">3</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
        <span class="s1">np.array([</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
        <span class="s1">np.ones([</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=dtype)]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>

<span class="s3">def </span><span class="s1">_make_slice_harness(name</span><span class="s3">,</span>
                        <span class="s1">shape=(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">start_indices=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">limit_indices=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">strides=</span><span class="s3">None,</span>
                        <span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.slice_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_a=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">start_indices=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">limit_indices=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">strides=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s0"># type: ignore</span>
      <span class="s1">lax.slice</span><span class="s3">,</span>
      <span class="s1">[</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
          <span class="s1">StaticArg(start_indices)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
          <span class="s1">StaticArg(limit_indices)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
          <span class="s1">StaticArg(strides)</span>
      <span class="s1">]</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">start_indices=start_indices</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">limit_indices=limit_indices)  </span><span class="s0"># type: ignore</span>


<span class="s0"># Test first all dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_slice_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Now test many shapes</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">, </span><span class="s1">limit_indices</span><span class="s3">, </span><span class="s1">strides </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">7</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">7</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">8</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">6</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">7</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
<span class="s1">]:</span>
  <span class="s1">_make_slice_harness(</span>
      <span class="s4">&quot;shapes&quot;</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">start_indices=start_indices</span><span class="s3">,</span>
      <span class="s1">limit_indices=limit_indices</span><span class="s3">,</span>
      <span class="s1">strides=strides)</span>


<span class="s3">def </span><span class="s1">_make_complex_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shapes=((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span><span class="s3">, </span><span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.complex_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shapes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shapes[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.complex_p.bind</span><span class="s3">,</span>
      <span class="s1">[RandArg(shapes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
       <span class="s1">RandArg(shapes[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shapes=shapes</span><span class="s3">,</span>
      <span class="s1">dtype=dtype)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.floating:</span>
  <span class="s1">_make_complex_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate broadcasting</span>
<span class="s3">for </span><span class="s1">shapes </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast imaginary part</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># broadcast real part</span>
<span class="s1">]:</span>
  <span class="s1">_make_complex_harness(</span><span class="s4">&quot;broadcast&quot;</span><span class="s3">, </span><span class="s1">shapes=shapes)</span>


<span class="s3">def </span><span class="s1">_make_conj_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.conj_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_operand=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">kwargs=</span><span class="s3">}</span><span class="s4">&quot;</span>
      <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">x: lax.conj_p.bind(x</span><span class="s3">, </span><span class="s1">**kwargs)</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">**kwargs)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.floating + jtu.dtypes.complex:</span>
  <span class="s1">_make_conj_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate kwargs</span>
<span class="s1">_make_conj_harness(</span><span class="s4">&quot;kwargs&quot;</span><span class="s3">, </span><span class="s1">_input_dtype=np.float32)</span>


<span class="s3">def </span><span class="s1">_make_real_imag_harness(prim</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">prim</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">prim.bind</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">prim=prim)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.complex:</span>
  <span class="s3">for </span><span class="s1">prim </span><span class="s3">in </span><span class="s1">[lax.real_p</span><span class="s3">, </span><span class="s1">lax.imag_p]:</span>
    <span class="s1">_make_real_imag_harness(prim</span><span class="s3">, </span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_make_dynamic_slice_harness(name</span><span class="s3">,</span>
                                <span class="s1">shape=(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">start_indices=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">limit_indices=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">dtype=np.float32):</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.dynamic_slice_p</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_a=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">start_indices=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">limit_indices=</span><span class="s3">}</span><span class="s4">_enablexla=</span><span class="s3">{</span><span class="s1">enable_xla</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s0"># type: ignore</span>
        <span class="s1">lax.dynamic_slice</span><span class="s3">,</span>
        <span class="s1">[</span>
            <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
            <span class="s1">np.array(list(start_indices))</span><span class="s3">,</span>
            <span class="s1">StaticArg(tuple(map(operator.sub</span><span class="s3">, </span><span class="s1">limit_indices</span><span class="s3">, </span><span class="s1">start_indices)))</span>
        <span class="s1">]</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">start_indices=start_indices</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">limit_indices=limit_indices</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s0"># Test first all dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_dynamic_slice_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Now test many shapes</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">, </span><span class="s1">limit_indices </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">7</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">7</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">8</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">6</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">7</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.uint32)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">2</span><span class="s3">,</span>
                                                <span class="s1">np.uint32)</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># uint32 indices</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.uint8)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">np.uint8)</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># uint8 indices</span>
    <span class="s0"># out-of-bounds cases, allowed for dynamic_slice</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">6</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">5</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">9</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">100</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">99</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">6</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">11</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">6</span><span class="s3">,</span><span class="s1">))</span>
<span class="s1">]:</span>
  <span class="s1">_make_dynamic_slice_harness(</span>
      <span class="s4">&quot;shapes&quot;</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">start_indices=start_indices</span><span class="s3">,</span>
      <span class="s1">limit_indices=limit_indices)</span>


<span class="s3">def </span><span class="s1">_make_dynamic_update_slice_harness(name</span><span class="s3">,</span>
                                       <span class="s1">shape=(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                       <span class="s1">start_indices=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                       <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                       <span class="s1">update_shape=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)):</span>
  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">[</span><span class="s3">False, True</span><span class="s1">]:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.dynamic_update_slice_p</span><span class="s3">,</span>
        <span class="s1">(</span>
            <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_operand=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;  </span><span class="s0"># type: ignore</span>
            <span class="s4">f&quot;_update=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(update_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;_</span><span class="s3">{</span><span class="s1">start_indices=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">enable_xla=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lax.dynamic_update_slice</span><span class="s3">,</span>
        <span class="s1">[</span>
            <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
            <span class="s1">RandArg(update_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
            <span class="s1">np.array(start_indices)</span>
        <span class="s1">]</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">start_indices=start_indices</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">update_shape=update_shape</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">enable_xla=enable_xla)</span>


<span class="s0"># Test first all dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_dynamic_update_slice_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Now test many shapes</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">start_indices</span><span class="s3">, </span><span class="s1">update_shape </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">7</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.uint32)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># uint32 indices</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(np.array(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.uint8)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># uint8 indices</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># out-of-bounds</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># out-of-bounds</span>
    <span class="s1">((</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">10</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># out-of-bounds</span>
<span class="s1">]:</span>
  <span class="s1">_make_dynamic_update_slice_harness(</span>
      <span class="s4">&quot;shapes&quot;</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">start_indices=start_indices</span><span class="s3">,</span>
      <span class="s1">update_shape=update_shape)</span>


<span class="s3">def </span><span class="s1">_make_squeeze_harness(name</span><span class="s3">,</span>
                          <span class="s1">shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dimensions=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dtype=np.float32):</span>
  <span class="s1">define(</span>
      <span class="s1">lax.squeeze_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_inshape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimensions=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
      <span class="s1">lax.squeeze</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">StaticArg(dimensions)]</span><span class="s3">,  </span><span class="s0"># type: ignore[has-type]</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">arg_shape=shape</span><span class="s3">,</span>
      <span class="s1">dimensions=dimensions)  </span><span class="s0"># type: ignore[has-type]</span>


<span class="s0"># Test first all dtypes</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all):</span>
  <span class="s1">_make_squeeze_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s0"># Now test many shapes</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dimensions </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
<span class="s1">]:</span>
  <span class="s1">_make_squeeze_harness(</span><span class="s4">&quot;shapes&quot;</span><span class="s3">, </span><span class="s1">shape=shape</span><span class="s3">, </span><span class="s1">dimensions=dimensions)</span>


<span class="s3">def </span><span class="s1">_make_select_and_scatter_add_harness(name</span><span class="s3">,</span>
                                         <span class="s1">*</span><span class="s3">,</span>
                                         <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">,</span>
                                         <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                         <span class="s1">select_prim=lax.ge_p</span><span class="s3">,</span>
                                         <span class="s1">window_dimensions=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                                         <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                         <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,</span>
                                         <span class="s1">nb_inactive_dims=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s1">ones = (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) * len(shape)</span>
  <span class="s1">cotangent_shape = jax.eval_shape(</span>
      <span class="s3">lambda </span><span class="s1">x: lax_windowed_reductions._select_and_gather_add(</span>
          <span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lax.ge_p</span><span class="s3">, </span><span class="s1">window_dimensions</span><span class="s3">, </span><span class="s1">window_strides</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">,</span>
          <span class="s1">ones</span><span class="s3">, </span><span class="s1">ones)</span><span class="s3">,</span>
      <span class="s1">np.ones(shape</span><span class="s3">, </span><span class="s1">dtype)).shape</span>
  <span class="s1">define(</span>
      <span class="s1">lax.select_and_scatter_add_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_selectprim=</span><span class="s3">{</span><span class="s1">select_prim</span><span class="s3">}</span><span class="s4">_windowdimensions=</span><span class="s3">{</span><span class="s1">window_dimensions</span><span class="s3">}</span><span class="s4">_windowstrides=</span><span class="s3">{</span><span class="s1">window_strides</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">padding=</span><span class="s3">!s}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax_windowed_reductions._select_and_scatter_add</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">RandArg(cotangent_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">StaticArg(select_prim)</span><span class="s3">,</span>
          <span class="s1">StaticArg(window_dimensions)</span><span class="s3">,</span>
          <span class="s1">StaticArg(window_strides)</span><span class="s3">,</span>
          <span class="s1">StaticArg(padding)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=[</span>
          <span class="s1">Limitation(</span>
              <span class="s4">&quot;works only for 2 or more inactive dimensions&quot;</span><span class="s3">,</span>
              <span class="s1">devices=</span><span class="s4">&quot;tpu&quot;</span><span class="s3">,</span>
              <span class="s1">enabled=(nb_inactive_dims &lt; </span><span class="s5">2</span><span class="s1">))</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">select_prim=select_prim</span><span class="s3">,</span>
      <span class="s1">window_dimensions=window_dimensions</span><span class="s3">,</span>
      <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
      <span class="s1">padding=padding)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - {np.complex64</span><span class="s3">, </span><span class="s1">np.complex128}:</span>
  <span class="s1">_make_select_and_scatter_add_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate different reduction primitives</span>
<span class="s1">_make_select_and_scatter_add_harness(</span><span class="s4">&quot;select_prim&quot;</span><span class="s3">, </span><span class="s1">select_prim=lax.le_p)</span>

<span class="s0"># Validate padding</span>
<span class="s3">for </span><span class="s1">padding </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s0"># TODO(bchetioui): commented out the test based on</span>
    <span class="s0"># https://github.com/google/jax/issues/4690</span>
    <span class="s0"># ((1, 2), (2, 3), (3, 4)) # non-zero padding</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))  </span><span class="s0"># non-zero padding</span>
<span class="s1">]:</span>
  <span class="s1">_make_select_and_scatter_add_harness(</span><span class="s4">&quot;padding&quot;</span><span class="s3">, </span><span class="s1">padding=padding)</span>

<span class="s0"># Validate window_dimensions; uneven dimensions</span>
<span class="s1">_make_select_and_scatter_add_harness(</span>
    <span class="s4">&quot;window_dimensions&quot;</span><span class="s3">, </span><span class="s1">window_dimensions=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>

<span class="s0"># Validate window_strides</span>
<span class="s0"># smaller than/same as/bigger than corresponding window dimension</span>
<span class="s1">_make_select_and_scatter_add_harness(</span><span class="s4">&quot;window_strides&quot;</span><span class="s3">, </span><span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>

<span class="s0"># Validate dtypes on TPU</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all) - {</span>
    <span class="s1">np.bool_</span><span class="s3">, </span><span class="s1">np.complex64</span><span class="s3">, </span><span class="s1">np.complex128</span><span class="s3">, </span><span class="s1">np.int8</span><span class="s3">, </span><span class="s1">np.uint8}:</span>
  <span class="s3">for </span><span class="s1">window_strides</span><span class="s3">, </span><span class="s1">window_dimensions</span><span class="s3">, </span><span class="s1">nb_inactive_dims </span><span class="s3">in </span><span class="s1">[((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                                               <span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)]:</span>
    <span class="s1">_make_select_and_scatter_add_harness(</span>
        <span class="s4">&quot;tpu_dtypes&quot;</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">nb_inactive_dims=nb_inactive_dims</span><span class="s3">,</span>
        <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
        <span class="s1">window_dimensions=window_dimensions)</span>


<span class="s3">def </span><span class="s1">_make_select_and_gather_add_harness(name</span><span class="s3">,</span>
                                        <span class="s1">*</span><span class="s3">,</span>
                                        <span class="s1">shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">,</span>
                                        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                        <span class="s1">select_prim=lax.le_p</span><span class="s3">,</span>
                                        <span class="s1">padding=</span><span class="s4">&quot;VALID&quot;</span><span class="s3">,</span>
                                        <span class="s1">window_dimensions=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                                        <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                        <span class="s1">base_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                        <span class="s1">window_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)):</span>
  <span class="s3">if </span><span class="s1">isinstance(padding</span><span class="s3">, </span><span class="s1">str):</span>
    <span class="s1">padding = tuple(</span>
        <span class="s1">lax.padtype_to_pads(shape</span><span class="s3">, </span><span class="s1">window_dimensions</span><span class="s3">, </span><span class="s1">window_strides</span><span class="s3">, </span><span class="s1">padding))</span>
  <span class="s1">define(</span>
      <span class="s1">lax.select_and_gather_add_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_selectprim=</span><span class="s3">{</span><span class="s1">select_prim</span><span class="s3">}</span><span class="s4">_windowdimensions=</span><span class="s3">{</span><span class="s1">window_dimensions</span><span class="s3">}</span><span class="s4">_windowstrides=</span><span class="s3">{</span><span class="s1">window_strides</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">padding=</span><span class="s3">!s}</span><span class="s4">_basedilation=</span><span class="s3">{</span><span class="s1">base_dilation</span><span class="s3">}</span><span class="s4">_windowdilation=</span><span class="s3">{</span><span class="s1">window_dilation</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax_windowed_reductions._select_and_gather_add</span><span class="s3">, </span><span class="s1">[</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">StaticArg(select_prim)</span><span class="s3">,</span>
          <span class="s1">StaticArg(window_dimensions)</span><span class="s3">,</span>
          <span class="s1">StaticArg(window_strides)</span><span class="s3">,</span>
          <span class="s1">StaticArg(padding)</span><span class="s3">,</span>
          <span class="s1">StaticArg(base_dilation)</span><span class="s3">,</span>
          <span class="s1">StaticArg(window_dilation)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">window_dimensions=window_dimensions</span><span class="s3">,</span>
      <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
      <span class="s1">padding=padding</span><span class="s3">,</span>
      <span class="s1">base_dilation=base_dilation</span><span class="s3">,</span>
      <span class="s1">window_dilation=window_dilation)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s3">for </span><span class="s1">select_prim </span><span class="s3">in </span><span class="s1">[lax.ge_p</span><span class="s3">, </span><span class="s1">lax.le_p]:</span>
    <span class="s1">_make_select_and_gather_add_harness(</span>
        <span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">select_prim=select_prim)</span>

<span class="s0"># Validate selection primitives</span>
<span class="s1">_make_select_and_gather_add_harness(</span><span class="s4">&quot;select_prim&quot;</span><span class="s3">, </span><span class="s1">select_prim=lax.ge_p)</span>
<span class="s0"># Validate window dimensions</span>
<span class="s1">_make_select_and_gather_add_harness(</span>
    <span class="s4">&quot;window_dimensions&quot;</span><span class="s3">, </span><span class="s1">window_dimensions=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>

<span class="s0"># Validate window strides</span>
<span class="s1">_make_select_and_gather_add_harness(</span><span class="s4">&quot;window_strides&quot;</span><span class="s3">, </span><span class="s1">window_strides=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>
<span class="s0"># Validate padding</span>
<span class="s1">_make_select_and_gather_add_harness(</span><span class="s4">&quot;padding&quot;</span><span class="s3">, </span><span class="s1">padding=</span><span class="s4">&quot;SAME&quot;</span><span class="s1">)</span>

<span class="s0"># Validate dilations</span>
<span class="s3">for </span><span class="s1">base_dilation</span><span class="s3">, </span><span class="s1">window_dilation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># base dilation, no window dilation</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no base dilation, window dilation</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))  </span><span class="s0"># base dilation, window dilation</span>
<span class="s1">]:</span>
  <span class="s1">_make_select_and_gather_add_harness(</span>
      <span class="s4">&quot;dilations&quot;</span><span class="s3">, </span><span class="s1">base_dilation=base_dilation</span><span class="s3">, </span><span class="s1">window_dilation=window_dilation)</span>

<span class="s3">def </span><span class="s1">_make_reduce_harness(name</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
                         <span class="s1">shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># The shape of all operands</span>
                         <span class="s1">nr_operands=</span><span class="s5">1</span><span class="s3">,  </span><span class="s0"># How many operands</span>
                         <span class="s1">computation=lax.add</span><span class="s3">,  </span><span class="s0"># Takes Tuple(op1, [op2,]) and Tuple(init_val1, [init_val2]). Returns Tuple(out_val1, [out_val2]).</span>
                         <span class="s1">dimensions: Sequence[int] = (</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">init_value=</span><span class="s5">0</span><span class="s3">,  </span><span class="s0"># The init value for first operand</span>
                         <span class="s1">dtype=np.float32):  </span><span class="s0"># The dtype of first operand</span>
  <span class="s3">def </span><span class="s1">reducer(*args):</span>
    <span class="s1">init_val = np.array(init_value</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">init_values = [init_val]</span>
    <span class="s3">if </span><span class="s1">nr_operands == </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s1">init_values.append(np.int32(</span><span class="s5">0.</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">lax.reduce(args[</span><span class="s5">0</span><span class="s1">:nr_operands]</span><span class="s3">, </span><span class="s1">tuple(init_values)</span><span class="s3">,</span>
                      <span class="s1">computation</span><span class="s3">, </span><span class="s1">dimensions)</span>
  <span class="s1">define(</span>
      <span class="s1">lax.reduce_p</span><span class="s3">,</span>
      <span class="s4">f&quot;gen_</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_initvalue=</span><span class="s3">{</span><span class="s1">init_value</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">nr_operands=</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimensions=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">reducer</span><span class="s3">,</span>
      <span class="s1">[</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s0"># Second operand (optional, always i32). We cannot mix multiple float</span>
          <span class="s0"># types in XLA.</span>
          <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">,</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">init_value=init_value</span><span class="s3">,</span>
      <span class="s1">computation=computation</span><span class="s3">,</span>
      <span class="s1">dimensions=dimensions)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">nr_operands</span><span class="s3">, </span><span class="s1">computation</span><span class="s3">, </span><span class="s1">init_value </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(</span><span class="s4">&quot;add_scalar&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span>
       <span class="s3">lambda </span><span class="s1">ops</span><span class="s3">, </span><span class="s1">inits: (lax.add(ops[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">inits[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s0"># Compute the max (starting with 3) and the min (from 0), in parallel</span>
      <span class="s1">(</span><span class="s4">&quot;max_min&quot;</span><span class="s3">, </span><span class="s5">2</span><span class="s3">,</span>
       <span class="s3">lambda </span><span class="s1">ops</span><span class="s3">, </span><span class="s1">inits: (lax.max(ops[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">inits[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">,</span>
                           <span class="s1">lax.min(ops[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">inits[</span><span class="s5">1</span><span class="s1">]))</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
  <span class="s1">]:</span>
    <span class="s3">if not </span><span class="s1">(dtype == np.bool_ </span><span class="s3">and </span><span class="s1">name == </span><span class="s4">&quot;add_scalar&quot;</span><span class="s1">):</span>
      <span class="s1">_make_reduce_harness(name</span><span class="s3">, </span><span class="s1">nr_operands=nr_operands</span><span class="s3">,</span>
                           <span class="s1">computation=computation</span><span class="s3">, </span><span class="s1">init_value=init_value</span><span class="s3">,</span>
                           <span class="s1">dtype=dtype)</span>
    <span class="s0"># Test the dimensions, but only for int32 (to keep the # of tests small)</span>
    <span class="s3">if </span><span class="s1">dtype == np.int32:</span>
      <span class="s1">_make_reduce_harness(name</span><span class="s3">, </span><span class="s1">nr_operands=nr_operands</span><span class="s3">,</span>
                           <span class="s1">computation=computation</span><span class="s3">, </span><span class="s1">init_value=init_value</span><span class="s3">,</span>
                           <span class="s1">dimensions=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">dtype=dtype)</span>
      <span class="s1">_make_reduce_harness(name</span><span class="s3">, </span><span class="s1">nr_operands=nr_operands</span><span class="s3">,</span>
                           <span class="s1">computation=computation</span><span class="s3">, </span><span class="s1">init_value=init_value</span><span class="s3">,</span>
                           <span class="s1">dimensions=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">dtype=dtype)</span>

<span class="s3">def </span><span class="s1">_make_reduce_window_harness(name</span><span class="s3">,</span>
                                <span class="s1">*</span><span class="s3">,</span>
                                <span class="s1">shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">base_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">computation=lax.add</span><span class="s3">,</span>
                                <span class="s1">window_dimensions=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">window_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">init_value=</span><span class="s5">0</span><span class="s3">,</span>
                                <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                                <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,</span>
                                <span class="s1">requires_xla=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">prim_name = </span><span class="s4">f&quot;reduce_window_</span><span class="s3">{</span><span class="s1">computation.__name__</span><span class="s3">}</span><span class="s4">&quot;</span>
  <span class="s1">limitations = []</span>
  <span class="s1">xla_opts = [</span><span class="s3">True</span><span class="s1">] </span><span class="s3">if </span><span class="s1">requires_xla </span><span class="s3">else </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]</span>

  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">xla_opts:</span>
    <span class="s1">define(</span>
        <span class="s1">prim_name</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_initvalue=</span><span class="s3">{</span><span class="s1">init_value</span><span class="s3">}</span><span class="s4">_windowdimensions=</span><span class="s3">{</span><span class="s1">window_dimensions</span><span class="s3">}</span><span class="s4">_windowstrides=</span><span class="s3">{</span><span class="s1">window_strides</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">padding=</span><span class="s3">!s}</span><span class="s4">_basedilation=</span><span class="s3">{</span><span class="s1">base_dilation</span><span class="s3">}</span><span class="s4">_windowdilation=</span><span class="s3">{</span><span class="s1">window_dilation</span><span class="s3">}</span><span class="s4">_enablexla=</span><span class="s3">{</span><span class="s1">enable_xla</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lax.reduce_window</span><span class="s3">,</span>
        <span class="s1">[</span>
            <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
            <span class="s0"># Must be static to trigger the picking of the reducers</span>
            <span class="s1">StaticArg(np.array(init_value</span><span class="s3">, </span><span class="s1">dtype=dtype))</span><span class="s3">,</span>
            <span class="s1">StaticArg(computation)</span><span class="s3">,</span>
            <span class="s1">StaticArg(window_dimensions)</span><span class="s3">,</span>
            <span class="s1">StaticArg(window_strides)</span><span class="s3">,</span>
            <span class="s1">StaticArg(padding)</span><span class="s3">,</span>
            <span class="s1">StaticArg(base_dilation)</span><span class="s3">,</span>
            <span class="s1">StaticArg(window_dilation)</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=limitations</span><span class="s3">,</span>
        <span class="s1">shape=shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">init_value=np.array(init_value</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">,</span>
        <span class="s1">computation=computation</span><span class="s3">,</span>
        <span class="s1">window_dimensions=window_dimensions</span><span class="s3">,</span>
        <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">base_dilation=base_dilation</span><span class="s3">,</span>
        <span class="s1">window_dilation=window_dilation</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla)</span>

<span class="s3">def </span><span class="s1">requires_xla_for_reduce(name</span><span class="s3">, </span><span class="s1">dtype):</span>
  <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s4">&quot;max&quot;</span><span class="s3">, </span><span class="s4">&quot;add&quot;</span><span class="s1">]:</span>
    <span class="s3">return True</span>
  <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s4">&quot;max&quot;</span><span class="s1">] </span><span class="s3">and </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">np.bool_</span><span class="s3">, </span><span class="s1">np.uint32</span><span class="s3">, </span><span class="s1">np.uint64</span><span class="s3">, </span><span class="s1">np.complex64</span><span class="s3">, </span><span class="s1">np.complex128</span>
  <span class="s1">]:</span>
    <span class="s3">return True</span>
  <span class="s3">if </span><span class="s1">name == </span><span class="s4">&quot;min&quot; </span><span class="s3">and </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[np.uint8</span><span class="s3">, </span><span class="s1">np.uint16]:</span>
    <span class="s3">return True</span>
  <span class="s3">if </span><span class="s1">name == </span><span class="s4">&quot;add&quot; </span><span class="s3">and </span><span class="s1">dtype </span><span class="s3">not in </span><span class="s1">[np.float16</span><span class="s3">, </span><span class="s1">np.float32</span><span class="s3">, </span><span class="s1">np.float64]:</span>
    <span class="s3">return True</span>
  <span class="s3">return False</span>

<span class="s0"># Validate dtypes across all execution paths</span>
<span class="s0"># This first harness runs the tests for all dtypes using default values for</span>
<span class="s0"># the other parameters (outside of computation and its init_value), through</span>
<span class="s0"># several execution paths. Variations of other parameters can thus safely</span>
<span class="s0"># skip testing their corresponding default value.</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s3">for </span><span class="s1">computation</span><span class="s3">, </span><span class="s1">init_value </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">(lax.min</span><span class="s3">, </span><span class="s1">_get_min_identity(dtype))</span><span class="s3">,  </span><span class="s0"># path through reduce_window_min</span>
      <span class="s1">(lax.max</span><span class="s3">, </span><span class="s1">_get_max_identity(dtype))</span><span class="s3">,  </span><span class="s0"># path through TF reduce_window_max</span>
      <span class="s1">(lax.max</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path through reduce_window</span>
      <span class="s1">(lax.add</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path_through reduce_window_sum</span>
      <span class="s1">(lax.add</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path through reduce_window</span>
      <span class="s1">(lax.mul</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path through reduce_window</span>
      <span class="s1">(lax.mul</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path through reduce_window</span>
      <span class="s1">(lax.mul</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># path through reduce_window</span>
  <span class="s1">]:</span>
    <span class="s3">if </span><span class="s1">dtype == np.bool_ </span><span class="s3">and </span><span class="s1">computation </span><span class="s3">in </span><span class="s1">[lax.add</span><span class="s3">, </span><span class="s1">lax.mul]:</span>
      <span class="s3">continue</span>
    <span class="s1">_make_reduce_window_harness(</span>
        <span class="s4">&quot;dtypes&quot;</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">computation=computation</span><span class="s3">,</span>
        <span class="s1">init_value=init_value</span><span class="s3">,</span>
        <span class="s1">requires_xla=requires_xla_for_reduce(computation.__name__</span><span class="s3">, </span><span class="s1">dtype))</span>

<span class="s0"># Validate window_dimensions</span>
<span class="s1">_make_reduce_window_harness(</span><span class="s4">&quot;window_dimensions&quot;</span><span class="s3">, </span><span class="s1">window_dimensions=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
<span class="s0"># Validate window_strides</span>
<span class="s1">_make_reduce_window_harness(</span><span class="s4">&quot;window_strides&quot;</span><span class="s3">, </span><span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
<span class="s0"># Validate padding</span>
<span class="s1">_make_reduce_window_harness(</span><span class="s4">&quot;padding&quot;</span><span class="s3">, </span><span class="s1">padding=((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,</span>
                            <span class="s1">requires_xla=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s0"># Validate base_dilation</span>
<span class="s1">_make_reduce_window_harness(</span><span class="s4">&quot;base_dilation&quot;</span><span class="s3">, </span><span class="s1">base_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                            <span class="s1">requires_xla=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s0"># Validate window_dilation</span>
<span class="s1">_make_reduce_window_harness(</span><span class="s4">&quot;window_dilation&quot;</span><span class="s3">, </span><span class="s1">window_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
<span class="s0"># Validate batch and channel dimensions behavior. lax.reduce_window accepts</span>
<span class="s0"># inputs that either have or do not have batch and channel dimensions.</span>
<span class="s0"># N=batch, DHW=spatial, C=channel.</span>
<span class="s0"># Without XLA only supports 1D/2D reductions.</span>
<span class="s3">for </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">window_dimensions</span><span class="s3">, </span><span class="s1">requires_xla </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># W</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># WC</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># NW</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># NWC</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># HW</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># NHWC</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, True</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># DHW</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, True</span><span class="s1">)  </span><span class="s0"># NDHWC</span>
<span class="s1">]:</span>
  <span class="s1">_make_reduce_window_harness(</span>
      <span class="s4">&quot;batch_channel_dims&quot;</span><span class="s3">,</span>
      <span class="s1">computation=lax.max</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=np.float32</span><span class="s3">,</span>
      <span class="s1">init_value=-np.inf</span><span class="s3">,</span>
      <span class="s1">base_dilation=tuple([</span><span class="s5">1</span><span class="s1">] * len(shape))</span><span class="s3">,</span>
      <span class="s1">window_dilation=tuple([</span><span class="s5">1</span><span class="s1">] * len(shape))</span><span class="s3">,</span>
      <span class="s1">padding=tuple([(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)] * len(shape))</span><span class="s3">,</span>
      <span class="s1">window_strides=tuple([</span><span class="s5">1</span><span class="s1">] * len(shape))</span><span class="s3">,</span>
      <span class="s1">window_dimensions=window_dimensions</span><span class="s3">,</span>
      <span class="s1">requires_xla=requires_xla)</span>

<span class="s3">for </span><span class="s1">computation</span><span class="s3">, </span><span class="s1">id_value </span><span class="s3">in </span><span class="s1">[(lax.max</span><span class="s3">, </span><span class="s1">_get_max_identity(np.float32))</span><span class="s3">,</span>
                              <span class="s1">(lax.min</span><span class="s3">, </span><span class="s1">_get_min_identity(np.float32))</span><span class="s3">,</span>
                              <span class="s1">(lax.add</span><span class="s3">, </span><span class="s5">0.</span><span class="s1">)]:</span>
  <span class="s1">_make_reduce_window_harness(</span>
      <span class="s4">&quot;same_padding&quot;</span><span class="s3">,</span>
      <span class="s1">shape=(</span><span class="s5">112</span><span class="s3">, </span><span class="s5">112</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">init_value=id_value</span><span class="s3">,</span>
      <span class="s1">computation=computation</span><span class="s3">,</span>
      <span class="s1">window_dimensions=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">window_strides=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">padding=</span><span class="s4">&quot;SAME&quot;</span><span class="s1">)</span>

<span class="s0"># A few additional test cases for manual padding, which is applied when calling</span>
<span class="s0"># reduce_window with lax.add, SAME padding and window_dimensions != (1, 1, ...).</span>
<span class="s3">for </span><span class="s1">window_dimensions</span><span class="s3">, </span><span class="s1">window_strides </span><span class="s3">in </span><span class="s1">[((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">, </span><span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,</span>
                                          <span class="s1">((</span><span class="s5">13</span><span class="s3">, </span><span class="s5">13</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">))]:</span>
  <span class="s1">_make_reduce_window_harness(</span>
      <span class="s4">&quot;manual_padding&quot;</span><span class="s3">,</span>
      <span class="s1">shape=(</span><span class="s5">12</span><span class="s3">, </span><span class="s5">12</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">init_value=</span><span class="s5">0.</span><span class="s3">,</span>
      <span class="s1">computation=lax.add</span><span class="s3">,</span>
      <span class="s1">window_dimensions=window_dimensions</span><span class="s3">,</span>
      <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
      <span class="s1">padding=</span><span class="s4">&quot;SAME&quot;</span><span class="s1">)</span>

<span class="s1">_make_reduce_window_harness(</span>
    <span class="s4">&quot;init_value_1d&quot;</span><span class="s3">,</span>
    <span class="s1">shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1600</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">init_value=</span><span class="s5">1.0</span><span class="s3">,</span>
    <span class="s1">computation=lax.min</span><span class="s3">,</span>
    <span class="s1">window_dimensions=[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">401</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">window_strides=[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">160</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">padding=</span><span class="s4">&quot;VALID&quot;</span><span class="s3">,</span>
    <span class="s1">requires_xla=</span><span class="s3">False</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_make_reducer_harness(prim</span><span class="s3">,</span>
                          <span class="s1">name</span><span class="s3">,</span>
                          <span class="s1">*</span><span class="s3">,</span>
                          <span class="s1">shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">axes=(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">dtype=np.int32):</span>
  <span class="s1">define(</span>
      <span class="s1">prim</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">arg: prim.bind(arg</span><span class="s3">, </span><span class="s1">axes=axes)</span><span class="s3">, </span><span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
      <span class="s1">prim=prim</span><span class="s3">,</span>
      <span class="s1">shape=shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">axes=axes)</span>


<span class="s3">for </span><span class="s1">prim </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">lax.reduce_sum_p</span><span class="s3">, </span><span class="s1">lax.reduce_prod_p</span><span class="s3">, </span><span class="s1">lax.reduce_max_p</span><span class="s3">, </span><span class="s1">lax.reduce_min_p</span><span class="s3">,</span>
    <span class="s1">lax.reduce_or_p</span><span class="s3">, </span><span class="s1">lax.reduce_and_p</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">{</span>
      <span class="s1">lax.reduce_sum_p: set(jtu.dtypes.all) - set(jtu.dtypes.boolean)</span><span class="s3">,</span>
      <span class="s1">lax.reduce_prod_p: set(jtu.dtypes.all) - set(jtu.dtypes.boolean)</span><span class="s3">,</span>
      <span class="s1">lax.reduce_max_p: jtu.dtypes.all</span><span class="s3">,</span>
      <span class="s1">lax.reduce_min_p: jtu.dtypes.all</span><span class="s3">,</span>
      <span class="s1">lax.reduce_or_p: jtu.dtypes.boolean</span><span class="s3">,</span>
      <span class="s1">lax.reduce_and_p: jtu.dtypes.boolean</span>
  <span class="s1">}[prim]:</span>
    <span class="s1">_make_reducer_harness(prim</span><span class="s3">, </span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">(np.float32</span><span class="s3">, </span><span class="s1">np.float64):</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)):</span>
    <span class="s1">define(</span>
        <span class="s4">&quot;random_gamma&quot;</span><span class="s3">,</span>
        <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">jax.jit(jax_random.gamma)</span><span class="s3">,</span>
        <span class="s1">[np.array([</span><span class="s5">42</span><span class="s3">, </span><span class="s5">43</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
         <span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)]</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">key_i</span><span class="s3">, </span><span class="s1">key </span><span class="s3">in </span><span class="s1">enumerate([</span>
    <span class="s1">np.array([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
    <span class="s1">np.array([</span><span class="s5">42</span><span class="s3">, </span><span class="s5">43</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
    <span class="s1">np.array([</span><span class="s5">0xFFFFFFFF</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
    <span class="s1">np.array([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0xFFFFFFFF</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
    <span class="s1">np.array([</span><span class="s5">0xFFFFFFFF</span><span class="s3">, </span><span class="s5">0xFFFFFFFF</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span>
<span class="s1">]):</span>
  <span class="s1">define(</span>
      <span class="s4">&quot;random_split&quot;</span><span class="s3">,</span>
      <span class="s4">f&quot;i=</span><span class="s3">{</span><span class="s1">key_i</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">jax.jit(</span><span class="s3">lambda </span><span class="s1">key: jax.random.split(key</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">, </span><span class="s1">[key]</span><span class="s3">,</span>
      <span class="s1">dtype=key.dtype)</span>

<span class="s0"># A few library functions from jax.random</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">((</span><span class="s5">8</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)):</span>
    <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">range(len(shape)):</span>
      <span class="s1">define(</span>
          <span class="s4">&quot;random_categorical&quot;</span><span class="s3">,</span>
          <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
          <span class="s1">jax.random.categorical</span><span class="s3">,</span>
          <span class="s1">[np.array([</span><span class="s5">42</span><span class="s3">, </span><span class="s5">43</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">, </span><span class="s1">RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
           <span class="s1">StaticArg(axis)]</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">axis=axis)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">32</span><span class="s3">,</span><span class="s1">)):</span>
    <span class="s1">define(</span>
        <span class="s4">&quot;random_uniform&quot;</span><span class="s3">,</span>
        <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">jax.random.uniform</span><span class="s3">,</span>
        <span class="s1">[np.array([</span><span class="s5">42</span><span class="s3">, </span><span class="s5">43</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
         <span class="s1">StaticArg(shape)</span><span class="s3">, </span><span class="s1">StaticArg(dtype)]</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_integer:</span>
  <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">32</span><span class="s3">,</span><span class="s1">)):</span>
    <span class="s1">maxval = {</span>
        <span class="s1">np.uint8: </span><span class="s5">256</span><span class="s3">,   </span><span class="s0"># Borderline</span>
    <span class="s1">}.get(dtype</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span>
    <span class="s1">define(</span>
        <span class="s4">&quot;random_randint&quot;</span><span class="s3">,</span>
        <span class="s4">f&quot;shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s1">jax.random.randint</span><span class="s3">,</span>
        <span class="s1">[np.array([</span><span class="s5">42</span><span class="s3">, </span><span class="s5">43</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.uint32)</span><span class="s3">,</span>
         <span class="s1">StaticArg(shape)</span><span class="s3">,</span>
         <span class="s1">StaticArg(-</span><span class="s5">5</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># minval</span>
         <span class="s1">StaticArg(maxval)</span><span class="s3">,</span>
         <span class="s1">StaticArg(dtype)]</span><span class="s3">,</span>
        <span class="s1">dtype=dtype)</span>

<span class="s3">def </span><span class="s1">_make_clamp_harness(name</span><span class="s3">,</span>
                        <span class="s1">*</span><span class="s3">,</span>
                        <span class="s1">min_shape=()</span><span class="s3">,</span>
                        <span class="s1">operand_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">max_shape=()</span><span class="s3">,</span>
                        <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                        <span class="s1">min_max=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">min_arr</span><span class="s3">, </span><span class="s1">max_arr = (</span>
      <span class="s1">min_max </span><span class="s3">if </span><span class="s1">min_max </span><span class="s3">is not None else</span>
      <span class="s1">[RandArg(min_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
       <span class="s1">RandArg(max_shape</span><span class="s3">, </span><span class="s1">dtype)])</span>
  <span class="s1">define(</span>
      <span class="s1">lax.clamp_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_min=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(min_arr.shape</span><span class="s3">, </span><span class="s1">min_arr.dtype)</span><span class="s3">}</span><span class="s4">_operand=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(operand_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_max=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(max_arr.shape</span><span class="s3">, </span><span class="s1">max_arr.dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s1">lax.clamp</span><span class="s3">, </span><span class="s1">[min_arr</span><span class="s3">, </span><span class="s1">RandArg(operand_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">max_arr]</span><span class="s3">,</span>
      <span class="s1">min_shape=min_arr.shape</span><span class="s3">,</span>
      <span class="s1">operand_shape=operand_shape</span><span class="s3">,</span>
      <span class="s1">max_shape=max_arr.shape</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=[</span>
          <span class="s1">Limitation(</span>
              <span class="s4">&quot;unimplemented&quot;</span><span class="s3">,</span>
              <span class="s1">dtypes=[np.bool_</span><span class="s3">, </span><span class="s1">np.complex64</span><span class="s3">, </span><span class="s1">np.complex128])]</span><span class="s3">,</span>
  <span class="s1">)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">set(jtu.dtypes.all):</span>
  <span class="s1">_make_clamp_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate broadcasting of min/max arrays</span>
<span class="s3">for </span><span class="s1">min_shape</span><span class="s3">, </span><span class="s1">operand_shape</span><span class="s3">, </span><span class="s1">max_shape </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no broadcasting for max</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">())</span><span class="s3">,  </span><span class="s0"># no broadcasting for min</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no broadcasting</span>
<span class="s1">]:</span>
  <span class="s1">_make_clamp_harness(</span>
      <span class="s4">&quot;broadcasting&quot;</span><span class="s3">,</span>
      <span class="s1">min_shape=min_shape</span><span class="s3">,</span>
      <span class="s1">max_shape=max_shape</span><span class="s3">,</span>
      <span class="s1">operand_shape=operand_shape)</span>

<span class="s0"># Validate clamping when minval &gt; maxval, and when minval &lt; maxval</span>
<span class="s3">for </span><span class="s1">is_ordered</span><span class="s3">, </span><span class="s1">min_arr</span><span class="s3">, </span><span class="s1">max_arr </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s3">False, </span><span class="s1">np.array(</span><span class="s5">4.</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s1">np.array(</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">dtype=np.float32))</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">True, </span><span class="s1">np.array(</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span><span class="s3">, </span><span class="s1">np.array(</span><span class="s5">4.</span><span class="s3">, </span><span class="s1">dtype=np.float32))</span>
<span class="s1">]:</span>
  <span class="s1">_make_clamp_harness(</span>
      <span class="s4">f&quot;order=</span><span class="s3">{</span><span class="s1">is_ordered</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">min_max=(min_arr</span><span class="s3">, </span><span class="s1">max_arr)</span><span class="s3">, </span><span class="s1">dtype=np.float32)</span>


<span class="s3">def </span><span class="s1">_make_dot_general_harness(name</span><span class="s3">,</span>
                              <span class="s1">*</span><span class="s3">,</span>
                              <span class="s1">lhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s1">rhs_shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                              <span class="s1">precision=</span><span class="s3">None,</span>
                              <span class="s1">dimension_numbers=(((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">()))</span><span class="s3">,</span>
                              <span class="s1">preferred_element_type=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">suffix = </span><span class="s4">&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">precision </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">suffix += </span><span class="s4">f&quot;_</span><span class="s3">{</span><span class="s1">precision=</span><span class="s3">}</span><span class="s4">&quot;</span>
  <span class="s3">if </span><span class="s1">preferred_element_type </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">suffix += </span><span class="s4">f&quot;_preferred=</span><span class="s3">{</span><span class="s1">jtu.dtype_str(preferred_element_type)</span><span class="s3">}</span><span class="s4">&quot;</span>

  <span class="s1">define(</span>
      <span class="s1">lax.dot_general_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_dimensionnumbers=</span><span class="s3">{</span><span class="s1">dimension_numbers</span><span class="s3">}{</span><span class="s1">suffix</span><span class="s3">}</span><span class="s4">&quot;</span>
      <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">lax.dot_general</span><span class="s3">,</span>
      <span class="s1">[</span>
          <span class="s1">RandArg(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">RandArg(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
          <span class="s1">StaticArg(dimension_numbers)</span><span class="s3">,</span>
          <span class="s1">StaticArg(precision)</span><span class="s3">,</span>
          <span class="s1">StaticArg(preferred_element_type)</span>
      <span class="s1">]</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
      <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
      <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
      <span class="s1">precision=precision</span><span class="s3">,</span>
      <span class="s1">preferred_element_type=preferred_element_type</span><span class="s3">,</span>
      <span class="s1">jax_unimplemented=[</span>
          <span class="s1">Limitation(</span><span class="s4">&quot;preferred_element_type must match dtype for floating point&quot;</span><span class="s3">,</span>
                     <span class="s1">devices=</span><span class="s4">&quot;gpu&quot;</span><span class="s3">,</span>
                     <span class="s1">dtypes=[np.float16</span><span class="s3">, </span><span class="s1">dtypes.bfloat16</span><span class="s3">, </span><span class="s1">np.float32</span><span class="s3">, </span><span class="s1">np.float64</span><span class="s3">, </span><span class="s1">np.complex64</span><span class="s3">, </span><span class="s1">np.complex128]</span><span class="s3">,</span>
                     <span class="s1">enabled=(preferred_element_type </span><span class="s3">is not None and </span><span class="s1">preferred_element_type != dtype))</span>
      <span class="s1">]</span>
  <span class="s1">)</span>


<span class="s0"># There are two execution paths in the conversion of dot_general. The main path</span>
<span class="s0"># uses tf.einsum, while special cases use tf.linalg.matmul. For that reason,</span>
<span class="s0"># the below tests are designed to perform the same checks on both execution</span>
<span class="s0"># paths.</span>
<span class="s0"># Validate dtypes and precision</span>
<span class="s0"># This first harness runs the tests for all dtypes and precisions using</span>
<span class="s0"># default values for all the other parameters. Variations of other parameters</span>
<span class="s0"># can thus safely skip testing their corresponding default value.</span>

<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s3">for </span><span class="s1">precision </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s3">None, </span><span class="s1">lax.Precision.DEFAULT</span><span class="s3">, </span><span class="s1">lax.Precision.HIGH</span><span class="s3">, </span><span class="s1">lax.Precision.HIGHEST</span>
  <span class="s1">]:</span>
    <span class="s3">for </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
        <span class="s1">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">())))</span><span class="s3">,</span>
        <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))))</span><span class="s3">,</span>
        <span class="s0"># Some batch dimensions</span>
        <span class="s1">((</span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">7</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))))</span><span class="s3">,</span>
    <span class="s1">]:</span>
      <span class="s1">_make_dot_general_harness(</span>
          <span class="s4">&quot;dtypes_and_precision&quot;</span><span class="s3">,</span>
          <span class="s1">precision=precision</span><span class="s3">,</span>
          <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
          <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
          <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
          <span class="s1">dtype=dtype)</span>

<span class="s0"># The other tests are only for float32.</span>
<span class="s0"># Validate batch dimensions</span>
<span class="s3">for </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s0"># Unique pattern that can go through tf.linalg.matmul</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))))</span><span class="s3">,</span>
    <span class="s0"># Main path with out of order batch dimensions</span>
    <span class="s1">((</span><span class="s5">8</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">, </span><span class="s1">((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))))</span>
<span class="s1">]:</span>
  <span class="s1">_make_dot_general_harness(</span>
      <span class="s4">&quot;batch_dimensions&quot;</span><span class="s3">,</span>
      <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
      <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
      <span class="s1">dimension_numbers=dimension_numbers)</span>

<span class="s0"># Validate squeezing behavior for matmul path</span>
<span class="s3">for </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape</span><span class="s3">, </span><span class="s1">dimension_numbers </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">())))</span><span class="s3">,  </span><span class="s0"># (1, 4) -&gt; (4,)</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">())))</span><span class="s3">,  </span><span class="s0"># (4, 1) -&gt; (4,)</span>
    <span class="s1">((</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">())))</span><span class="s3">,  </span><span class="s0"># (1, 1) -&gt; ()</span>
<span class="s1">]:</span>
  <span class="s1">_make_dot_general_harness(</span>
      <span class="s4">&quot;squeeze&quot;</span><span class="s3">,</span>
      <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
      <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
      <span class="s1">dimension_numbers=dimension_numbers)</span>

<span class="s0"># Validate preferred element type</span>
<span class="s0"># From lax_test.py</span>
<span class="s1">preferred_type_combinations = [(np.float16</span><span class="s3">, </span><span class="s1">np.float16)</span><span class="s3">, </span><span class="s1">(np.float16</span><span class="s3">,</span>
                                                          <span class="s1">np.float32)</span><span class="s3">,</span>
                               <span class="s1">(np.float16</span><span class="s3">, </span><span class="s1">np.float64)</span><span class="s3">,</span>
                               <span class="s1">(dtypes.bfloat16</span><span class="s3">, </span><span class="s1">np.float32)</span><span class="s3">,</span>
                               <span class="s1">(dtypes.bfloat16</span><span class="s3">, </span><span class="s1">np.float64)</span><span class="s3">,</span>
                               <span class="s1">(np.float32</span><span class="s3">, </span><span class="s1">np.float32)</span><span class="s3">,</span>
                               <span class="s1">(np.float32</span><span class="s3">, </span><span class="s1">np.float64)</span><span class="s3">, </span><span class="s1">(np.int8</span><span class="s3">, </span><span class="s1">np.int16)</span><span class="s3">,</span>
                               <span class="s1">(np.int8</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">, </span><span class="s1">(np.int8</span><span class="s3">, </span><span class="s1">np.int64)</span><span class="s3">,</span>
                               <span class="s1">(np.int16</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">, </span><span class="s1">(np.int16</span><span class="s3">, </span><span class="s1">np.int64)</span><span class="s3">,</span>
                               <span class="s1">(np.int32</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">, </span><span class="s1">(np.int32</span><span class="s3">, </span><span class="s1">np.int64)</span><span class="s3">,</span>
                               <span class="s1">(np.complex64</span><span class="s3">, </span><span class="s1">np.complex128)]</span>

<span class="s3">for </span><span class="s1">lhs_shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)]:</span>
  <span class="s3">for </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">6</span><span class="s1">)]:</span>
    <span class="s3">for </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">preferred_element_type </span><span class="s3">in </span><span class="s1">preferred_type_combinations:</span>
      <span class="s1">_make_dot_general_harness(</span>
          <span class="s4">&quot;preferred&quot;</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
          <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
          <span class="s1">dimension_numbers=(((len(lhs_shape) - </span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">()))</span><span class="s3">,</span>
          <span class="s1">preferred_element_type=preferred_element_type)</span>


<span class="s3">def </span><span class="s1">_make_concatenate_harness(name</span><span class="s3">,</span>
                              <span class="s1">*</span><span class="s3">,</span>
                              <span class="s1">shapes=[(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)]</span><span class="s3">,</span>
                              <span class="s1">dimension=</span><span class="s5">0</span><span class="s3">,</span>
                              <span class="s1">dtype=np.float32):</span>
  <span class="s1">shapes_str = </span><span class="s4">&quot;_&quot;</span><span class="s1">.join(jtu.format_shape_dtype_string(s</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">shapes)</span>
  <span class="s1">define(</span>
      <span class="s1">lax.concatenate_p</span><span class="s3">,</span>
      <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_shapes=</span><span class="s3">{</span><span class="s1">shapes_str</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">dimension=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">*args: lax.concatenate_p.bind(*args</span><span class="s3">, </span><span class="s1">dimension=dimension)</span><span class="s3">,</span>
      <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">shapes]</span><span class="s3">,</span>
      <span class="s1">shapes=shapes</span><span class="s3">,</span>
      <span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">dimension=dimension)</span>


<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all:</span>
  <span class="s1">_make_concatenate_harness(</span><span class="s4">&quot;dtypes&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s0"># Validate dimension; non-major axis</span>
<span class="s1">_make_concatenate_harness(</span><span class="s4">&quot;dimension&quot;</span><span class="s3">, </span><span class="s1">dimension=</span><span class="s5">1</span><span class="s1">)</span>

<span class="s0"># Validate &gt; 2 operands</span>
<span class="s3">for </span><span class="s1">shapes </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">[(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)]</span><span class="s3">,  </span><span class="s0"># 3 operands</span>
<span class="s1">]:</span>
  <span class="s1">_make_concatenate_harness(</span><span class="s4">&quot;nb_operands&quot;</span><span class="s3">, </span><span class="s1">shapes=shapes)</span>


<span class="s3">def </span><span class="s1">_make_conv_harness(name</span><span class="s3">,</span>
                       <span class="s1">*</span><span class="s3">,</span>
                       <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">dtype=np.float32</span><span class="s3">,</span>
                       <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">precision=</span><span class="s3">None,</span>
                       <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,</span>
                       <span class="s1">lhs_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">rhs_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">feature_group_count=</span><span class="s5">1</span><span class="s3">,</span>
                       <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NCHW&quot;</span><span class="s3">, </span><span class="s4">&quot;OIHW&quot;</span><span class="s3">, </span><span class="s4">&quot;NCHW&quot;</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">batch_group_count=</span><span class="s5">1</span><span class="s3">,</span>
                       <span class="s1">preferred_element_type=</span><span class="s3">None,</span>
                       <span class="s1">works_without_xla=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">enable_xla_cases = [</span><span class="s3">True, False</span><span class="s1">] </span><span class="s3">if </span><span class="s1">works_without_xla </span><span class="s3">else </span><span class="s1">[</span><span class="s3">True</span><span class="s1">]</span>

  <span class="s3">for </span><span class="s1">enable_xla </span><span class="s3">in </span><span class="s1">enable_xla_cases:</span>
    <span class="s1">define(</span>
        <span class="s1">lax.conv_general_dilated_p</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">_lhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_rhs=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_windowstrides=</span><span class="s3">{</span><span class="s1">window_strides</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">padding=</span><span class="s3">!s}</span><span class="s4">_lhsdilation=</span><span class="s3">{</span><span class="s1">lhs_dilation</span><span class="s3">}</span><span class="s4">_rhsdilation=</span><span class="s3">{</span><span class="s1">rhs_dilation</span><span class="s3">}</span><span class="s4">_dimensionnumbers=</span><span class="s3">{</span><span class="s1">dimension_numbers</span><span class="s3">}</span><span class="s4">_featuregroupcount=</span><span class="s3">{</span><span class="s1">feature_group_count</span><span class="s3">}</span><span class="s4">_batchgroupcount=</span><span class="s3">{</span><span class="s1">batch_group_count</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">precision=</span><span class="s3">}</span><span class="s4">_preferred=</span><span class="s3">{</span><span class="s1">jtu.dtype_str(preferred_element_type)</span><span class="s3">}</span><span class="s4">_enablexla=</span><span class="s3">{</span><span class="s1">enable_xla</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s1">.replace(</span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lax.conv_general_dilated</span><span class="s3">,</span>
        <span class="s1">[</span>
            <span class="s1">RandArg(lhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
            <span class="s1">RandArg(rhs_shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">,</span>
            <span class="s1">StaticArg(window_strides)</span><span class="s3">,</span>
            <span class="s1">StaticArg(padding)</span><span class="s3">,</span>
            <span class="s1">StaticArg(lhs_dilation)</span><span class="s3">,</span>
            <span class="s1">StaticArg(rhs_dilation)</span><span class="s3">,</span>
            <span class="s1">StaticArg(dimension_numbers)</span><span class="s3">,</span>
            <span class="s1">StaticArg(feature_group_count)</span><span class="s3">,</span>
            <span class="s1">StaticArg(batch_group_count)</span><span class="s3">,</span>
            <span class="s1">StaticArg(precision)</span><span class="s3">,</span>
            <span class="s1">StaticArg(preferred_element_type)</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
        <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">,</span>
        <span class="s1">rhs_dilation=rhs_dilation</span><span class="s3">,</span>
        <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
        <span class="s1">feature_group_count=feature_group_count</span><span class="s3">,</span>
        <span class="s1">batch_group_count=batch_group_count</span><span class="s3">,</span>
        <span class="s1">precision=precision</span><span class="s3">,</span>
        <span class="s1">preferred_element_type=preferred_element_type</span><span class="s3">,</span>
        <span class="s1">enable_xla=enable_xla</span><span class="s3">,</span>
        <span class="s1">jax_unimplemented=[</span>
            <span class="s0"># b/183565702 - no integer convolutions for GPU</span>
            <span class="s1">Limitation(</span>
                <span class="s4">&quot;preferred_element_type not implemented for integers&quot;</span><span class="s3">,</span>
                <span class="s1">devices=</span><span class="s4">&quot;gpu&quot;</span><span class="s3">,</span>
                <span class="s1">dtypes=(np.int8</span><span class="s3">, </span><span class="s1">np.int16</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">,</span>
                <span class="s1">enabled=(preferred_element_type </span><span class="s3">in </span><span class="s1">[np.int16</span><span class="s3">, </span><span class="s1">np.int32</span><span class="s3">,</span>
                                                    <span class="s1">np.int64]))</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Validate dtypes and precision</span>
<span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_inexact:</span>
  <span class="s3">for </span><span class="s1">precision </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s3">None, </span><span class="s1">lax.Precision.DEFAULT</span><span class="s3">, </span><span class="s1">lax.Precision.HIGH</span><span class="s3">, </span><span class="s1">lax.Precision.HIGHEST</span>
  <span class="s1">]:</span>
    <span class="s0"># This first harness runs the tests for all dtypes and precisions using</span>
    <span class="s0"># default values for all the other parameters. Variations of other parameters</span>
    <span class="s0"># can thus safely skip testing their corresponding default value.</span>
    <span class="s1">_make_conv_harness(</span>
        <span class="s4">&quot;dtype_precision&quot;</span><span class="s3">,</span>
        <span class="s1">dtype=dtype</span><span class="s3">,</span>
        <span class="s1">precision=precision)</span>


<span class="s0"># Validate preferred_element_type</span>
<span class="s3">for </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">preferred_element_type </span><span class="s3">in </span><span class="s1">preferred_type_combinations:</span>
  <span class="s1">works_without_xla = dtype == np.float32 </span><span class="s3">and </span><span class="s1">preferred_element_type == np.float32</span>
  <span class="s1">_make_conv_harness(</span>
      <span class="s4">&quot;preferred&quot;</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">,</span>
      <span class="s1">preferred_element_type=preferred_element_type</span><span class="s3">,</span>
      <span class="s1">works_without_xla=works_without_xla)</span>

<span class="s0"># Validate variations of feature_group_count and batch_group_count</span>
<span class="s3">for </span><span class="s1">batch_group_count</span><span class="s3">, </span><span class="s1">feature_group_count </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># feature_group_count != 1</span>
    <span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># batch_group_count != 1</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">((</span><span class="s5">2 </span><span class="s1">* batch_group_count</span><span class="s3">, </span><span class="s5">3 </span><span class="s1">* feature_group_count</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,</span>
       <span class="s1">(</span><span class="s5">3 </span><span class="s1">* feature_group_count * batch_group_count</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">))</span>
  <span class="s1">]:</span>
    <span class="s1">_make_conv_harness(</span>
        <span class="s4">&quot;group_counts&quot;</span><span class="s3">,</span>
        <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
        <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">feature_group_count=feature_group_count</span><span class="s3">,</span>
        <span class="s1">batch_group_count=batch_group_count)</span>

<span class="s0"># --- BEGIN Tests for conv_general_dilated with works_without_xla=True ---</span>

<span class="s0"># Validate Conv1D.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;conv1d&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NCH&quot;</span><span class="s3">, </span><span class="s4">&quot;OIH&quot;</span><span class="s3">, </span><span class="s4">&quot;NCH&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s0"># feature_group_count is supported for enable_xla=False only if we are doing a</span>
<span class="s0"># depthwise convolution, i.e.: in_channels == feature_group_count.</span>
<span class="s0"># See explanation of depthwise convolution at</span>
<span class="s0"># https://www.tensorflow.org/xla/operation_semantics#conv_convolution.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;depthwise2d&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;NCHW&quot;: in_channels == 3</span>
    <span class="s1">rhs_shape=(</span><span class="s5">12</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;OIHW&quot;: channel_multiplier = 12/3 = 4</span>
    <span class="s1">feature_group_count=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;depthwise2d_dilated&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;NCHW&quot;: in_channels == 3</span>
    <span class="s1">rhs_shape=(</span><span class="s5">12</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;OIHW&quot;: channel_multiplier = 12/3 = 4</span>
    <span class="s1">feature_group_count=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;depthwise1d&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;NCH&quot;: in_channels == 3</span>
    <span class="s1">rhs_shape=(</span><span class="s5">12</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;OIH&quot;: channel_multiplier = 12/3 = 4</span>
    <span class="s1">feature_group_count=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NCH&quot;</span><span class="s3">, </span><span class="s4">&quot;OIH&quot;</span><span class="s3">, </span><span class="s4">&quot;NCH&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;depthwise1d_dilated&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;NCH&quot;: in_channels == 3</span>
    <span class="s1">rhs_shape=(</span><span class="s5">12</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># &quot;OIH&quot;: channel_multiplier = 12/3 = 4</span>
    <span class="s1">feature_group_count=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NCH&quot;</span><span class="s3">, </span><span class="s4">&quot;OIH&quot;</span><span class="s3">, </span><span class="s4">&quot;NCH&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate variations of window_strides</span>
<span class="s3">for </span><span class="s1">window_strides </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)]:</span>
  <span class="s1">_make_conv_harness(</span>
      <span class="s4">&quot;window_strides&quot;</span><span class="s3">,</span>
      <span class="s1">window_strides=window_strides</span><span class="s3">,</span>
      <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate variations of padding</span>
<span class="s3">for </span><span class="s1">padding </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># padding only one spatial axis</span>
    <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))  </span><span class="s0"># padding on both spatial axes</span>
<span class="s1">]:</span>
  <span class="s1">_make_conv_harness(</span><span class="s4">&quot;padding&quot;</span><span class="s3">, </span><span class="s1">padding=padding</span><span class="s3">, </span><span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate variations of dilations</span>
<span class="s3">for </span><span class="s1">lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation </span><span class="s3">in </span><span class="s1">[</span>
     <span class="s1">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS (atrous)</span>
<span class="s1">]:</span>
  <span class="s1">_make_conv_harness(</span>
      <span class="s4">&quot;dilations&quot;</span><span class="s3">,</span>
      <span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">,</span>
      <span class="s1">rhs_dilation=rhs_dilation</span><span class="s3">,</span>
      <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Simulate a call from lax.conv_transpose.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;conv_tranpose2d_valid_padding&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Simulate a call from lax.conv_transpose.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;conv_tranpose1d_valid_padding&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NHC&quot;</span><span class="s3">, </span><span class="s4">&quot;HIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHC&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;conv_tranpose1d_same_padding&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NHC&quot;</span><span class="s3">, </span><span class="s4">&quot;HIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHC&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;conv_tranpose2d_same_padding&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">lhs_dilation=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Validate rhs &gt; lhs.</span>
<span class="s0"># One dimension of rhs is bigger than lhs.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;rhs_oob&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Effective rhs size is too big after applying rhs_dilation.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;rhs_oob_after_dilation&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_dilation=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># Effective rhs is too big after applying input padding.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;rhs_oob_after_pading&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">64</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">window_strides=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># rhs out of bounds with &quot;SAME&quot; padding.</span>
<span class="s1">_make_conv_harness(</span>
    <span class="s4">&quot;rhs_oob_same_padding&quot;</span><span class="s3">,</span>
    <span class="s1">lhs_shape=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">padding=</span><span class="s4">&quot;SAME&quot;</span><span class="s3">,</span>
    <span class="s1">rhs_shape=(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">dimension_numbers=(</span><span class="s4">&quot;NHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># TF default</span>
    <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s0"># Dimension numbers and corresponding permutation</span>
<span class="s3">for </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">((</span><span class="s4">&quot;NHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># TF default</span>
    <span class="s1">((</span><span class="s4">&quot;NCHW&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># custom</span>
<span class="s1">]:</span>
  <span class="s1">_make_conv_harness(</span>
      <span class="s4">&quot;dimension_numbers&quot;</span><span class="s3">,</span>
      <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
      <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
      <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
      <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s3">for </span><span class="s1">padding</span><span class="s3">, </span><span class="s1">lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;SAME&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;SAME&quot; padding</span>
    <span class="s1">([(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">((</span><span class="s4">&quot;NHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NHWC&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># TF default</span>
      <span class="s1">((</span><span class="s4">&quot;NCHW&quot;</span><span class="s3">, </span><span class="s4">&quot;HWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NCHW&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">28</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s1">))</span><span class="s3">,</span>
  <span class="s1">]:</span>
    <span class="s1">_make_conv_harness(</span>
        <span class="s4">&quot;tf_conversion_path_2d&quot;</span><span class="s3">,</span>
        <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
        <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">,</span>
        <span class="s1">rhs_dilation=rhs_dilation</span><span class="s3">,</span>
        <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s3">for </span><span class="s1">padding</span><span class="s3">, </span><span class="s1">lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;SAME&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;SAME&quot; padding</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s1">((</span><span class="s4">&quot;NWC&quot;</span><span class="s3">, </span><span class="s4">&quot;WIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NWC&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># TF default</span>
  <span class="s1">]:</span>
    <span class="s1">_make_conv_harness(</span>
        <span class="s4">&quot;tf_conversion_path_1d&quot;</span><span class="s3">,</span>
        <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
        <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">,</span>
        <span class="s1">rhs_dilation=rhs_dilation</span><span class="s3">,</span>
        <span class="s1">works_without_xla=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># --- END Tests for conv_general_dilated with works_without_xla=True ---</span>

<span class="s3">for </span><span class="s1">lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s0"># Note: LHS dilation does work for enable_xla=False, but only if</span>
    <span class="s0"># padding=='VALID' (see test above for conv_transpose2d_valid_padding).</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on LHS (transposed)</span>
    <span class="s1">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))   </span><span class="s0"># dilation on both LHS and RHS (transposed &amp; atrous)</span>
<span class="s1">]:</span>
  <span class="s1">_make_conv_harness(</span>
      <span class="s4">&quot;dilations&quot;</span><span class="s3">, </span><span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation=rhs_dilation)</span>


<span class="s3">for </span><span class="s1">padding</span><span class="s3">, </span><span class="s1">lhs_dilation</span><span class="s3">, </span><span class="s1">rhs_dilation </span><span class="s3">in </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># no dilation with &quot;SAME&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;VALID&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span>
                          <span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;VALID&quot; padding</span>
    <span class="s1">(</span><span class="s4">&quot;SAME&quot;</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># dilation only on RHS with &quot;SAME&quot; padding</span>
<span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">lhs_shape</span><span class="s3">, </span><span class="s1">rhs_shape </span><span class="s3">in </span><span class="s1">[</span>
      <span class="s0"># TF default</span>
      <span class="s1">((</span><span class="s4">&quot;NDHWC&quot;</span><span class="s3">, </span><span class="s4">&quot;DHWIO&quot;</span><span class="s3">, </span><span class="s4">&quot;NDHWC&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">16</span><span class="s1">))</span><span class="s3">,</span>
  <span class="s1">]:</span>
    <span class="s1">_make_conv_harness(</span>
        <span class="s4">&quot;tf_conversion_path_3d&quot;</span><span class="s3">,</span>
        <span class="s1">lhs_shape=lhs_shape</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">rhs_shape=rhs_shape</span><span class="s3">,</span>
        <span class="s1">dimension_numbers=dimension_numbers</span><span class="s3">,</span>
        <span class="s1">window_strides=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">lhs_dilation=lhs_dilation</span><span class="s3">,</span>
        <span class="s1">rhs_dilation=rhs_dilation)</span>

<span class="s1">key_types = [((</span><span class="s5">4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.uint32)]</span>
<span class="s3">if </span><span class="s1">config.jax_enable_x64:</span>
  <span class="s1">key_types.append(((</span><span class="s5">2</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.uint64))</span>

<span class="s3">for </span><span class="s1">algorithm </span><span class="s3">in </span><span class="s1">[lax.RandomAlgorithm.RNG_THREE_FRY</span><span class="s3">,</span>
                  <span class="s1">lax.RandomAlgorithm.RNG_PHILOX</span><span class="s3">,</span>
                  <span class="s1">lax.RandomAlgorithm.RNG_DEFAULT]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">[np.uint32</span><span class="s3">, </span><span class="s1">np.uint64]:</span>
    <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)]:</span>
      <span class="s3">for </span><span class="s1">key_shape</span><span class="s3">, </span><span class="s1">key_dtype </span><span class="s3">in </span><span class="s1">key_types:</span>
        <span class="s1">define(</span>
            <span class="s1">lax.rng_bit_generator_p</span><span class="s3">,</span>
            <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">key_dtype=</span><span class="s3">}</span><span class="s4">_shape=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">_</span><span class="s3">{</span><span class="s1">algorithm=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s3">lambda </span><span class="s1">key</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">algorithm: lax.rng_bit_generator(key</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">,</span>
                                                                       <span class="s1">algorithm=algorithm)</span><span class="s3">,</span>
            <span class="s1">[RandArg(key_shape</span><span class="s3">, </span><span class="s1">key_dtype)</span><span class="s3">,</span>
             <span class="s1">StaticArg(shape)</span><span class="s3">, </span><span class="s1">StaticArg(dtype)</span><span class="s3">, </span><span class="s1">StaticArg(algorithm)]</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">dtype=dtype</span><span class="s3">,</span>
            <span class="s1">algorithm=algorithm)</span>

<span class="s3">def </span><span class="s1">_make_iota_2x32_shape_harness(shape):</span>
  <span class="s1">shapestr = </span><span class="s4">','</span><span class="s1">.join(str(dim) </span><span class="s3">for </span><span class="s1">dim </span><span class="s3">in </span><span class="s1">shape)</span>
  <span class="s1">define(</span>
      <span class="s1">prng.iota_2x32_shape_p</span><span class="s3">,</span>
      <span class="s4">f&quot;shape=(</span><span class="s3">{</span><span class="s1">shapestr</span><span class="s3">}</span><span class="s4">)&quot;</span><span class="s3">,</span>
      <span class="s3">lambda </span><span class="s1">shape: prng.iota_2x32_shape_p.bind(shape=shape)</span><span class="s3">,</span>
      <span class="s1">[StaticArg(shape)]</span><span class="s3">,</span>
      <span class="s1">dtype=jnp.uint32</span><span class="s3">,</span>
      <span class="s1">shape=shape)</span>

<span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">3</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)]:</span>
  <span class="s1">_make_iota_2x32_shape_harness(shape)</span>


<span class="s3">for </span><span class="s1">in_dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
  <span class="s3">for </span><span class="s1">out_dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
    <span class="s1">out_iinfo = dtypes.finfo(out_dtype)</span>
    <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[()</span><span class="s3">, </span><span class="s1">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">7</span><span class="s1">)]:</span>
        <span class="s1">define(</span>
            <span class="s1">lax.reduce_precision_p</span><span class="s3">,</span>
            <span class="s4">f&quot;in=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">in_dtype)</span><span class="s3">}</span><span class="s4">_out=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">out_dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">exp_bits</span><span class="s3">, </span><span class="s1">mant_bits: lax.reduce_precision(x</span><span class="s3">,</span>
                                                                <span class="s1">exponent_bits=exp_bits</span><span class="s3">,</span>
                                                                <span class="s1">mantissa_bits=mant_bits)</span><span class="s3">,</span>
            <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">in_dtype)</span><span class="s3">,</span>
             <span class="s1">StaticArg(out_iinfo.nexp)</span><span class="s3">, </span><span class="s1">StaticArg(out_iinfo.nmant)]</span><span class="s3">,</span>
            <span class="s1">shape=shape</span><span class="s3">,</span>
            <span class="s1">dtype=in_dtype</span><span class="s3">,</span>
            <span class="s1">out_dtype=out_dtype)</span>

<span class="s0"># approx_top_k</span>
<span class="s3">for </span><span class="s1">is_max </span><span class="s3">in </span><span class="s1">[</span><span class="s3">True, False</span><span class="s1">]:</span>
  <span class="s3">for </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">jtu.dtypes.all_floating:</span>
    <span class="s0"># There are different lowerings for sizes &lt; 1024 for rank-1 and 128 for higher</span>
    <span class="s0"># rank.</span>
    <span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">[(</span><span class="s5">32</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2048</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">16</span><span class="s3">, </span><span class="s5">256</span><span class="s1">)]:</span>
      <span class="s1">define(</span>
          <span class="s1">lax.approx_top_k_p</span><span class="s3">,</span>
          <span class="s4">f&quot;large=</span><span class="s3">{</span><span class="s1">np.prod(shape) &gt;= </span><span class="s5">1024</span><span class="s3">}</span><span class="s4">_max=</span><span class="s3">{</span><span class="s1">is_max</span><span class="s3">}</span><span class="s4">_op=</span><span class="s3">{</span><span class="s1">jtu.format_shape_dtype_string(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s3">,</span>
          <span class="s3">lambda </span><span class="s1">operand</span><span class="s3">, </span><span class="s1">is_max: lax.approx_top_k_p.bind(</span>
              <span class="s1">operand</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">reduction_dimension=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">recall_target=</span><span class="s5">0.95</span><span class="s3">,</span>
              <span class="s1">is_max_k=is_max</span><span class="s3">,</span>
              <span class="s1">reduction_input_size_override=-</span><span class="s5">1</span><span class="s3">,</span>
              <span class="s1">aggregate_to_topk=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
          <span class="s1">[RandArg(shape</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">StaticArg(is_max)]</span><span class="s3">,</span>
          <span class="s1">dtype=dtype</span><span class="s3">,</span>
          <span class="s1">is_max=is_max</span><span class="s3">,</span>
          <span class="s1">shape=shape)</span>
</pre>
</body>
</html>