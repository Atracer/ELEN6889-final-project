<html>
<head>
<title>custom_batching.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
custom_batching.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Optional</span>

<span class="s2">import </span><span class="s1">jax</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">tree_util</span>
<span class="s2">from </span><span class="s1">jax.tree_util </span><span class="s2">import </span><span class="s1">(tree_flatten</span><span class="s2">, </span><span class="s1">tree_map</span><span class="s2">, </span><span class="s1">tree_structure</span><span class="s2">,</span>
                           <span class="s1">tree_unflatten</span><span class="s2">, </span><span class="s1">treedef_tuple)</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">custom_api_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">source_info_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">jax._src.api_util </span><span class="s2">import </span><span class="s1">flatten_fun_nokwargs</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">ad</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">batching</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters.batching </span><span class="s2">import </span><span class="s1">not_mapped</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">mlir</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">partial_eval </span><span class="s2">as </span><span class="s1">pe</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">xla</span>


<span class="s1">source_info_util.register_exclusion(__file__)</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>


<span class="s1">map</span><span class="s2">, </span><span class="s1">unsafe_map = util.safe_map</span><span class="s2">, </span><span class="s1">map</span>
<span class="s1">zip</span><span class="s2">, </span><span class="s1">unsafe_zip = util.safe_zip</span><span class="s2">, </span><span class="s1">zip</span>


<span class="s1">@custom_api_util.register_custom_decorator_type</span>
<span class="s2">class </span><span class="s1">custom_vmap:</span>
  <span class="s1">fun: Callable</span>
  <span class="s1">vmap_rule: Optional[Callable]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fun: Callable):</span>
    <span class="s1">functools.update_wrapper(self</span><span class="s2">, </span><span class="s1">fun)</span>
    <span class="s1">self.fun = fun  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">self.vmap_rule = </span><span class="s2">None</span>

  <span class="s1">__getattr__ = custom_api_util.forward_attr</span>

  <span class="s2">def </span><span class="s1">def_vmap(self</span><span class="s2">, </span><span class="s1">vmap_rule: Callable) -&gt; Callable:</span>
    <span class="s1">self.vmap_rule = vmap_rule</span>
    <span class="s2">return </span><span class="s1">vmap_rule</span>

  <span class="s1">@traceback_util.api_boundary</span>
  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">assert not </span><span class="s1">kwargs</span>
    <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(args)</span>
    <span class="s1">flat_fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(lu.wrap_init(self.fun)</span><span class="s2">, </span><span class="s1">in_tree)</span>
    <span class="s1">in_avals = [core.raise_to_shaped(core.get_aval(x)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args_flat]</span>
    <span class="s1">debug = pe.debug_info(self.fun</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, False, </span><span class="s3">&quot;custom_vmap&quot;</span><span class="s1">)</span>
    <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(flat_fun</span><span class="s2">, </span><span class="s1">in_avals</span><span class="s2">, </span><span class="s1">debug)</span>
    <span class="s1">closed_call = core.ClosedJaxpr(pe.convert_constvars_jaxpr(jaxpr)</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s1">in_tree = treedef_tuple((tree_structure(consts)</span><span class="s2">, </span><span class="s1">in_tree))</span>
    <span class="s1">out_flat = custom_vmap_p.bind(*consts</span><span class="s2">, </span><span class="s1">*args_flat</span><span class="s2">,</span>
                                  <span class="s1">call=closed_call</span><span class="s2">,</span>
                                  <span class="s1">rule=ClosedRule(self.vmap_rule)</span><span class="s2">,</span>
                                  <span class="s1">in_tree=in_tree</span><span class="s2">,</span>
                                  <span class="s1">out_tree=out_tree())</span>
    <span class="s2">return </span><span class="s1">tree_unflatten(out_tree()</span><span class="s2">, </span><span class="s1">out_flat)</span>


<span class="s0">### utils</span>

<span class="s0"># Define a class, instead of making a function closing over `rule`, so</span>
<span class="s0"># that we can override __str__</span>
<span class="s2">class </span><span class="s1">ClosedRule:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rule):</span>
    <span class="s1">functools.update_wrapper(self</span><span class="s2">, </span><span class="s1">rule)</span>
    <span class="s1">self.rule = rule</span>

  <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">all_in_batched</span><span class="s2">, </span><span class="s1">*all_args):</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">args = all_args</span>
    <span class="s1">consts_batched</span><span class="s2">, </span><span class="s1">in_batched = all_in_batched</span>
    <span class="s2">assert not </span><span class="s1">any(tree_util.tree_leaves(consts_batched))</span><span class="s2">, </span><span class="s1">consts_batched</span>
    <span class="s2">return </span><span class="s1">call_rule(self.rule</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">in_batched</span><span class="s2">, </span><span class="s1">args)</span>

  <span class="s2">def </span><span class="s1">__str__(self):</span>
    <span class="s2">return </span><span class="s1">str(self.rule)</span>

<span class="s2">def </span><span class="s1">ensure_list(xs):</span>
  <span class="s2">return </span><span class="s1">xs </span><span class="s2">if </span><span class="s1">type(xs) </span><span class="s2">is </span><span class="s1">list </span><span class="s2">else </span><span class="s1">list(xs)</span>

<span class="s2">def </span><span class="s1">rule_name(rule):</span>
  <span class="s2">return </span><span class="s1">getattr(rule</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s3">'&lt;unnamed rule&gt;'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">call_rule(rule</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">in_batched</span><span class="s2">, </span><span class="s1">args):</span>
  <span class="s2">return </span><span class="s1">rule(axis_size</span><span class="s2">, </span><span class="s1">ensure_list(in_batched)</span><span class="s2">, </span><span class="s1">*args)</span>

<span class="s2">def </span><span class="s1">check_vmap_rule_trees(rule</span><span class="s2">, </span><span class="s1">original_out_tree</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">out_batched_tree):</span>
  <span class="s2">if </span><span class="s1">out_tree != out_batched_tree:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'structure of output value and output batching specification returned '</span>
        <span class="s3">f'by custom vmap rule (</span><span class="s2">{</span><span class="s1">rule_name(rule)</span><span class="s2">}</span><span class="s3">) do not match.</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s3">f'Output values: </span><span class="s2">{</span><span class="s1">out_tree</span><span class="s2">}\n</span><span class="s3">'</span>
        <span class="s3">f'Batching spec: </span><span class="s2">{</span><span class="s1">out_batched_tree</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">out_tree != original_out_tree:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">f'structure of output returned by custom vmap rule (</span><span class="s2">{</span><span class="s1">rule_name(rule)</span><span class="s2">}</span><span class="s3">) '</span>
        <span class="s3">'does not match that of original custom-vmapped function.</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s3">f'Original output: </span><span class="s2">{</span><span class="s1">original_out_tree</span><span class="s2">}\n</span><span class="s3">'</span>
        <span class="s3">f'Rule output: </span><span class="s2">{</span><span class="s1">out_tree</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

<span class="s0"># Like batching.bdim_at_front, but doesn't broadcast if not mapped</span>
<span class="s2">def </span><span class="s1">maybe_bdim_at_front(x</span><span class="s2">, </span><span class="s1">bdim):</span>
  <span class="s2">if </span><span class="s1">bdim </span><span class="s2">is </span><span class="s1">not_mapped:</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">util.moveaxis(x</span><span class="s2">, </span><span class="s1">bdim</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

<span class="s0"># Like batching.batch except (a) not curried and (b) returns inferred output</span>
<span class="s0"># axes instead of accepting and matching a given spec of output axes. Assumes</span>
<span class="s0"># `f` is pytree-flattened</span>
<span class="s2">def </span><span class="s1">vmap_unrestricted(f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">axis_size):</span>
  <span class="s1">f</span><span class="s2">, </span><span class="s1">out_axes = batching.batch_subtrace(f)</span>
  <span class="s1">f = batching._batch_outer(f</span><span class="s2">, </span><span class="s1">axis_name</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">in_axes</span><span class="s2">,</span>
                            <span class="s1">batching.BatchTrace</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s1">outs = f.call_wrapped(*args)</span>
  <span class="s2">return </span><span class="s1">outs</span><span class="s2">, </span><span class="s1">out_axes()</span>


<span class="s0">### custom_vmap_p rules</span>


<span class="s2">def </span><span class="s1">custom_vmap_impl(*args</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree):</span>
  <span class="s2">del </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree</span>
  <span class="s2">return </span><span class="s1">core.jaxpr_as_fun(call)(*args)</span>


<span class="s2">def </span><span class="s1">custom_vmap_batching(args_flat</span><span class="s2">, </span><span class="s1">dims</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree):</span>
  <span class="s2">del </span><span class="s1">call</span>
  <span class="s1">axis_size</span><span class="s2">, </span><span class="s1">= {x.shape[d] </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">zip(args_flat</span><span class="s2">, </span><span class="s1">dims) </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is not None</span><span class="s1">}</span>
  <span class="s1">args_flat = map(maybe_bdim_at_front</span><span class="s2">, </span><span class="s1">args_flat</span><span class="s2">, </span><span class="s1">dims)</span>
  <span class="s1">flat_in_batched = [d </span><span class="s2">is not </span><span class="s1">not_mapped </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dims]</span>

  <span class="s1">args = tree_unflatten(in_tree</span><span class="s2">, </span><span class="s1">args_flat)</span>
  <span class="s1">in_batched = tree_unflatten(in_tree</span><span class="s2">, </span><span class="s1">flat_in_batched)</span>
  <span class="s1">out</span><span class="s2">, </span><span class="s1">out_batched = call_rule(rule</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">in_batched</span><span class="s2">, </span><span class="s1">args)</span>
  <span class="s1">flat_outs</span><span class="s2">, </span><span class="s1">tree1 = tree_flatten(out)</span>
  <span class="s1">flat_out_batched</span><span class="s2">, </span><span class="s1">tree2 = tree_flatten(out_batched)</span>
  <span class="s1">check_vmap_rule_trees(rule</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">tree1</span><span class="s2">, </span><span class="s1">tree2)</span>
  <span class="s1">flat_out_dims = [</span><span class="s4">0 </span><span class="s2">if </span><span class="s1">b </span><span class="s2">else </span><span class="s1">not_mapped </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">flat_out_batched]</span>
  <span class="s2">return </span><span class="s1">flat_outs</span><span class="s2">, </span><span class="s1">flat_out_dims</span>


<span class="s2">def </span><span class="s1">custom_vmap_abstract_eval(*in_avals</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">**_):</span>
  <span class="s2">return </span><span class="s1">call.out_avals</span>


<span class="s2">def </span><span class="s1">custom_vmap_jvp(primals</span><span class="s2">, </span><span class="s1">tangents</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">call</span><span class="s2">, </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">in_tree</span><span class="s2">, </span><span class="s1">out_tree):</span>
  <span class="s2">def </span><span class="s1">jvp_of_rule_rule(axis_size</span><span class="s2">, </span><span class="s1">in_batched</span><span class="s2">, </span><span class="s1">primals</span><span class="s2">, </span><span class="s1">tangents):</span>
    <span class="s1">in_batched_ps</span><span class="s2">, </span><span class="s1">in_batched_ts = in_batched</span>

    <span class="s1">mutually_batched = tree_map(operator.and_</span><span class="s2">, </span><span class="s1">in_batched_ps</span><span class="s2">, </span><span class="s1">in_batched_ts)</span>
    <span class="s1">extra_batched_ps = tree_map(</span><span class="s2">lambda </span><span class="s1">pb</span><span class="s2">, </span><span class="s1">tb: </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">pb </span><span class="s2">and not </span><span class="s1">tb </span><span class="s2">else None,</span>
                                <span class="s1">in_batched_ps</span><span class="s2">, </span><span class="s1">in_batched_ts)</span>
    <span class="s1">extra_batched_ts = tree_map(</span><span class="s2">lambda </span><span class="s1">pb</span><span class="s2">, </span><span class="s1">tb: </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">tb </span><span class="s2">and not </span><span class="s1">pb </span><span class="s2">else None,</span>
                                <span class="s1">in_batched_ps</span><span class="s2">, </span><span class="s1">in_batched_ts)</span>

    <span class="s1">out_mutually_batched = lu.Store()</span>
    <span class="s1">flat_ps_ts</span><span class="s2">, </span><span class="s1">tree_ps_ts = tree_flatten((primals</span><span class="s2">, </span><span class="s1">tangents))</span>
    <span class="s1">flat_extra_batched_ps_ts</span><span class="s2">, </span><span class="s1">tree_ps_ts2 = tree_flatten(</span>
        <span class="s1">(extra_batched_ps</span><span class="s2">, </span><span class="s1">extra_batched_ts)</span><span class="s2">,</span>
        <span class="s1">is_leaf=</span><span class="s2">lambda </span><span class="s1">x: x </span><span class="s2">is None</span><span class="s1">)</span>

    <span class="s0"># TODO(frostig): assert these also equal:</span>
    <span class="s0">#   treedef_tuple((in_tree, in_tree))</span>
    <span class="s0"># once https://github.com/google/jax/issues/9066 is fixed</span>
    <span class="s2">assert </span><span class="s1">tree_ps_ts == tree_ps_ts2</span>
    <span class="s2">del </span><span class="s1">tree_ps_ts2</span>

    <span class="s2">def </span><span class="s1">to_jvp(*primals):</span>
      <span class="s1">out</span><span class="s2">, </span><span class="s1">out_batched = call_rule(rule</span><span class="s2">, </span><span class="s1">axis_size</span><span class="s2">, </span><span class="s1">mutually_batched</span><span class="s2">, </span><span class="s1">primals)</span>
      <span class="s1">check_vmap_rule_trees(</span>
          <span class="s1">rule</span><span class="s2">, </span><span class="s1">out_tree</span><span class="s2">, </span><span class="s1">tree_structure(out)</span><span class="s2">, </span><span class="s1">tree_structure(out_batched))</span>
      <span class="s1">out_mutually_batched.store(out_batched)</span>
      <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">to_vmap_over_extra_batched_dims(primals</span><span class="s2">, </span><span class="s1">tangents):</span>
      <span class="s2">return </span><span class="s1">jax.jvp(to_jvp</span><span class="s2">, </span><span class="s1">primals</span><span class="s2">, </span><span class="s1">tangents)</span>

    <span class="s1">to_vmap_over_extra_batched_dims_flat</span><span class="s2">, </span><span class="s1">out_tree2 = flatten_fun_nokwargs(</span>
        <span class="s1">lu.wrap_init(to_vmap_over_extra_batched_dims)</span><span class="s2">,</span>
        <span class="s1">tree_ps_ts)</span>

    <span class="s1">flat_out_ps_ts</span><span class="s2">, </span><span class="s1">flat_out_axes = vmap_unrestricted(</span>
        <span class="s1">to_vmap_over_extra_batched_dims_flat</span><span class="s2">, </span><span class="s1">*flat_ps_ts</span><span class="s2">,</span>
        <span class="s1">in_axes=flat_extra_batched_ps_ts</span><span class="s2">,</span>
        <span class="s1">axis_name=core.no_axis_name</span><span class="s2">, </span><span class="s1">axis_size=axis_size)</span>

    <span class="s1">n</span><span class="s2">, </span><span class="s1">ragged = divmod(len(flat_out_ps_ts)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">assert not </span><span class="s1">ragged</span>
    <span class="s1">flat_out_ps</span><span class="s2">, </span><span class="s1">flat_out_ts = flat_out_ps_ts[:n]</span><span class="s2">, </span><span class="s1">flat_out_ps_ts[n:]</span>
    <span class="s1">flat_out_axes_p</span><span class="s2">, </span><span class="s1">flat_out_axes_t = flat_out_axes[:n]</span><span class="s2">, </span><span class="s1">flat_out_axes[n:]</span>
    <span class="s1">flat_out_ps = map(maybe_bdim_at_front</span><span class="s2">, </span><span class="s1">flat_out_ps</span><span class="s2">, </span><span class="s1">flat_out_axes_p)</span>
    <span class="s1">flat_out_extra_batched_ps = [d </span><span class="s2">is not </span><span class="s1">not_mapped </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">flat_out_axes_p]</span>
    <span class="s1">flat_out_ts = map(maybe_bdim_at_front</span><span class="s2">, </span><span class="s1">flat_out_ts</span><span class="s2">, </span><span class="s1">flat_out_axes_t)</span>
    <span class="s1">flat_out_extra_batched_ts = [d </span><span class="s2">is not </span><span class="s1">not_mapped </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">flat_out_axes_t]</span>

    <span class="s1">out_ps</span><span class="s2">, </span><span class="s1">out_ts = tree_unflatten(</span>
        <span class="s1">out_tree2()</span><span class="s2">, </span><span class="s1">[*flat_out_ps</span><span class="s2">, </span><span class="s1">*flat_out_ts])</span>
    <span class="s1">out_extra_batched_ps</span><span class="s2">, </span><span class="s1">out_extra_batched_ts = tree_unflatten(</span>
        <span class="s1">out_tree2()</span><span class="s2">, </span><span class="s1">[*flat_out_extra_batched_ps</span><span class="s2">, </span><span class="s1">*flat_out_extra_batched_ts])</span>

    <span class="s1">out_batched_ps = tree_map(</span>
        <span class="s1">operator.or_</span><span class="s2">, </span><span class="s1">out_mutually_batched.val</span><span class="s2">, </span><span class="s1">out_extra_batched_ps)</span>
    <span class="s1">out_batched_ts = tree_map(</span>
        <span class="s1">operator.or_</span><span class="s2">, </span><span class="s1">out_mutually_batched.val</span><span class="s2">, </span><span class="s1">out_extra_batched_ts)</span>

    <span class="s2">return </span><span class="s1">(out_ps</span><span class="s2">, </span><span class="s1">out_ts)</span><span class="s2">, </span><span class="s1">(out_batched_ps</span><span class="s2">, </span><span class="s1">out_batched_ts)</span>

  <span class="s1">tangents = map(ad.instantiate_zeros</span><span class="s2">, </span><span class="s1">tangents)</span>
  <span class="s1">jvp_call</span><span class="s2">, </span><span class="s1">_ = ad.jvp_jaxpr(call</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True</span><span class="s1">] * len(primals)</span><span class="s2">, True</span><span class="s1">)</span>
  <span class="s1">jvp_in_tree = treedef_tuple((in_tree</span><span class="s2">, </span><span class="s1">in_tree))</span>
  <span class="s1">jvp_out_tree = treedef_tuple((out_tree</span><span class="s2">, </span><span class="s1">out_tree))</span>
  <span class="s1">outs = custom_vmap_p.bind(</span>
      <span class="s1">*primals</span><span class="s2">, </span><span class="s1">*tangents</span><span class="s2">,</span>
      <span class="s1">call=jvp_call</span><span class="s2">, </span><span class="s1">rule=jvp_of_rule_rule</span><span class="s2">,</span>
      <span class="s1">in_tree=jvp_in_tree</span><span class="s2">, </span><span class="s1">out_tree=jvp_out_tree)</span>
  <span class="s2">assert </span><span class="s1">len(outs) % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0</span><span class="s2">, </span><span class="s1">len(outs)</span>
  <span class="s1">out_primals</span><span class="s2">, </span><span class="s1">out_tangents = util.split_list(outs</span><span class="s2">, </span><span class="s1">[len(outs) // </span><span class="s4">2</span><span class="s1">])</span>
  <span class="s2">return </span><span class="s1">out_primals</span><span class="s2">, </span><span class="s1">out_tangents</span>


<span class="s1">custom_vmap_p = core.Primitive(</span><span class="s3">'custom_vmap_call'</span><span class="s1">)</span>
<span class="s1">custom_vmap_p.multiple_results = </span><span class="s2">True</span>
<span class="s1">custom_vmap_p.def_impl(custom_vmap_impl)</span>
<span class="s1">custom_vmap_p.def_abstract_eval(custom_vmap_abstract_eval)</span>
<span class="s1">batching.primitive_batchers[custom_vmap_p] = custom_vmap_batching</span>
<span class="s1">ad.primitive_jvps[custom_vmap_p] = custom_vmap_jvp</span>
<span class="s1">xla.register_initial_style_primitive(custom_vmap_p)</span>
<span class="s1">mlir.register_lowering(custom_vmap_p</span><span class="s2">, </span><span class="s1">mlir.lower_fun(</span>
    <span class="s1">custom_vmap_impl</span><span class="s2">, </span><span class="s1">multiple_results=</span><span class="s2">True</span><span class="s1">))</span>


<span class="s0"># -- custom vmap applications</span>


<span class="s2">def </span><span class="s1">tree_split(mask</span><span class="s2">, </span><span class="s1">tree):</span>
  <span class="s1">lhs = tree_map(</span><span class="s2">lambda </span><span class="s1">l</span><span class="s2">, </span><span class="s1">x: x </span><span class="s2">if </span><span class="s1">l </span><span class="s2">else None, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">tree)</span>
  <span class="s1">rhs = tree_map(</span><span class="s2">lambda </span><span class="s1">l</span><span class="s2">, </span><span class="s1">x: </span><span class="s2">None if </span><span class="s1">l </span><span class="s2">else </span><span class="s1">x</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">tree)</span>
  <span class="s2">return </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span>

<span class="s2">def </span><span class="s1">tree_merge(mask</span><span class="s2">, </span><span class="s1">lhs_tree</span><span class="s2">, </span><span class="s1">rhs_tree):</span>
  <span class="s2">return </span><span class="s1">tree_map(</span><span class="s2">lambda </span><span class="s1">l</span><span class="s2">, </span><span class="s1">x_l</span><span class="s2">, </span><span class="s1">x_r: x_l </span><span class="s2">if </span><span class="s1">l </span><span class="s2">else </span><span class="s1">x_r</span><span class="s2">,</span>
                  <span class="s1">mask</span><span class="s2">, </span><span class="s1">lhs_tree</span><span class="s2">, </span><span class="s1">rhs_tree)</span>

<span class="s2">def </span><span class="s1">sequential_vmap(f):</span>
  <span class="s1">f = custom_vmap(f)</span>

  <span class="s1">@f.def_vmap</span>
  <span class="s2">def </span><span class="s1">rule(axis_size</span><span class="s2">, </span><span class="s1">in_batched</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s2">del </span><span class="s1">axis_size</span>

    <span class="s2">def </span><span class="s1">to_map(mapped_args):</span>
      <span class="s1">args = tree_merge(in_batched</span><span class="s2">, </span><span class="s1">mapped_args</span><span class="s2">, </span><span class="s1">bcast_args)</span>
      <span class="s2">return </span><span class="s1">f(*args)</span>

    <span class="s1">mapped_args</span><span class="s2">, </span><span class="s1">bcast_args = tree_split(in_batched</span><span class="s2">, </span><span class="s1">list(args))</span>
    <span class="s1">out = jax.lax.map(to_map</span><span class="s2">, </span><span class="s1">mapped_args)</span>
    <span class="s1">out_batched = tree_map(</span><span class="s2">lambda </span><span class="s1">_: </span><span class="s2">True, </span><span class="s1">out)</span>
    <span class="s2">return </span><span class="s1">out</span><span class="s2">, </span><span class="s1">out_batched</span>

  <span class="s2">return </span><span class="s1">f</span>
</pre>
</body>
</html>