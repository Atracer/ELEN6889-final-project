<html>
<head>
<title>dtypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dtypes.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2019 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s0"># Array type functions.</span>
<span class="s0">#</span>
<span class="s0"># JAX dtypes differ from NumPy in both:</span>
<span class="s0"># a) their type promotion rules, and</span>
<span class="s0"># b) the set of supported types (e.g., bfloat16),</span>
<span class="s0"># so we need our own implementation that deviates from NumPy in places.</span>


<span class="s2">import </span><span class="s1">builtins</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(cast</span><span class="s2">, </span><span class="s1">overload</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">,</span>
                    <span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">Union)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">ml_dtypes</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">jax._src.typing </span><span class="s2">import </span><span class="s1">DType</span><span class="s2">, </span><span class="s1">DTypeLike</span><span class="s2">, </span><span class="s1">OpaqueDType</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">FLAGS = flags.FLAGS</span>

<span class="s0"># fp8 support</span>
<span class="s1">float8_e4m3fn: Type[np.generic] = ml_dtypes.float8_e4m3fn</span>
<span class="s1">float8_e5m2: Type[np.generic] = ml_dtypes.float8_e5m2</span>
<span class="s1">_float8_e4m3fn_dtype: np.dtype = np.dtype(float8_e4m3fn)</span>
<span class="s1">_float8_e5m2_dtype: np.dtype = np.dtype(float8_e5m2)</span>

<span class="s0"># bfloat16 support</span>
<span class="s1">bfloat16: Type[np.generic] = ml_dtypes.bfloat16</span>
<span class="s1">_bfloat16_dtype: np.dtype = np.dtype(bfloat16)</span>

<span class="s0"># Default types.</span>
<span class="s1">bool_: type = np.bool_</span>
<span class="s1">int_: type = np.int32 </span><span class="s2">if </span><span class="s1">config.jax_default_dtype_bits == </span><span class="s3">'32' </span><span class="s2">else </span><span class="s1">np.int64</span>
<span class="s1">uint: type = np.uint32 </span><span class="s2">if </span><span class="s1">config.jax_default_dtype_bits == </span><span class="s3">'32' </span><span class="s2">else </span><span class="s1">np.uint64</span>
<span class="s1">float_: type = np.float32 </span><span class="s2">if </span><span class="s1">config.jax_default_dtype_bits == </span><span class="s3">'32' </span><span class="s2">else </span><span class="s1">np.float64</span>
<span class="s1">complex_: type = np.complex64 </span><span class="s2">if </span><span class="s1">config.jax_default_dtype_bits == </span><span class="s3">'32' </span><span class="s2">else </span><span class="s1">np.complex128</span>
<span class="s1">_default_types: Dict[str</span><span class="s2">, </span><span class="s1">type] = {</span><span class="s3">'b'</span><span class="s1">: bool_</span><span class="s2">, </span><span class="s3">'i'</span><span class="s1">: int_</span><span class="s2">, </span><span class="s3">'u'</span><span class="s1">: uint</span><span class="s2">, </span><span class="s3">'f'</span><span class="s1">: float_</span><span class="s2">, </span><span class="s3">'c'</span><span class="s1">: complex_}</span>

<span class="s0"># Trivial vectorspace datatype needed for tangent values of int/bool primals</span>
<span class="s1">float0: np.dtype = np.dtype([(</span><span class="s3">'float0'</span><span class="s2">, </span><span class="s1">np.void</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)])</span>

<span class="s1">_dtype_to_32bit_dtype: Dict[DType</span><span class="s2">, </span><span class="s1">DType] = {</span>
    <span class="s1">np.dtype(</span><span class="s3">'int64'</span><span class="s1">): np.dtype(</span><span class="s3">'int32'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'uint64'</span><span class="s1">): np.dtype(</span><span class="s3">'uint32'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'float64'</span><span class="s1">): np.dtype(</span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'complex128'</span><span class="s1">): np.dtype(</span><span class="s3">'complex64'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s0"># Note: we promote narrow types to float32 here for backward compatibility</span>
<span class="s0"># with earlier approaches. We might consider revisiting this, or perhaps</span>
<span class="s0"># tying the logic more closely to the type promotion lattice.</span>
<span class="s1">_dtype_to_inexact: Dict[DType</span><span class="s2">, </span><span class="s1">DType] = {</span>
    <span class="s1">np.dtype(k): np.dtype(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s3">'bool'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'uint8'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'int8'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'uint16'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'int16'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'uint32'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'int32'</span><span class="s2">, </span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'uint64'</span><span class="s2">, </span><span class="s3">'float64'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'int64'</span><span class="s2">, </span><span class="s3">'float64'</span><span class="s1">)</span>
    <span class="s1">]</span>
<span class="s1">}</span>

<span class="s2">def </span><span class="s1">to_numeric_dtype(dtype: DTypeLike) -&gt; DType:</span>
  <span class="s5">&quot;&quot;&quot;Promotes a dtype into an numeric dtype, if it is not already one.&quot;&quot;&quot;</span>
  <span class="s1">dtype_ = np.dtype(dtype)</span>
  <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">'int32'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">dtype_ == np.dtype(</span><span class="s3">'bool'</span><span class="s1">) </span><span class="s2">else </span><span class="s1">dtype_</span>


<span class="s2">def </span><span class="s1">to_inexact_dtype(dtype: DTypeLike) -&gt; DType:</span>
  <span class="s5">&quot;&quot;&quot;Promotes a dtype into an inexact dtype, if it is not already one.&quot;&quot;&quot;</span>
  <span class="s1">dtype_ = np.dtype(dtype)</span>
  <span class="s2">return </span><span class="s1">_dtype_to_inexact.get(dtype_</span><span class="s2">, </span><span class="s1">dtype_)</span>


<span class="s2">def </span><span class="s1">to_complex_dtype(dtype: DTypeLike) -&gt; DType:</span>
  <span class="s1">ftype = to_inexact_dtype(dtype)</span>
  <span class="s2">if </span><span class="s1">ftype </span><span class="s2">in </span><span class="s1">[np.dtype(</span><span class="s3">'float64'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">'complex128'</span><span class="s1">)]:</span>
    <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">'complex128'</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s3">'complex64'</span><span class="s1">)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_canonicalize_dtype(x64_enabled: bool</span><span class="s2">, </span><span class="s1">allow_opaque_dtype: bool</span><span class="s2">, </span><span class="s1">dtype: Any) -&gt; Union[DType</span><span class="s2">, </span><span class="s1">OpaqueDType]:</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core     </span><span class="s0"># TODO(frostig): break this cycle</span>
  <span class="s2">if </span><span class="s1">core.is_opaque_dtype(dtype):</span>
    <span class="s2">if not </span><span class="s1">allow_opaque_dtype:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Internal: canonicalize_dtype called onopaque dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">&quot;</span>
                       <span class="s3">&quot;with allow_opaque_dtype=False&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">dtype</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">dtype_ = np.dtype(dtype)</span>
  <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f'dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">!r} </span><span class="s3">not understood'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>

  <span class="s2">if </span><span class="s1">x64_enabled:</span>
    <span class="s2">return </span><span class="s1">dtype_</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">_dtype_to_32bit_dtype.get(dtype_</span><span class="s2">, </span><span class="s1">dtype_)</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">canonicalize_dtype(dtype: Any</span><span class="s2">, </span><span class="s1">allow_opaque_dtype: Literal[</span><span class="s2">False</span><span class="s1">] = </span><span class="s2">False</span><span class="s1">) -&gt; DType: ...</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">canonicalize_dtype(dtype: Any</span><span class="s2">, </span><span class="s1">allow_opaque_dtype: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Union[DType</span><span class="s2">, </span><span class="s1">OpaqueDType]: ...</span>

<span class="s2">def </span><span class="s1">canonicalize_dtype(dtype: Any</span><span class="s2">, </span><span class="s1">allow_opaque_dtype: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Union[DType</span><span class="s2">, </span><span class="s1">OpaqueDType]:</span>
  <span class="s5">&quot;&quot;&quot;Convert from a dtype to a canonical dtype based on config.x64_enabled.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_canonicalize_dtype(config.x64_enabled</span><span class="s2">, </span><span class="s1">allow_opaque_dtype</span><span class="s2">, </span><span class="s1">dtype)</span>

<span class="s0"># Default dtypes corresponding to Python scalars.</span>
<span class="s1">python_scalar_dtypes : Dict[type</span><span class="s2">, </span><span class="s1">DType] = {</span>
  <span class="s1">bool: np.dtype(</span><span class="s3">'bool'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">int: np.dtype(</span><span class="s3">'int64'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">float: np.dtype(</span><span class="s3">'float64'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">complex: np.dtype(</span><span class="s3">'complex128'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">def </span><span class="s1">scalar_type_of(x: Any) -&gt; type:</span>
  <span class="s5">&quot;&quot;&quot;Return the scalar type associated with a JAX value.&quot;&quot;&quot;</span>
  <span class="s1">typ = dtype(x)</span>
  <span class="s2">if </span><span class="s1">typ == bfloat16:</span>
    <span class="s2">return </span><span class="s1">float</span>
  <span class="s2">elif </span><span class="s1">typ == float8_e4m3fn:</span>
    <span class="s2">return </span><span class="s1">float</span>
  <span class="s2">elif </span><span class="s1">typ == float8_e5m2:</span>
    <span class="s2">return </span><span class="s1">float</span>
  <span class="s2">elif </span><span class="s1">np.issubdtype(typ</span><span class="s2">, </span><span class="s1">np.bool_):</span>
    <span class="s2">return </span><span class="s1">bool</span>
  <span class="s2">elif </span><span class="s1">np.issubdtype(typ</span><span class="s2">, </span><span class="s1">np.integer):</span>
    <span class="s2">return </span><span class="s1">int</span>
  <span class="s2">elif </span><span class="s1">np.issubdtype(typ</span><span class="s2">, </span><span class="s1">np.floating):</span>
    <span class="s2">return </span><span class="s1">float</span>
  <span class="s2">elif </span><span class="s1">np.issubdtype(typ</span><span class="s2">, </span><span class="s1">np.complexfloating):</span>
    <span class="s2">return </span><span class="s1">complex</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Invalid scalar value </span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_scalar_type_to_dtype(typ: type</span><span class="s2">, </span><span class="s1">value: Any = </span><span class="s2">None</span><span class="s1">) -&gt; DType:</span>
  <span class="s5">&quot;&quot;&quot;Return the numpy dtype for the given scalar type. 
 
  Raises 
  ------ 
  OverflowError: if `typ` is `int` and the value is too large for int64. 
 
  Examples 
  -------- 
  &gt;&gt;&gt; _scalar_type_to_dtype(int) 
  dtype('int32') 
  &gt;&gt;&gt; _scalar_type_to_dtype(float) 
  dtype('float32') 
  &gt;&gt;&gt; _scalar_type_to_dtype(complex) 
  dtype('complex64') 
  &gt;&gt;&gt; _scalar_type_to_dtype(int) 
  dtype('int32') 
  &gt;&gt;&gt; _scalar_type_to_dtype(int, 0) 
  dtype('int32') 
  &gt;&gt;&gt; _scalar_type_to_dtype(int, 1 &lt;&lt; 63)  # doctest: +IGNORE_EXCEPTION_DETAIL 
  Traceback (most recent call last): 
  OverflowError: Python int 9223372036854775808 too large to convert to int32 
  &quot;&quot;&quot;</span>
  <span class="s1">dtype = canonicalize_dtype(python_scalar_dtypes[typ])</span>
  <span class="s2">if </span><span class="s1">typ </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">value </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">value &lt; np.iinfo(dtype).min </span><span class="s2">or </span><span class="s1">value &gt; np.iinfo(dtype).max:</span>
      <span class="s2">raise </span><span class="s1">OverflowError(</span><span class="s3">f&quot;Python int </span><span class="s2">{</span><span class="s1">value</span><span class="s2">} </span><span class="s3">too large to convert to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">coerce_to_array(x: Any</span><span class="s2">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s2">None</span><span class="s1">) -&gt; np.ndarray:</span>
  <span class="s5">&quot;&quot;&quot;Coerces a scalar or NumPy array to an np.array. 
 
  Handles Python scalar type promotion according to JAX's rules, not NumPy's 
  rules. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None and </span><span class="s1">type(x) </span><span class="s2">in </span><span class="s1">python_scalar_dtypes:</span>
    <span class="s1">dtype = _scalar_type_to_dtype(type(x)</span><span class="s2">, </span><span class="s1">x)</span>
  <span class="s2">return </span><span class="s1">np.asarray(x</span><span class="s2">, </span><span class="s1">dtype)</span>

<span class="s1">iinfo = np.iinfo</span>

<span class="s2">class </span><span class="s1">_Bfloat16MachArLike:</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">smallest_normal = float.fromhex(</span><span class="s3">&quot;0x1p-126&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_normal = bfloat16(smallest_normal)</span>
    <span class="s1">smallest_subnormal = float.fromhex(</span><span class="s3">&quot;0x1p-133&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_subnormal = bfloat16(smallest_subnormal)</span>

<span class="s2">class </span><span class="s1">_Float8E4m3FnMachArLike:</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">smallest_normal = float.fromhex(</span><span class="s3">&quot;0x1p-6&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_normal = float8_e4m3fn(smallest_normal)</span>
    <span class="s1">smallest_subnormal = float.fromhex(</span><span class="s3">&quot;0x1p-9&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_subnormal = float8_e4m3fn(smallest_subnormal)</span>

<span class="s2">class </span><span class="s1">_Float8E5m2MachArLike:</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">smallest_normal = float.fromhex(</span><span class="s3">&quot;0x1p-14&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_normal = float8_e5m2(smallest_normal)</span>
    <span class="s1">smallest_subnormal = float.fromhex(</span><span class="s3">&quot;0x1p-16&quot;</span><span class="s1">)</span>
    <span class="s1">self.smallest_subnormal = float8_e5m2(smallest_subnormal)</span>

<span class="s2">class </span><span class="s1">finfo(np.finfo):</span>
  <span class="s1">__doc__ = np.finfo.__doc__</span>
  <span class="s1">_finfo_cache: Dict[np.dtype</span><span class="s2">, </span><span class="s1">np.finfo] = {}</span>
  <span class="s1">@staticmethod</span>
  <span class="s2">def </span><span class="s1">_bfloat16_finfo():</span>
    <span class="s2">def </span><span class="s1">float_to_str(f):</span>
      <span class="s2">return </span><span class="s3">&quot;%12.4e&quot; </span><span class="s1">% float(f)</span>

    <span class="s1">bfloat16 = _bfloat16_dtype.type</span>
    <span class="s1">tiny = float.fromhex(</span><span class="s3">&quot;0x1p-126&quot;</span><span class="s1">)</span>
    <span class="s1">resolution = </span><span class="s4">0.01</span>
    <span class="s1">eps = float.fromhex(</span><span class="s3">&quot;0x1p-7&quot;</span><span class="s1">)</span>
    <span class="s1">epsneg = float.fromhex(</span><span class="s3">&quot;0x1p-8&quot;</span><span class="s1">)</span>
    <span class="s1">max = float.fromhex(</span><span class="s3">&quot;0x1.FEp127&quot;</span><span class="s1">)</span>

    <span class="s1">obj = object.__new__(np.finfo)</span>
    <span class="s1">obj.dtype = _bfloat16_dtype</span>
    <span class="s1">obj.bits = </span><span class="s4">16</span>
    <span class="s1">obj.eps = bfloat16(eps)</span>
    <span class="s1">obj.epsneg = bfloat16(epsneg)</span>
    <span class="s1">obj.machep = -</span><span class="s4">7</span>
    <span class="s1">obj.negep = -</span><span class="s4">8</span>
    <span class="s1">obj.max = bfloat16(max)</span>
    <span class="s1">obj.min = bfloat16(-max)</span>
    <span class="s1">obj.nexp = </span><span class="s4">8</span>
    <span class="s1">obj.nmant = </span><span class="s4">7</span>
    <span class="s1">obj.iexp = obj.nexp</span>
    <span class="s1">obj.maxexp = </span><span class="s4">128</span>
    <span class="s1">obj.precision = </span><span class="s4">2</span>
    <span class="s1">obj.resolution = bfloat16(resolution)</span>
    <span class="s1">obj._machar = _Bfloat16MachArLike()</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;tiny&quot;</span><span class="s1">):</span>
      <span class="s1">obj.tiny = bfloat16(tiny)</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;smallest_normal&quot;</span><span class="s1">):</span>
      <span class="s1">obj.smallest_normal = obj._machar.smallest_normal</span>
    <span class="s1">obj.smallest_subnormal = obj._machar.smallest_subnormal</span>

    <span class="s1">obj._str_tiny = float_to_str(tiny)</span>
    <span class="s1">obj._str_smallest_normal = float_to_str(tiny)</span>
    <span class="s1">obj._str_max = float_to_str(max)</span>
    <span class="s1">obj._str_epsneg = float_to_str(epsneg)</span>
    <span class="s1">obj._str_eps = float_to_str(eps)</span>
    <span class="s1">obj._str_resolution = float_to_str(resolution)</span>
    <span class="s2">return </span><span class="s1">obj</span>

  <span class="s1">@staticmethod</span>
  <span class="s2">def </span><span class="s1">_float8_e4m3fn_finfo():</span>
    <span class="s2">def </span><span class="s1">float_to_str(f):</span>
      <span class="s2">return </span><span class="s3">&quot;%6.2e&quot; </span><span class="s1">% float(f)</span>

    <span class="s1">float8_e4m3fn = _float8_e4m3fn_dtype.type</span>
    <span class="s1">tiny = float.fromhex(</span><span class="s3">&quot;0x1p-6&quot;</span><span class="s1">)</span>
    <span class="s1">resolution = </span><span class="s4">0.1</span>
    <span class="s1">eps = float.fromhex(</span><span class="s3">&quot;0x1p-3&quot;</span><span class="s1">)</span>
    <span class="s1">epsneg = float.fromhex(</span><span class="s3">&quot;0x1p-4&quot;</span><span class="s1">)</span>
    <span class="s1">max = float.fromhex(</span><span class="s3">&quot;0x1.Cp8&quot;</span><span class="s1">)</span>

    <span class="s1">obj = object.__new__(np.finfo)</span>
    <span class="s1">obj.dtype = _float8_e4m3fn_dtype</span>
    <span class="s1">obj.bits = </span><span class="s4">8</span>
    <span class="s1">obj.eps = float8_e4m3fn(eps)</span>
    <span class="s1">obj.epsneg = float8_e4m3fn(epsneg)</span>
    <span class="s1">obj.machep = -</span><span class="s4">3</span>
    <span class="s1">obj.negep = -</span><span class="s4">4</span>
    <span class="s1">obj.max = float8_e4m3fn(max)</span>
    <span class="s1">obj.min = float8_e4m3fn(-max)</span>
    <span class="s1">obj.nexp = </span><span class="s4">4</span>
    <span class="s1">obj.nmant = </span><span class="s4">3</span>
    <span class="s1">obj.iexp = obj.nexp</span>
    <span class="s1">obj.maxexp = </span><span class="s4">9</span>
    <span class="s1">obj.precision = </span><span class="s4">1</span>
    <span class="s1">obj.resolution = float8_e4m3fn(resolution)</span>
    <span class="s1">obj._machar = _Float8E4m3FnMachArLike()</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;tiny&quot;</span><span class="s1">):</span>
      <span class="s1">obj.tiny = float8_e4m3fn(tiny)</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;smallest_normal&quot;</span><span class="s1">):</span>
      <span class="s1">obj.smallest_normal = obj._machar.smallest_normal</span>
    <span class="s1">obj.smallest_subnormal = obj._machar.smallest_subnormal</span>

    <span class="s1">obj._str_tiny = float_to_str(tiny)</span>
    <span class="s1">obj._str_smallest_normal = float_to_str(tiny)</span>
    <span class="s1">obj._str_max = float_to_str(max)</span>
    <span class="s1">obj._str_epsneg = float_to_str(epsneg)</span>
    <span class="s1">obj._str_eps = float_to_str(eps)</span>
    <span class="s1">obj._str_resolution = float_to_str(resolution)</span>
    <span class="s2">return </span><span class="s1">obj</span>

  <span class="s1">@staticmethod</span>
  <span class="s2">def </span><span class="s1">_float8_e5m2_finfo():</span>
    <span class="s2">def </span><span class="s1">float_to_str(f):</span>
      <span class="s2">return </span><span class="s3">&quot;%6.2e&quot; </span><span class="s1">% float(f)</span>

    <span class="s1">float8_e5m2 = _float8_e5m2_dtype.type</span>
    <span class="s1">tiny = float.fromhex(</span><span class="s3">&quot;0x1p-14&quot;</span><span class="s1">)</span>
    <span class="s1">resolution = </span><span class="s4">0.1</span>
    <span class="s1">eps = float.fromhex(</span><span class="s3">&quot;0x1p-2&quot;</span><span class="s1">)</span>
    <span class="s1">epsneg = float.fromhex(</span><span class="s3">&quot;0x1p-3&quot;</span><span class="s1">)</span>
    <span class="s1">max = float.fromhex(</span><span class="s3">&quot;0x1.Cp15&quot;</span><span class="s1">)</span>

    <span class="s1">obj = object.__new__(np.finfo)</span>
    <span class="s1">obj.dtype = _float8_e5m2_dtype</span>
    <span class="s1">obj.bits = </span><span class="s4">8</span>
    <span class="s1">obj.eps = float8_e5m2(eps)</span>
    <span class="s1">obj.epsneg = float8_e5m2(epsneg)</span>
    <span class="s1">obj.machep = -</span><span class="s4">2</span>
    <span class="s1">obj.negep = -</span><span class="s4">3</span>
    <span class="s1">obj.max = float8_e5m2(max)</span>
    <span class="s1">obj.min = float8_e5m2(-max)</span>
    <span class="s1">obj.nexp = </span><span class="s4">5</span>
    <span class="s1">obj.nmant = </span><span class="s4">2</span>
    <span class="s1">obj.iexp = obj.nexp</span>
    <span class="s1">obj.maxexp = </span><span class="s4">16</span>
    <span class="s1">obj.precision = </span><span class="s4">1</span>
    <span class="s1">obj.resolution = float8_e5m2(resolution)</span>
    <span class="s1">obj._machar = _Float8E5m2MachArLike()</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;tiny&quot;</span><span class="s1">):</span>
      <span class="s1">obj.tiny = float8_e5m2(tiny)</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;smallest_normal&quot;</span><span class="s1">):</span>
      <span class="s1">obj.smallest_normal = obj._machar.smallest_normal</span>
    <span class="s1">obj.smallest_subnormal = obj._machar.smallest_subnormal</span>

    <span class="s1">obj._str_tiny = float_to_str(tiny)</span>
    <span class="s1">obj._str_smallest_normal = float_to_str(tiny)</span>
    <span class="s1">obj._str_max = float_to_str(max)</span>
    <span class="s1">obj._str_epsneg = float_to_str(epsneg)</span>
    <span class="s1">obj._str_eps = float_to_str(eps)</span>
    <span class="s1">obj._str_resolution = float_to_str(resolution)</span>
    <span class="s2">return </span><span class="s1">obj</span>

  <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype == </span><span class="s3">'bfloat16' </span><span class="s2">or </span><span class="s1">dtype == _bfloat16_dtype:</span>
      <span class="s2">if </span><span class="s1">_bfloat16_dtype </span><span class="s2">not in </span><span class="s1">cls._finfo_cache:</span>
        <span class="s1">cls._finfo_cache[_bfloat16_dtype] = cls._bfloat16_finfo()</span>
      <span class="s2">return </span><span class="s1">cls._finfo_cache[_bfloat16_dtype]</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype == </span><span class="s3">'float8_e4m3fn' </span><span class="s2">or </span><span class="s1">dtype == _float8_e4m3fn_dtype:</span>
      <span class="s2">if </span><span class="s1">_float8_e4m3fn_dtype </span><span class="s2">not in </span><span class="s1">cls._finfo_cache:</span>
        <span class="s1">cls._finfo_cache[_float8_e4m3fn_dtype] = cls._float8_e4m3fn_finfo()</span>
      <span class="s2">return </span><span class="s1">cls._finfo_cache[_float8_e4m3fn_dtype]</span>
    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype == </span><span class="s3">'float8_e5m2' </span><span class="s2">or </span><span class="s1">dtype == _float8_e5m2_dtype:</span>
      <span class="s2">if </span><span class="s1">_float8_e5m2_dtype </span><span class="s2">not in </span><span class="s1">cls._finfo_cache:</span>
        <span class="s1">cls._finfo_cache[_float8_e5m2_dtype] = cls._float8_e5m2_finfo()</span>
      <span class="s2">return </span><span class="s1">cls._finfo_cache[_float8_e5m2_dtype]</span>
    <span class="s2">return </span><span class="s1">super().__new__(cls</span><span class="s2">, </span><span class="s1">dtype)</span>

<span class="s2">def </span><span class="s1">_issubclass(a: Any</span><span class="s2">, </span><span class="s1">b: Any) -&gt; bool:</span>
  <span class="s5">&quot;&quot;&quot;Determines if ``a`` is a subclass of ``b``. 
 
  Similar to issubclass, but returns False instead of an exception if `a` is not 
  a class. 
  &quot;&quot;&quot;</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">issubclass(a</span><span class="s2">, </span><span class="s1">b)</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">issubdtype(a: DTypeLike</span><span class="s2">, </span><span class="s1">b: DTypeLike) -&gt; bool:</span>
  <span class="s5">&quot;&quot;&quot;Returns True if first argument is a typecode lower/equal in type hierarchy. 
 
  This is like :func:`numpy.issubdtype`, but can handle dtype extensions such as 
  :obj:`jax.dtypes.bfloat16`. 
  '&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">a == </span><span class="s3">&quot;float8_e4m3fn&quot;</span><span class="s1">:</span>
    <span class="s1">a = float8_e4m3fn</span>
  <span class="s2">if </span><span class="s1">a == float8_e4m3fn:</span>
    <span class="s2">if </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">np.dtype):</span>
      <span class="s2">return </span><span class="s1">b == _float8_e4m3fn_dtype</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">b </span><span class="s2">in </span><span class="s1">[float8_e4m3fn</span><span class="s2">, </span><span class="s1">np.floating</span><span class="s2">, </span><span class="s1">np.inexact</span><span class="s2">, </span><span class="s1">np.number]</span>
  <span class="s2">if </span><span class="s1">a == </span><span class="s3">&quot;float8_e5m2&quot;</span><span class="s1">:</span>
    <span class="s1">a = float8_e5m2</span>
  <span class="s2">if </span><span class="s1">a == float8_e5m2:</span>
    <span class="s2">if </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">np.dtype):</span>
      <span class="s2">return </span><span class="s1">b == _float8_e5m2_dtype</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">b </span><span class="s2">in </span><span class="s1">[float8_e5m2</span><span class="s2">, </span><span class="s1">np.floating</span><span class="s2">, </span><span class="s1">np.inexact</span><span class="s2">, </span><span class="s1">np.number]</span>
  <span class="s2">if </span><span class="s1">a == </span><span class="s3">&quot;bfloat16&quot;</span><span class="s1">:</span>
    <span class="s1">a = bfloat16</span>
  <span class="s2">if </span><span class="s1">a == bfloat16:</span>
    <span class="s2">if </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">np.dtype):</span>
      <span class="s2">return </span><span class="s1">b == _bfloat16_dtype</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">b </span><span class="s2">in </span><span class="s1">[bfloat16</span><span class="s2">, </span><span class="s1">np.floating</span><span class="s2">, </span><span class="s1">np.inexact</span><span class="s2">, </span><span class="s1">np.number]</span>
  <span class="s2">if not </span><span class="s1">_issubclass(b</span><span class="s2">, </span><span class="s1">np.generic):</span>
    <span class="s0"># Workaround for JAX scalar types. NumPy's issubdtype has a backward</span>
    <span class="s0"># compatibility behavior for the second argument of issubdtype that</span>
    <span class="s0"># interacts badly with JAX's custom scalar types. As a workaround,</span>
    <span class="s0"># explicitly cast the second argument to a NumPy type object.</span>
    <span class="s1">b = np.dtype(b).type</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">np.issubdtype(a</span><span class="s2">, </span><span class="s1">b)</span>
  <span class="s2">except </span><span class="s1">TypeError:  </span><span class="s0"># e.g. if 'a' is not a np.dtype</span>
    <span class="s2">return False</span>

<span class="s1">can_cast = np.can_cast</span>
<span class="s1">issubsctype = np.issubsctype</span>

<span class="s1">JAXType = Union[type</span><span class="s2">, </span><span class="s1">DType]</span>

<span class="s0"># Enumeration of all valid JAX types in order.</span>
<span class="s1">_weak_types: List[JAXType] = [int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex]</span>
<span class="s1">_bool_types: List[JAXType] = [np.dtype(bool)]</span>
<span class="s1">_int_types: List[JAXType] = [</span>
    <span class="s1">np.dtype(</span><span class="s3">'uint8'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'uint16'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'uint32'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'uint64'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'int8'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'int16'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'int32'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'int64'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">_float_types: List[JAXType]</span>
<span class="s1">_float_types = [</span>
  <span class="s1">np.dtype(float8_e4m3fn)</span><span class="s2">,</span>
  <span class="s1">np.dtype(float8_e5m2)</span><span class="s2">,</span>
  <span class="s1">np.dtype(bfloat16)</span><span class="s2">,</span>
  <span class="s1">np.dtype(</span><span class="s3">'float16'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">np.dtype(</span><span class="s3">'float32'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">np.dtype(</span><span class="s3">'float64'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">_complex_types: List[JAXType] = [</span>
    <span class="s1">np.dtype(</span><span class="s3">'complex64'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">np.dtype(</span><span class="s3">'complex128'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s1">_jax_types = _bool_types + _int_types + _float_types + _complex_types</span>
<span class="s1">_jax_dtype_set = {float0</span><span class="s2">, </span><span class="s1">*_bool_types</span><span class="s2">, </span><span class="s1">*_int_types</span><span class="s2">, </span><span class="s1">*_float_types</span><span class="s2">, </span><span class="s1">*_complex_types}</span>

<span class="s2">def </span><span class="s1">_jax_type(dtype: DType</span><span class="s2">, </span><span class="s1">weak_type: bool) -&gt; JAXType:</span>
  <span class="s5">&quot;&quot;&quot;Return the jax type for a dtype and weak type.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">weak_type:</span>
    <span class="s2">if </span><span class="s1">dtype == bool:</span>
      <span class="s2">return </span><span class="s1">dtype</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[_float8_e4m3fn_dtype</span><span class="s2">, </span><span class="s1">_float8_e5m2_dtype</span><span class="s2">, </span><span class="s1">_bfloat16_dtype]:</span>
      <span class="s2">return </span><span class="s1">float</span>
    <span class="s2">return </span><span class="s1">type(dtype.type(</span><span class="s4">0</span><span class="s1">).item())</span>
  <span class="s2">return </span><span class="s1">dtype</span>

<span class="s2">def </span><span class="s1">_dtype_and_weaktype(value: Any) -&gt; Tuple[DType</span><span class="s2">, </span><span class="s1">bool]:</span>
  <span class="s5">&quot;&quot;&quot;Return a (dtype, weak_type) tuple for the given input.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">dtype(value)</span><span class="s2">, </span><span class="s1">any(value </span><span class="s2">is </span><span class="s1">typ </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">_weak_types) </span><span class="s2">or </span><span class="s1">is_weakly_typed(value)</span>

<span class="s2">def </span><span class="s1">_type_promotion_lattice(jax_numpy_dtype_promotion: str) -&gt; Dict[JAXType</span><span class="s2">, </span><span class="s1">List[JAXType]]:</span>
  <span class="s5">&quot;&quot;&quot; 
  Return the type promotion lattice in the form of a DAG. 
  This DAG maps each type to its immediately higher type on the lattice. 
  &quot;&quot;&quot;</span>
  <span class="s1">b1</span><span class="s2">, </span><span class="s1">= _bool_types</span>
  <span class="s1">u1</span><span class="s2">, </span><span class="s1">u2</span><span class="s2">, </span><span class="s1">u4</span><span class="s2">, </span><span class="s1">u8</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">i2</span><span class="s2">, </span><span class="s1">i4</span><span class="s2">, </span><span class="s1">i8 = _int_types</span>
  <span class="s1">f1_e4m3fn</span><span class="s2">, </span><span class="s1">f1_e5m2</span><span class="s2">, </span><span class="s1">bf</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f4</span><span class="s2">, </span><span class="s1">f8 = _float_types</span>
  <span class="s1">c4</span><span class="s2">, </span><span class="s1">c8 = _complex_types</span>
  <span class="s1">i_</span><span class="s2">, </span><span class="s1">f_</span><span class="s2">, </span><span class="s1">c_ = _weak_types</span>
  <span class="s2">if </span><span class="s1">jax_numpy_dtype_promotion == </span><span class="s3">'standard'</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">b1: [i_]</span><span class="s2">,</span>
      <span class="s1">u1: [i2</span><span class="s2">, </span><span class="s1">u2]</span><span class="s2">, </span><span class="s1">u2: [i4</span><span class="s2">, </span><span class="s1">u4]</span><span class="s2">, </span><span class="s1">u4: [i8</span><span class="s2">, </span><span class="s1">u8]</span><span class="s2">, </span><span class="s1">u8: [f_]</span><span class="s2">,</span>
      <span class="s1">i_: [u1</span><span class="s2">, </span><span class="s1">i1]</span><span class="s2">, </span><span class="s1">i1: [i2]</span><span class="s2">, </span><span class="s1">i2: [i4]</span><span class="s2">, </span><span class="s1">i4: [i8]</span><span class="s2">, </span><span class="s1">i8: [f_]</span><span class="s2">,</span>
      <span class="s1">f_: [f1_e4m3fn</span><span class="s2">, </span><span class="s1">f1_e5m2</span><span class="s2">, </span><span class="s1">bf</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">c_]</span><span class="s2">, </span><span class="s1">f1_e4m3fn: []</span><span class="s2">, </span><span class="s1">f1_e5m2: []</span><span class="s2">, </span><span class="s1">bf: [f4]</span><span class="s2">, </span><span class="s1">f2: [f4]</span><span class="s2">, </span><span class="s1">f4: [f8</span><span class="s2">, </span><span class="s1">c4]</span><span class="s2">, </span><span class="s1">f8: [c8]</span><span class="s2">,</span>
      <span class="s1">c_: [c4]</span><span class="s2">, </span><span class="s1">c4: [c8]</span><span class="s2">, </span><span class="s1">c8: []</span><span class="s2">,</span>
    <span class="s1">}</span>
  <span class="s2">elif </span><span class="s1">jax_numpy_dtype_promotion == </span><span class="s3">'strict'</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">i_: [f_] + _int_types</span><span class="s2">,</span>
      <span class="s1">f_: [c_] + _float_types</span><span class="s2">,</span>
      <span class="s1">c_: _complex_types</span><span class="s2">,</span>
      <span class="s1">**{t: [] </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_jax_types}</span>
    <span class="s1">}</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
      <span class="s3">f&quot;Unexpected value of jax_numpy_dtype_promotion=</span><span class="s2">{</span><span class="s1">jax_numpy_dtype_promotion</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_make_lattice_upper_bounds(jax_numpy_dtype_promotion: str) -&gt; Dict[JAXType</span><span class="s2">, </span><span class="s1">Set[JAXType]]:</span>
  <span class="s1">lattice = _type_promotion_lattice(jax_numpy_dtype_promotion)</span>
  <span class="s1">upper_bounds = {node: {node} </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">lattice}</span>
  <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">lattice:</span>
    <span class="s2">while True</span><span class="s1">:</span>
      <span class="s1">new_upper_bounds = set().union(*(lattice[b] </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">upper_bounds[n]))</span>
      <span class="s2">if </span><span class="s1">n </span><span class="s2">in </span><span class="s1">new_upper_bounds:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;cycle detected in type promotion lattice for node </span><span class="s2">{</span><span class="s1">n</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
      <span class="s2">if </span><span class="s1">new_upper_bounds.issubset(upper_bounds[n]):</span>
        <span class="s2">break</span>
      <span class="s1">upper_bounds[n] |= new_upper_bounds</span>
  <span class="s2">return </span><span class="s1">upper_bounds</span>

<span class="s1">_lattice_upper_bounds: Dict[str</span><span class="s2">, </span><span class="s1">Dict[JAXType</span><span class="s2">, </span><span class="s1">Set[JAXType]]] = {</span>
  <span class="s3">'standard'</span><span class="s1">: _make_lattice_upper_bounds(</span><span class="s3">'standard'</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s3">'strict'</span><span class="s1">: _make_lattice_upper_bounds(</span><span class="s3">'strict'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TypePromotionError(ValueError):</span>
  <span class="s2">pass</span>

<span class="s1">@functools.lru_cache(</span><span class="s4">512</span><span class="s1">)  </span><span class="s0"># don't use util.memoize because there is no X64 dependence.</span>
<span class="s2">def </span><span class="s1">_least_upper_bound(jax_numpy_dtype_promotion: str</span><span class="s2">, </span><span class="s1">*nodes: JAXType) -&gt; JAXType:</span>
  <span class="s5">&quot;&quot;&quot;Compute the least upper bound of a set of nodes. 
 
  Args: 
    nodes: sequence of entries from _jax_types + _weak_types 
  Returns: 
    the _jax_type representing the least upper bound of the input nodes 
      on the promotion lattice. 
  &quot;&quot;&quot;</span>
  <span class="s0"># This function computes the least upper bound of a set of nodes N within a partially</span>
  <span class="s0"># ordered set defined by the lattice generated above.</span>
  <span class="s0"># Given a partially ordered set S, let the set of upper bounds of n ∈ S be</span>
  <span class="s0">#   UB(n) ≡ {m ∈ S | n ≤ m}</span>
  <span class="s0"># Further, for a set of nodes N ⊆ S, let the set of common upper bounds be given by</span>
  <span class="s0">#   CUB(N) ≡ {a ∈ S | ∀ b ∈ N: a ∈ UB(b)}</span>
  <span class="s0"># Then the least upper bound of N is defined as</span>
  <span class="s0">#   LUB(N) ≡ {c ∈ CUB(N) | ∀ d ∈ CUB(N), c ≤ d}</span>
  <span class="s0"># The definition of an upper bound implies that c ≤ d if and only if d ∈ UB(c),</span>
  <span class="s0"># so the LUB can be expressed:</span>
  <span class="s0">#   LUB(N) = {c ∈ CUB(N) | ∀ d ∈ CUB(N): d ∈ UB(c)}</span>
  <span class="s0"># or, equivalently:</span>
  <span class="s0">#   LUB(N) = {c ∈ CUB(N) | CUB(N) ⊆ UB(c)}</span>
  <span class="s0"># By definition, LUB(N) has a cardinality of 1 for a partially ordered set.</span>
  <span class="s0"># Note a potential algorithmic shortcut: from the definition of CUB(N), we have</span>
  <span class="s0">#   ∀ c ∈ N: CUB(N) ⊆ UB(c)</span>
  <span class="s0"># So if N ∩ CUB(N) is nonempty, if follows that LUB(N) = N ∩ CUB(N).</span>
  <span class="s1">N = set(nodes)</span>
  <span class="s1">UB = _lattice_upper_bounds[jax_numpy_dtype_promotion]</span>
  <span class="s1">CUB = set.intersection(*(UB[n] </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">N))</span>
  <span class="s1">LUB = (CUB &amp; N) </span><span class="s2">or </span><span class="s1">{c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">CUB </span><span class="s2">if </span><span class="s1">CUB.issubset(UB[c])}</span>
  <span class="s2">if </span><span class="s1">len(LUB) == </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">LUB.pop()</span>
  <span class="s2">elif </span><span class="s1">len(LUB) == </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">config.jax_numpy_dtype_promotion == </span><span class="s3">'strict'</span><span class="s1">:</span>
      <span class="s1">msg = (</span>
        <span class="s3">f&quot;Input dtypes </span><span class="s2">{</span><span class="s1">tuple(str(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nodes)</span><span class="s2">} </span><span class="s3">have no available implicit dtype &quot;</span>
        <span class="s3">&quot;promotion path when jax_numpy_dtype_promotion=strict. Try explicitly casting &quot;</span>
        <span class="s3">&quot;inputs to the desired output type, or set jax_numpy_dtype_promotion=standard.&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">msg = (</span>
        <span class="s3">f&quot;Input dtypes </span><span class="s2">{</span><span class="s1">tuple(str(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nodes)</span><span class="s2">} </span><span class="s3">have no available implicit dtype &quot;</span>
        <span class="s3">&quot;promotion path. Try explicitly casting inputs to the desired output type.&quot;</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">TypePromotionError(msg)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s0"># If we get here, it means the lattice is ill-formed.</span>
    <span class="s2">raise </span><span class="s1">TypePromotionError(</span>
      <span class="s3">f&quot;Internal Type Promotion error: </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">} </span><span class="s3">do not have a unique least upper bound &quot;</span>
      <span class="s3">f&quot;on the specified lattice; options are </span><span class="s2">{</span><span class="s1">LUB</span><span class="s2">}</span><span class="s3">. This is an unexpected error in &quot;</span>
      <span class="s3">&quot;JAX's internal logic; please report it to the JAX maintainers.&quot;</span>
    <span class="s1">)</span>

<span class="s2">def </span><span class="s1">promote_types(a: DTypeLike</span><span class="s2">, </span><span class="s1">b: DTypeLike) -&gt; DType:</span>
  <span class="s5">&quot;&quot;&quot;Returns the type to which a binary operation should cast its arguments. 
 
  For details of JAX's type promotion semantics, see :ref:`type-promotion`. 
 
  Args: 
    a: a :class:`numpy.dtype` or a dtype specifier. 
    b: a :class:`numpy.dtype` or a dtype specifier. 
 
  Returns: 
    A :class:`numpy.dtype` object. 
  &quot;&quot;&quot;</span>
  <span class="s0"># Note: we deliberately avoid `if a in _weak_types` here because we want to check</span>
  <span class="s0"># object identity, not object equality, due to the behavior of np.dtype.__eq__</span>
  <span class="s1">a_tp = cast(JAXType</span><span class="s2">, </span><span class="s1">a </span><span class="s2">if </span><span class="s1">any(a </span><span class="s2">is </span><span class="s1">t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_weak_types) </span><span class="s2">else </span><span class="s1">np.dtype(a))</span>
  <span class="s1">b_tp = cast(JAXType</span><span class="s2">, </span><span class="s1">b </span><span class="s2">if </span><span class="s1">any(b </span><span class="s2">is </span><span class="s1">t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_weak_types) </span><span class="s2">else </span><span class="s1">np.dtype(b))</span>
  <span class="s2">return </span><span class="s1">np.dtype(_least_upper_bound(config.jax_numpy_dtype_promotion</span><span class="s2">, </span><span class="s1">a_tp</span><span class="s2">, </span><span class="s1">b_tp))</span>

<span class="s2">def </span><span class="s1">is_weakly_typed(x: Any) -&gt; bool:</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">x.aval.weak_type</span>
  <span class="s2">except </span><span class="s1">AttributeError:</span>
    <span class="s2">return </span><span class="s1">type(x) </span><span class="s2">in </span><span class="s1">_weak_types</span>

<span class="s2">def </span><span class="s1">is_python_scalar(x: Any) -&gt; bool:</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">x.aval.weak_type </span><span class="s2">and </span><span class="s1">np.ndim(x) == </span><span class="s4">0</span>
  <span class="s2">except </span><span class="s1">AttributeError:</span>
    <span class="s2">return </span><span class="s1">type(x) </span><span class="s2">in </span><span class="s1">python_scalar_dtypes</span>

<span class="s2">def </span><span class="s1">check_valid_dtype(dtype: DType) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
  <span class="s2">if </span><span class="s1">dtype </span><span class="s2">not in </span><span class="s1">_jax_dtype_set:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">is not a valid JAX array &quot;</span>
                    <span class="s3">&quot;type. Only arrays of numeric types are supported by JAX.&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">dtype(x: Any</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">canonicalize: bool = </span><span class="s2">False</span><span class="s1">) -&gt; DType:</span>
  <span class="s5">&quot;&quot;&quot;Return the dtype object for a value or type, optionally canonicalized based on X64 mode.&quot;&quot;&quot;</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core     </span><span class="s0"># TODO(frostig): break this cycle</span>
  <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Invalid argument to dtype: </span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>
  <span class="s2">elif </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">type) </span><span class="s2">and </span><span class="s1">x </span><span class="s2">in </span><span class="s1">python_scalar_dtypes:</span>
    <span class="s1">dt = python_scalar_dtypes[x]</span>
  <span class="s2">elif </span><span class="s1">type(x) </span><span class="s2">in </span><span class="s1">python_scalar_dtypes:</span>
    <span class="s1">dt = python_scalar_dtypes[type(x)]</span>
  <span class="s2">elif </span><span class="s1">core.is_opaque_dtype(getattr(x</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s2">, None</span><span class="s1">)):</span>
    <span class="s1">dt = x.dtype</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">dt = np.result_type(x)</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
      <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Cannot determine dtype of </span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
  <span class="s2">if </span><span class="s1">dt </span><span class="s2">not in </span><span class="s1">_jax_dtype_set:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Value '</span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">' with dtype </span><span class="s2">{</span><span class="s1">dt</span><span class="s2">} </span><span class="s3">is not a valid JAX array &quot;</span>
                    <span class="s3">&quot;type. Only arrays of numeric types are supported by JAX.&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">canonicalize_dtype(dt) </span><span class="s2">if </span><span class="s1">canonicalize </span><span class="s2">else </span><span class="s1">dt</span>

<span class="s2">def </span><span class="s1">_lattice_result_type(*args: Any) -&gt; Tuple[DType</span><span class="s2">, </span><span class="s1">bool]:</span>
  <span class="s1">dtypes</span><span class="s2">, </span><span class="s1">weak_types = zip(*(_dtype_and_weaktype(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args))</span>
  <span class="s2">if </span><span class="s1">len(dtypes) == </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s1">out_dtype = dtypes[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">out_weak_type = weak_types[</span><span class="s4">0</span><span class="s1">]</span>
  <span class="s2">elif </span><span class="s1">all(weak_types) </span><span class="s2">and </span><span class="s1">config.jax_numpy_dtype_promotion != </span><span class="s3">'strict'</span><span class="s1">:</span>
    <span class="s0"># If all inputs are weakly typed, we compute the bound of the strongly-typed</span>
    <span class="s0"># counterparts and apply the weak type at the end. This avoids returning the</span>
    <span class="s0"># incorrect result with non-canonical weak types (e.g. weak int16).</span>
    <span class="s0"># TODO(jakevdp): explore removing this special case.</span>
    <span class="s1">result_type = _least_upper_bound(config.jax_numpy_dtype_promotion</span><span class="s2">,</span>
                                     <span class="s1">*{_jax_type(dtype</span><span class="s2">, False</span><span class="s1">) </span><span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes})</span>
    <span class="s1">out_dtype = dtype(result_type)</span>
    <span class="s1">out_weak_type = </span><span class="s2">True</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">result_type = _least_upper_bound(config.jax_numpy_dtype_promotion</span><span class="s2">,</span>
                                     <span class="s1">*{_jax_type(d</span><span class="s2">, </span><span class="s1">w) </span><span class="s2">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">zip(dtypes</span><span class="s2">, </span><span class="s1">weak_types)})</span>
    <span class="s1">out_dtype = dtype(result_type)</span>
    <span class="s1">out_weak_type = any(result_type </span><span class="s2">is </span><span class="s1">t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">_weak_types)</span>
  <span class="s2">return </span><span class="s1">out_dtype</span><span class="s2">, </span><span class="s1">(out_dtype != bool_) </span><span class="s2">and </span><span class="s1">out_weak_type</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">result_type(*args: Any</span><span class="s2">, </span><span class="s1">return_weak_type_flag: Literal[</span><span class="s2">True</span><span class="s1">]) -&gt; Tuple[DType</span><span class="s2">, </span><span class="s1">bool]: ...</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">result_type(*args: Any</span><span class="s2">, </span><span class="s1">return_weak_type_flag: Literal[</span><span class="s2">False</span><span class="s1">] = </span><span class="s2">False</span><span class="s1">) -&gt; DType: ...</span>

<span class="s1">@overload</span>
<span class="s2">def </span><span class="s1">result_type(*args: Any</span><span class="s2">, </span><span class="s1">return_weak_type_flag: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Union[DType</span><span class="s2">, </span><span class="s1">Tuple[DType</span><span class="s2">, </span><span class="s1">bool]]: ...</span>

<span class="s2">def </span><span class="s1">result_type(*args: Any</span><span class="s2">, </span><span class="s1">return_weak_type_flag: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Union[DType</span><span class="s2">, </span><span class="s1">Tuple[DType</span><span class="s2">, </span><span class="s1">bool]]:</span>
  <span class="s5">&quot;&quot;&quot;Convenience function to apply JAX argument dtype promotion. 
 
  Args: 
    return_weak_type_flag : if True, then return a ``(dtype, weak_type)`` tuple. 
      If False, just return `dtype` 
 
  Returns: 
    dtype or (dtype, weak_type) depending on the value of the ``return_weak_type`` argument. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;at least one array or dtype is required&quot;</span><span class="s1">)</span>
  <span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type = _lattice_result_type(*(float_ </span><span class="s2">if </span><span class="s1">arg </span><span class="s2">is None else </span><span class="s1">arg </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args))</span>
  <span class="s2">if </span><span class="s1">weak_type:</span>
    <span class="s1">dtype = canonicalize_dtype(</span>
      <span class="s1">_default_types[</span><span class="s3">'f' </span><span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">[_float8_e4m3fn_dtype</span><span class="s2">, </span><span class="s1">_float8_e5m2_dtype</span><span class="s2">, </span><span class="s1">_bfloat16_dtype] </span><span class="s2">else </span><span class="s1">dtype.kind])</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">dtype = canonicalize_dtype(dtype)</span>
  <span class="s2">return </span><span class="s1">(dtype</span><span class="s2">, </span><span class="s1">weak_type) </span><span class="s2">if </span><span class="s1">return_weak_type_flag </span><span class="s2">else </span><span class="s1">dtype</span>

<span class="s2">def </span><span class="s1">check_user_dtype_supported(dtype</span><span class="s2">, </span><span class="s1">fun_name=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s0"># Avoid using `dtype in [...]` because of numpy dtype equality overloading.</span>
  <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">type) </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">{bool</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">builtins.complex}:</span>
    <span class="s2">return</span>
  <span class="s1">np_dtype = np.dtype(dtype)</span>
  <span class="s1">is_custom_dtype = np_dtype.type </span><span class="s2">in </span><span class="s1">[float8_e4m3fn</span><span class="s2">, </span><span class="s1">float8_e5m2</span><span class="s2">, </span><span class="s1">bfloat16]</span>
  <span class="s2">if </span><span class="s1">np_dtype.kind </span><span class="s2">not in </span><span class="s3">&quot;biufc&quot; </span><span class="s2">and not </span><span class="s1">is_custom_dtype:</span>
    <span class="s1">msg = </span><span class="s3">f&quot;JAX only supports number and bool dtypes, got dtype </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s1">msg += </span><span class="s3">f&quot; in </span><span class="s2">{</span><span class="s1">fun_name</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">fun_name </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">TypeError(msg)</span>
  <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None and </span><span class="s1">np_dtype != canonicalize_dtype(dtype):</span>
    <span class="s1">msg = (</span><span class="s3">&quot;Explicitly requested dtype {} {} is not available, &quot;</span>
           <span class="s3">&quot;and will be truncated to dtype {}. To enable more dtypes, set the &quot;</span>
           <span class="s3">&quot;jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell &quot;</span>
           <span class="s3">&quot;environment variable. &quot;</span>
           <span class="s3">&quot;See https://github.com/google/jax#current-gotchas for more.&quot;</span><span class="s1">)</span>
    <span class="s1">fun_name = </span><span class="s3">f&quot;requested in </span><span class="s2">{</span><span class="s1">fun_name</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">fun_name </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
    <span class="s1">truncated_dtype = canonicalize_dtype(dtype).name</span>
    <span class="s1">warnings.warn(msg.format(dtype</span><span class="s2">, </span><span class="s1">fun_name </span><span class="s2">, </span><span class="s1">truncated_dtype)</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">)</span>
</pre>
</body>
</html>