<html>
<head>
<title>transform.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transform.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s3">&quot;&quot;&quot; 
Sparsify transform 
================== 
 
This is an experimental JAX transform that will allow arbitrary JAX functions to accept 
sparse matrices as inputs, so long as sparse rules are implemented for the primitives 
called by the function. 
 
For example: 
 
&gt;&gt;&gt; import jax.numpy as jnp 
&gt;&gt;&gt; from jax import random 
&gt;&gt;&gt; from jax.experimental.sparse import BCOO, sparsify 
 
&gt;&gt;&gt; mat = random.uniform(random.PRNGKey(1701), (5, 5)) 
&gt;&gt;&gt; mat = mat.at[mat &lt; 0.5].set(0) 
&gt;&gt;&gt; vec = random.uniform(random.PRNGKey(42), (5,)) 
 
&gt;&gt;&gt; def f(mat, vec): 
...   return -(jnp.sin(mat) @ vec) 
... 
&gt;&gt;&gt; f(mat, vec) 
Array([-1.2655463 , -0.52060574, -0.14522289, -0.10817424, 
       -0.15574613], dtype=float32) 
 
&gt;&gt;&gt; mat_sparse = BCOO.fromdense(mat) 
&gt;&gt;&gt; mat_sparse 
BCOO(float32[5, 5], nse=8) 
 
&gt;&gt;&gt; sparsify(f)(mat_sparse, vec) 
Array([-1.2655463 , -0.52060574, -0.14522289, -0.10817424, 
       -0.15574613], dtype=float32) 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
  <span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Tuple)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">jax</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">lax</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">pjit</span>
<span class="s2">from </span><span class="s1">jax.experimental.sparse.bcoo </span><span class="s2">import </span><span class="s1">bcoo_multiply_dense</span><span class="s2">, </span><span class="s1">bcoo_multiply_sparse</span>
<span class="s2">import </span><span class="s1">jax.numpy </span><span class="s2">as </span><span class="s1">jnp</span>
<span class="s2">from </span><span class="s1">jax._src.api_util </span><span class="s2">import </span><span class="s1">flatten_fun_nokwargs</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">pytree</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">partial_eval </span><span class="s2">as </span><span class="s1">pe</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">xla</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">pxla</span>
<span class="s2">from </span><span class="s1">jax.tree_util </span><span class="s2">import </span><span class="s1">tree_flatten</span><span class="s2">, </span><span class="s1">tree_map</span><span class="s2">, </span><span class="s1">tree_unflatten</span>
<span class="s2">from </span><span class="s1">jax.util </span><span class="s2">import </span><span class="s1">safe_map</span><span class="s2">, </span><span class="s1">safe_zip</span><span class="s2">, </span><span class="s1">split_list</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">jax._src.lax.control_flow </span><span class="s2">import </span><span class="s1">_check_tree_and_avals</span>
<span class="s2">from </span><span class="s1">jax._src.numpy </span><span class="s2">import </span><span class="s1">lax_numpy</span>
<span class="s2">from </span><span class="s1">jax.experimental </span><span class="s2">import </span><span class="s1">sparse</span>
<span class="s2">from </span><span class="s1">jax.experimental.sparse </span><span class="s2">import </span><span class="s1">BCOO</span><span class="s2">, </span><span class="s1">BCSR</span>

<span class="s1">sparse_rules_bcoo : Dict[core.Primitive</span><span class="s2">, </span><span class="s1">Callable] = {}</span>
<span class="s1">sparse_rules_bcsr : Dict[core.Primitive</span><span class="s2">, </span><span class="s1">Callable] = {}</span>

<span class="s1">_zero_preserving_linear_unary_primitives = [</span>
  <span class="s1">lax.copy_p</span><span class="s2">,</span>
  <span class="s1">lax.imag_p</span><span class="s2">,</span>
  <span class="s1">lax.neg_p</span><span class="s2">,</span>
  <span class="s1">lax.real_p</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">_zero_preserving_unary_primitives = [</span>
  <span class="s1">lax.abs_p</span><span class="s2">,</span>
  <span class="s1">lax.asin_p</span><span class="s2">,</span>
  <span class="s1">lax.asinh_p</span><span class="s2">,</span>
  <span class="s1">lax.atan_p</span><span class="s2">,</span>
  <span class="s1">lax.atanh_p</span><span class="s2">,</span>
  <span class="s1">lax.bessel_i1e_p</span><span class="s2">,</span>
  <span class="s1">lax.expm1_p</span><span class="s2">,</span>
  <span class="s1">lax.log1p_p</span><span class="s2">,</span>
  <span class="s1">lax.sign_p</span><span class="s2">,</span>
  <span class="s1">lax.sin_p</span><span class="s2">,</span>
  <span class="s1">lax.sinh_p</span><span class="s2">,</span>
  <span class="s1">lax.sqrt_p</span><span class="s2">,</span>
  <span class="s1">lax.tan_p</span><span class="s2">,</span>
  <span class="s1">lax.tanh_p</span><span class="s2">,</span>
  <span class="s1">lax.convert_element_type_p</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">_densifying_primitives : List[core.Primitive] = [</span>
  <span class="s1">lax.acos_p</span><span class="s2">,</span>
  <span class="s1">lax.acosh_p</span><span class="s2">,</span>
  <span class="s1">lax.bessel_i0e_p</span><span class="s2">,</span>
  <span class="s1">lax.cos_p</span><span class="s2">,</span>
  <span class="s1">lax.cosh_p</span><span class="s2">,</span>
  <span class="s1">lax.eq_p</span><span class="s2">,</span>
  <span class="s1">lax.exp_p</span><span class="s2">,</span>
  <span class="s1">lax.ge_p</span><span class="s2">,</span>
  <span class="s1">lax.gt_p</span><span class="s2">,</span>
  <span class="s1">lax.le_p</span><span class="s2">,</span>
  <span class="s1">lax.lt_p</span><span class="s2">,</span>
  <span class="s1">lax.log_p</span><span class="s2">,</span>
  <span class="s1">lax.ne_p</span><span class="s2">,</span>
  <span class="s1">lax.xor_p</span>
<span class="s1">]</span>

<span class="s2">def </span><span class="s1">_raise_unimplemented_primitive(primitive):</span>
  <span class="s2">if </span><span class="s1">primitive </span><span class="s2">in </span><span class="s1">_densifying_primitives:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;sparse rule for </span><span class="s2">{</span><span class="s1">primitive</span><span class="s2">} </span><span class="s3">is not implemented because it &quot;</span>
                              <span class="s3">&quot;would result in dense output. If this is your intent, use &quot;</span>
                              <span class="s3">&quot;sparse.todense() to convert your arguments to dense matrices.&quot;</span><span class="s1">)</span>
  <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;sparse rule for </span><span class="s2">{</span><span class="s1">primitive</span><span class="s2">} </span><span class="s3">is not implemented.&quot;</span><span class="s1">)</span>


<span class="s1">Array = Any</span>
<span class="s1">ArrayOrSparse = Any</span>


<span class="s2">class </span><span class="s1">SparsifyEnv:</span>
  <span class="s4">&quot;&quot;&quot;Environment for sparse jaxpr evaluation. 
 
  The environment is essentially a collection of buffers and/or tracers 
  that may be shared between one or more SparsifyValue objects, which 
  represent sparse or dense arrays via indices into the list of buffers. 
  &quot;&quot;&quot;</span>
  <span class="s1">_buffers : List[Array]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bufs=()):</span>
    <span class="s1">self._buffers = list(bufs)</span>

  <span class="s2">def </span><span class="s1">_push(self</span><span class="s2">, </span><span class="s1">arr: Array) -&gt; int:</span>
    <span class="s1">self._buffers.append(jnp.asarray(arr))  </span><span class="s0"># type: ignore</span>
    <span class="s2">return </span><span class="s1">len(self._buffers) - </span><span class="s5">1</span>

  <span class="s2">def </span><span class="s1">data(self</span><span class="s2">, </span><span class="s1">spvalue: SparsifyValue) -&gt; Array:</span>
    <span class="s4">&quot;&quot;&quot;Get the data buffer associated with a SparsifyValue.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">spvalue.data_ref </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: requested data from spvalue with data_ref=None&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">self._buffers[spvalue.data_ref]</span>

  <span class="s2">def </span><span class="s1">indices(self</span><span class="s2">, </span><span class="s1">spvalue: SparsifyValue) -&gt; Array:</span>
    <span class="s4">&quot;&quot;&quot;Get the indices buffer associated with a SparsifyValue.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">spvalue.indices_ref </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: requested indices from spvalue with indices_ref=None&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">self._buffers[spvalue.indices_ref]</span>

  <span class="s2">def </span><span class="s1">indptr(self</span><span class="s2">, </span><span class="s1">spvalue: SparsifyValue) -&gt; Array:</span>
    <span class="s4">&quot;&quot;&quot;Get the BCSR indptr buffer associated with a SparsifyValue.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">spvalue.indptr_ref </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: requested indices from spvalue with indptr_ref=None&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">self._buffers[spvalue.indptr_ref]</span>

  <span class="s2">def </span><span class="s1">dense(self</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s4">&quot;&quot;&quot;Add a new dense array to the sparsify environment.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">SparsifyValue(np.shape(data)</span><span class="s2">, </span><span class="s1">self._push(data))</span>

  <span class="s2">def </span><span class="s1">sparse(self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">data=</span><span class="s2">None, </span><span class="s1">indices=</span><span class="s2">None, </span><span class="s1">indptr=</span><span class="s2">None,</span>
             <span class="s1">*</span><span class="s2">, </span><span class="s1">data_ref=</span><span class="s2">None, </span><span class="s1">indices_ref=</span><span class="s2">None, </span><span class="s1">indptr_ref=</span><span class="s2">None,</span>
             <span class="s1">indices_sorted=</span><span class="s2">False, </span><span class="s1">unique_indices=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Add a new sparse array to the sparsify environment.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">data_ref </span><span class="s2">is None</span>
      <span class="s1">data_ref = self._push(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">data_ref </span><span class="s2">is not None and </span><span class="s1">data_ref &lt; len(self._buffers)</span>

    <span class="s2">if </span><span class="s1">indices </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">indices_ref </span><span class="s2">is None</span>
      <span class="s1">indices_ref = self._push(indices)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">indices_ref </span><span class="s2">is not None and </span><span class="s1">indices_ref &lt; len(self._buffers)</span>

    <span class="s2">if </span><span class="s1">indptr </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">indptr_ref </span><span class="s2">is None</span>
      <span class="s1">indptr_ref = self._push(indptr)</span>
    <span class="s2">elif </span><span class="s1">indptr_ref </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">indptr_ref &lt; len(self._buffers)</span>

    <span class="s2">return </span><span class="s1">SparsifyValue(shape</span><span class="s2">, </span><span class="s1">data_ref</span><span class="s2">, </span><span class="s1">indices_ref</span><span class="s2">, </span><span class="s1">indptr_ref</span><span class="s2">,</span>
                         <span class="s1">indices_sorted=indices_sorted</span><span class="s2">, </span><span class="s1">unique_indices=unique_indices)</span>


<span class="s2">class </span><span class="s1">SparsifyValue(NamedTuple):</span>
  <span class="s1">shape: Tuple[int</span><span class="s2">, </span><span class="s1">...]</span>
  <span class="s1">data_ref: Optional[int]</span>
  <span class="s1">indices_ref: Optional[int] = </span><span class="s2">None</span>
  <span class="s1">indptr_ref: Optional[int] = </span><span class="s2">None</span>
  <span class="s1">indices_sorted: Optional[bool] = </span><span class="s2">False</span>
  <span class="s1">unique_indices: Optional[bool] = </span><span class="s2">False</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">ndim(self):</span>
    <span class="s2">return </span><span class="s1">len(self.shape)</span>

  <span class="s2">def </span><span class="s1">is_sparse(self):</span>
    <span class="s2">return </span><span class="s1">self.indices_ref </span><span class="s2">is not None</span>

  <span class="s2">def </span><span class="s1">is_dense(self):</span>
    <span class="s2">return </span><span class="s1">self.indices_ref </span><span class="s2">is None</span>

  <span class="s2">def </span><span class="s1">is_bcoo(self):</span>
    <span class="s2">return </span><span class="s1">self.is_sparse() </span><span class="s2">and </span><span class="s1">self.indptr_ref </span><span class="s2">is None</span>

  <span class="s2">def </span><span class="s1">is_bcsr(self):</span>
    <span class="s2">return </span><span class="s1">self.is_sparse() </span><span class="s2">and </span><span class="s1">self.indptr_ref </span><span class="s2">is not None</span>


<span class="s1">_is_sparse_obj = </span><span class="s2">lambda </span><span class="s1">arg: isinstance(arg</span><span class="s2">, </span><span class="s1">(BCOO</span><span class="s2">, </span><span class="s1">BCSR))</span>
<span class="s1">_is_spvalue = </span><span class="s2">lambda </span><span class="s1">arg: isinstance(arg</span><span class="s2">, </span><span class="s1">SparsifyValue)</span>


<span class="s2">def </span><span class="s1">arrays_to_spvalues(</span>
    <span class="s1">spenv: SparsifyEnv</span><span class="s2">,</span>
    <span class="s1">args: Any</span>
    <span class="s1">) -&gt; Any:</span>
  <span class="s4">&quot;&quot;&quot;Convert a pytree of (sparse) arrays to an equivalent pytree of spvalues.&quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">array_to_spvalue(arg):</span>
    <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">BCOO):</span>
      <span class="s2">return </span><span class="s1">spenv.sparse(arg.shape</span><span class="s2">, </span><span class="s1">arg.data</span><span class="s2">, </span><span class="s1">arg.indices</span><span class="s2">,</span>
                          <span class="s1">indices_sorted=arg.indices_sorted</span><span class="s2">,</span>
                          <span class="s1">unique_indices=arg.unique_indices)</span>
    <span class="s2">elif </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">BCSR):</span>
      <span class="s2">return </span><span class="s1">spenv.sparse(arg.shape</span><span class="s2">, </span><span class="s1">arg.data</span><span class="s2">, </span><span class="s1">arg.indices</span><span class="s2">, </span><span class="s1">arg.indptr</span><span class="s2">,</span>
                          <span class="s1">indices_sorted=arg.indices_sorted</span><span class="s2">,</span>
                          <span class="s1">unique_indices=arg.unique_indices)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">spenv.dense(arg)</span>
  <span class="s2">return </span><span class="s1">tree_map(array_to_spvalue</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">is_leaf=_is_sparse_obj)</span>


<span class="s2">def </span><span class="s1">spvalues_to_arrays(</span>
    <span class="s1">spenv: SparsifyEnv</span><span class="s2">,</span>
    <span class="s1">spvalues: Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any:</span>
  <span class="s4">&quot;&quot;&quot;Convert a pytree of spvalues to an equivalent pytree of (sparse) arrays.&quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">spvalue_to_array(spvalue):</span>
    <span class="s2">if </span><span class="s1">spvalue.is_bcoo():</span>
      <span class="s2">return </span><span class="s1">BCOO((spenv.data(spvalue)</span><span class="s2">, </span><span class="s1">spenv.indices(spvalue))</span><span class="s2">,</span>
                  <span class="s1">shape=spvalue.shape</span><span class="s2">, </span><span class="s1">indices_sorted=spvalue.indices_sorted</span><span class="s2">,</span>
                  <span class="s1">unique_indices=spvalue.unique_indices)</span>
    <span class="s2">elif </span><span class="s1">spvalue.is_bcsr():</span>
      <span class="s2">return </span><span class="s1">BCSR((spenv.data(spvalue)</span><span class="s2">, </span><span class="s1">spenv.indices(spvalue)</span><span class="s2">, </span><span class="s1">spenv.indptr(spvalue))</span><span class="s2">,</span>
                  <span class="s1">shape=spvalue.shape</span><span class="s2">, </span><span class="s1">indices_sorted=spvalue.indices_sorted</span><span class="s2">,</span>
                  <span class="s1">unique_indices=spvalue.unique_indices)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">spenv.data(spvalue)</span>
  <span class="s2">return </span><span class="s1">tree_map(spvalue_to_array</span><span class="s2">, </span><span class="s1">spvalues</span><span class="s2">, </span><span class="s1">is_leaf=_is_spvalue)</span>


<span class="s2">def </span><span class="s1">spvalues_to_avals(</span>
    <span class="s1">spenv: SparsifyEnv</span><span class="s2">,</span>
    <span class="s1">spvalues: Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; Any:</span>
  <span class="s4">&quot;&quot;&quot;Convert a pytree of spvalues to an equivalent pytree of abstract values.&quot;&quot;&quot;</span>
  <span class="s2">def </span><span class="s1">spvalue_to_aval(spvalue):</span>
    <span class="s1">data = spenv.data(spvalue)</span>
    <span class="s2">return </span><span class="s1">core.ShapedArray(spvalue.shape</span><span class="s2">, </span><span class="s1">data.dtype</span><span class="s2">, </span><span class="s1">data.aval.weak_type)</span>
  <span class="s2">return </span><span class="s1">tree_map(spvalue_to_aval</span><span class="s2">, </span><span class="s1">spvalues</span><span class="s2">, </span><span class="s1">is_leaf=_is_spvalue)</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Implementation of sparsify() using tracers.</span>

<span class="s2">def </span><span class="s1">popattr(obj: Any</span><span class="s2">, </span><span class="s1">name: str) -&gt; Any:</span>
  <span class="s2">assert </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
  <span class="s1">val = getattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
  <span class="s1">delattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
  <span class="s2">return </span><span class="s1">val</span>

<span class="s2">def </span><span class="s1">setnewattr(obj: Any</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">val: Any):</span>
  <span class="s2">assert not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
  <span class="s1">setattr(obj</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val)</span>

<span class="s2">class </span><span class="s1">SparseTracer(core.Tracer):</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">trace: core.Trace</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">spvalue):</span>
    <span class="s1">self._spvalue = spvalue</span>
    <span class="s1">self._trace = trace</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">spenv(self):</span>
    <span class="s2">if not </span><span class="s1">hasattr(self._trace.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">):</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: main does not have spenv defined.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">self._trace.main.spenv</span>

  <span class="s1">@property</span>
  <span class="s2">def </span><span class="s1">aval(self):</span>
    <span class="s2">return </span><span class="s1">spvalues_to_avals(self.spenv</span><span class="s2">, </span><span class="s1">[self._spvalue])[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">full_lower(self):</span>
    <span class="s2">return </span><span class="s1">self</span>

<span class="s2">class </span><span class="s1">SparseTrace(core.Trace):</span>
  <span class="s2">def </span><span class="s1">pure(self</span><span class="s2">, </span><span class="s1">val: Any):</span>
    <span class="s2">if not </span><span class="s1">hasattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">):</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: main does not have spenv defined.&quot;</span><span class="s1">)</span>
    <span class="s1">spvalue</span><span class="s2">, </span><span class="s1">= arrays_to_spvalues(self.main.spenv</span><span class="s2">, </span><span class="s1">[val])</span>
    <span class="s2">return </span><span class="s1">SparseTracer(self</span><span class="s2">, </span><span class="s1">spvalue=spvalue)</span>

  <span class="s2">def </span><span class="s1">lift(self</span><span class="s2">, </span><span class="s1">val: core.Tracer):</span>
    <span class="s2">if not </span><span class="s1">hasattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">):</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Internal: main does not have spenv defined.&quot;</span><span class="s1">)</span>
    <span class="s1">spvalue</span><span class="s2">, </span><span class="s1">= arrays_to_spvalues(self.main.spenv</span><span class="s2">, </span><span class="s1">[val])</span>
    <span class="s2">return </span><span class="s1">SparseTracer(self</span><span class="s2">, </span><span class="s1">spvalue=spvalue)</span>

  <span class="s2">def </span><span class="s1">sublift(self</span><span class="s2">, </span><span class="s1">val: SparseTracer):</span>
    <span class="s2">return </span><span class="s1">SparseTracer(val._trace</span><span class="s2">, </span><span class="s1">spvalue=val._spvalue)</span>

  <span class="s2">def </span><span class="s1">process_primitive(self</span><span class="s2">, </span><span class="s1">primitive</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">spenv = popattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">)</span>
    <span class="s1">spvalues = [t._spvalue </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers]</span>
    <span class="s2">if </span><span class="s1">any(spvalue.is_sparse() </span><span class="s2">for </span><span class="s1">spvalue </span><span class="s2">in </span><span class="s1">spvalues):</span>
      <span class="s2">if </span><span class="s1">primitive </span><span class="s2">not in </span><span class="s1">sparse_rules_bcoo:</span>
        <span class="s1">_raise_unimplemented_primitive(primitive)</span>
      <span class="s1">out_spvalues = sparse_rules_bcoo[primitive](spenv</span><span class="s2">, </span><span class="s1">*(t._spvalue </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers)</span><span class="s2">, </span><span class="s1">**params)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">out_bufs = primitive.bind(*(spenv.data(spvalue) </span><span class="s2">for </span><span class="s1">spvalue </span><span class="s2">in </span><span class="s1">spvalues)</span><span class="s2">, </span><span class="s1">**params)</span>
      <span class="s1">out_spvalues = arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">out_bufs </span><span class="s2">if </span><span class="s1">primitive.multiple_results </span><span class="s2">else </span><span class="s1">[out_bufs])</span>
    <span class="s1">setnewattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s2">, </span><span class="s1">spenv)</span>
    <span class="s1">out_tracers = tuple(SparseTracer(self</span><span class="s2">, </span><span class="s1">spvalue=spvalue) </span><span class="s2">for </span><span class="s1">spvalue </span><span class="s2">in </span><span class="s1">out_spvalues)</span>
    <span class="s2">return </span><span class="s1">out_tracers </span><span class="s2">if </span><span class="s1">primitive.multiple_results </span><span class="s2">else </span><span class="s1">out_tracers[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">process_call(self</span><span class="s2">, </span><span class="s1">call_primitive</span><span class="s2">, </span><span class="s1">f: lu.WrappedFun</span><span class="s2">, </span><span class="s1">tracers</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s1">spenv = popattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">)</span>
    <span class="s1">spvalues = tuple(t._spvalue </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">tracers)</span>
    <span class="s1">in_bufs = spenv._buffers</span>
    <span class="s1">fun</span><span class="s2">, </span><span class="s1">out_spvalues = sparsify_subtrace(f</span><span class="s2">, </span><span class="s1">self.main</span><span class="s2">, </span><span class="s1">spvalues)</span>
    <span class="s2">if </span><span class="s1">any(params[</span><span class="s3">'donated_invars'</span><span class="s1">]):</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;sparsify does not support donated_invars&quot;</span><span class="s1">)</span>
    <span class="s1">params = dict(params</span><span class="s2">, </span><span class="s1">donated_invars=tuple(</span><span class="s2">False for </span><span class="s1">buf </span><span class="s2">in </span><span class="s1">in_bufs))</span>
    <span class="s1">bufs_out = call_primitive.bind(fun</span><span class="s2">, </span><span class="s1">*in_bufs</span><span class="s2">, </span><span class="s1">**params)</span>
    <span class="s1">setnewattr(self.main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s2">, </span><span class="s1">SparsifyEnv(bufs_out))</span>
    <span class="s2">return </span><span class="s1">[SparseTracer(self</span><span class="s2">, </span><span class="s1">spvalue=spvalue) </span><span class="s2">for </span><span class="s1">spvalue </span><span class="s2">in </span><span class="s1">out_spvalues()]</span>

<span class="s1">@lu.transformation_with_aux</span>
<span class="s2">def </span><span class="s1">sparsify_subtrace(main</span><span class="s2">, </span><span class="s1">spvalues</span><span class="s2">, </span><span class="s1">*bufs):</span>
  <span class="s1">setnewattr(main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s2">, </span><span class="s1">SparsifyEnv(bufs))</span>
  <span class="s1">trace = main.with_cur_sublevel()</span>
  <span class="s1">in_tracers = [SparseTracer(trace</span><span class="s2">, </span><span class="s1">spvalue=spvalue) </span><span class="s2">for </span><span class="s1">spvalue </span><span class="s2">in </span><span class="s1">spvalues]</span>
  <span class="s1">outs = </span><span class="s2">yield </span><span class="s1">in_tracers</span><span class="s2">, </span><span class="s1">{}</span>
  <span class="s1">out_traces = [trace.full_raise(out) </span><span class="s2">for </span><span class="s1">out </span><span class="s2">in </span><span class="s1">outs]</span>
  <span class="s1">buffers = popattr(main</span><span class="s2">, </span><span class="s3">'spenv'</span><span class="s1">)._buffers</span>
  <span class="s2">yield </span><span class="s1">buffers</span><span class="s2">, </span><span class="s1">[out._spvalue </span><span class="s2">for </span><span class="s1">out </span><span class="s2">in </span><span class="s1">out_traces]</span>

<span class="s2">def </span><span class="s1">sparsify_fun(wrapped_fun</span><span class="s2">, </span><span class="s1">args: List[ArrayOrSparse]):</span>
  <span class="s2">with </span><span class="s1">core.new_main(SparseTrace) </span><span class="s2">as </span><span class="s1">main:</span>
    <span class="s1">spenv = SparsifyEnv()</span>
    <span class="s1">spvalues = arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s1">in_bufs = spenv._buffers</span>
    <span class="s1">fun</span><span class="s2">, </span><span class="s1">out_spvalues = sparsify_subtrace(wrapped_fun</span><span class="s2">, </span><span class="s1">main</span><span class="s2">, </span><span class="s1">spvalues)</span>
    <span class="s1">out_bufs = fun.call_wrapped(*in_bufs)</span>
    <span class="s1">spenv = SparsifyEnv(out_bufs)</span>
    <span class="s2">del </span><span class="s1">main</span>
  <span class="s2">return </span><span class="s1">spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">out_spvalues())</span>

<span class="s2">def </span><span class="s1">_sparsify_with_tracer(fun):</span>
  <span class="s4">&quot;&quot;&quot;Implementation of sparsify() using tracers.&quot;&quot;&quot;</span>
  <span class="s1">@functools.wraps(fun)</span>
  <span class="s2">def </span><span class="s1">_wrapped(*args):</span>
    <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(args</span><span class="s2">, </span><span class="s1">is_leaf=_is_sparse_obj)</span>
    <span class="s1">wrapped_fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(lu.wrap_init(fun)</span><span class="s2">, </span><span class="s1">in_tree)</span>
    <span class="s1">out = sparsify_fun(wrapped_fun</span><span class="s2">, </span><span class="s1">args_flat)</span>
    <span class="s2">return </span><span class="s1">tree_unflatten(out_tree()</span><span class="s2">, </span><span class="s1">out)</span>
  <span class="s2">return </span><span class="s1">_wrapped</span>

<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Implementation of sparsify() using a jaxpr interpreter.</span>

<span class="s2">def </span><span class="s1">eval_sparse(</span>
    <span class="s1">jaxpr: core.Jaxpr</span><span class="s2">,</span>
    <span class="s1">consts: Sequence[Array]</span><span class="s2">,  </span><span class="s0"># all consts are dense</span>
    <span class="s1">spvalues: Sequence[SparsifyValue]</span><span class="s2">,  </span><span class="s0"># mix of sparse and dense pointers into spenv</span>
    <span class="s1">spenv: SparsifyEnv</span><span class="s2">,</span>
<span class="s1">) -&gt; Sequence[SparsifyValue]:</span>
  <span class="s1">env : Dict[core.Var</span><span class="s2">, </span><span class="s1">SparsifyValue] = {}</span>

  <span class="s2">def </span><span class="s1">read(var: core.Atom) -&gt; SparsifyValue:</span>
    <span class="s0"># all literals are dense</span>
    <span class="s2">if </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">core.Literal):</span>
      <span class="s2">return </span><span class="s1">spenv.dense(var.val)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">assert </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">core.Var)</span>
      <span class="s2">return </span><span class="s1">env[var]</span>

  <span class="s2">def </span><span class="s1">write_buffer(var: core.Var</span><span class="s2">, </span><span class="s1">a: Array) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">core.DropVar):</span>
      <span class="s2">return</span>
    <span class="s1">env[var] = spenv.dense(a)</span>

  <span class="s2">def </span><span class="s1">write(var: core.Var</span><span class="s2">, </span><span class="s1">a: SparsifyValue) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">isinstance(var</span><span class="s2">, </span><span class="s1">core.DropVar):</span>
      <span class="s2">return</span>
    <span class="s2">assert </span><span class="s1">a </span><span class="s2">is not None</span>
    <span class="s1">env[var] = a</span>

  <span class="s1">safe_map(write_buffer</span><span class="s2">, </span><span class="s1">jaxpr.constvars</span><span class="s2">, </span><span class="s1">consts)</span>
  <span class="s1">safe_map(write</span><span class="s2">, </span><span class="s1">jaxpr.invars</span><span class="s2">, </span><span class="s1">spvalues)</span>

  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s1">prim = eqn.primitive</span>
    <span class="s1">invals = safe_map(read</span><span class="s2">, </span><span class="s1">eqn.invars)</span>
    <span class="s2">if </span><span class="s1">any(val.is_bcsr() </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">invals):</span>
      <span class="s2">if </span><span class="s1">prim </span><span class="s2">not in </span><span class="s1">sparse_rules_bcsr:</span>
        <span class="s1">_raise_unimplemented_primitive(prim)</span>
      <span class="s1">out = sparse_rules_bcsr[prim](spenv</span><span class="s2">, </span><span class="s1">*invals</span><span class="s2">, </span><span class="s1">**eqn.params)</span>
    <span class="s2">elif </span><span class="s1">any(val.is_bcoo() </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">invals):</span>
      <span class="s2">if </span><span class="s1">prim </span><span class="s2">not in </span><span class="s1">sparse_rules_bcoo:</span>
        <span class="s1">_raise_unimplemented_primitive(prim)</span>
      <span class="s1">out = sparse_rules_bcoo[prim](spenv</span><span class="s2">, </span><span class="s1">*invals</span><span class="s2">, </span><span class="s1">**eqn.params)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">out_bufs = prim.bind(*(spenv.data(val) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">invals)</span><span class="s2">, </span><span class="s1">**eqn.params)</span>
      <span class="s1">out_bufs = out_bufs </span><span class="s2">if </span><span class="s1">prim.multiple_results </span><span class="s2">else </span><span class="s1">[out_bufs]</span>
      <span class="s1">out = []</span>
      <span class="s2">for </span><span class="s1">buf</span><span class="s2">, </span><span class="s1">outvar </span><span class="s2">in </span><span class="s1">safe_zip(out_bufs</span><span class="s2">, </span><span class="s1">eqn.outvars):</span>
        <span class="s2">if </span><span class="s1">isinstance(outvar</span><span class="s2">, </span><span class="s1">core.DropVar):</span>
          <span class="s1">out.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
          <span class="s1">out.append(spenv.dense(buf))</span>
    <span class="s1">safe_map(write</span><span class="s2">, </span><span class="s1">eqn.outvars</span><span class="s2">, </span><span class="s1">out)</span>

  <span class="s2">return </span><span class="s1">safe_map(read</span><span class="s2">, </span><span class="s1">jaxpr.outvars)</span>

<span class="s2">def </span><span class="s1">sparsify_raw(f):</span>

  <span class="s2">def </span><span class="s1">wrapped(</span>
      <span class="s1">spenv: SparsifyEnv</span><span class="s2">, </span><span class="s1">*spvalues: SparsifyValue</span><span class="s2">, </span><span class="s1">**params: Any</span>
  <span class="s1">) -&gt; Tuple[Sequence[SparsifyValue]</span><span class="s2">, </span><span class="s1">pytree.PyTreeDef]:</span>
    <span class="s1">spvalues_flat</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(spvalues</span><span class="s2">, </span><span class="s1">is_leaf=_is_spvalue)</span>
    <span class="s1">in_avals_flat = spvalues_to_avals(spenv</span><span class="s2">, </span><span class="s1">spvalues_flat)</span>
    <span class="s1">wrapped_fun</span><span class="s2">, </span><span class="s1">out_tree = flatten_fun_nokwargs(lu.wrap_init(f</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">, </span><span class="s1">in_tree)</span>
    <span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">out_avals_flat</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(wrapped_fun</span><span class="s2">, </span><span class="s1">in_avals_flat)</span>
    <span class="s1">result = eval_sparse(jaxpr</span><span class="s2">, </span><span class="s1">consts</span><span class="s2">, </span><span class="s1">spvalues_flat</span><span class="s2">, </span><span class="s1">spenv)</span>
    <span class="s2">if </span><span class="s1">len(out_avals_flat) != len(result):</span>
      <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">&quot;Internal: eval_sparse does not return expected number of arguments. &quot;</span>
                      <span class="s3">&quot;Got {result} for avals {out_avals_flat}&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">out_tree()</span>

  <span class="s2">return </span><span class="s1">wrapped</span>

<span class="s2">def </span><span class="s1">_sparsify_with_interpreter(f):</span>
  <span class="s4">&quot;&quot;&quot;Implementation of sparsify() using jaxpr interpreter.&quot;&quot;&quot;</span>
  <span class="s1">f_raw = sparsify_raw(f)</span>
  <span class="s1">@functools.wraps(f)</span>
  <span class="s2">def </span><span class="s1">wrapped(*args</span><span class="s2">, </span><span class="s1">**params):</span>
    <span class="s1">spenv = SparsifyEnv()</span>
    <span class="s1">spvalues = arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s1">spvalues_out</span><span class="s2">, </span><span class="s1">out_tree = f_raw(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">**params)</span>
    <span class="s1">out = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues_out)</span>
    <span class="s2">return </span><span class="s1">tree_unflatten(out_tree</span><span class="s2">, </span><span class="s1">out)</span>
  <span class="s2">return </span><span class="s1">wrapped</span>

<span class="s2">def </span><span class="s1">sparsify(f</span><span class="s2">, </span><span class="s1">use_tracer=</span><span class="s2">False</span><span class="s1">):</span>
  <span class="s4">&quot;&quot;&quot;Experimental sparsification transform. 
 
  Examples: 
 
    Decorate JAX functions to make them compatible with :class:`jax.experimental.sparse.BCOO` 
    matrices: 
 
    &gt;&gt;&gt; from jax.experimental import sparse 
 
    &gt;&gt;&gt; @sparse.sparsify 
    ... def f(M, v): 
    ...   return 2 * M.T @ v 
 
    &gt;&gt;&gt; M = sparse.BCOO.fromdense(jnp.arange(12).reshape(3, 4)) 
 
    &gt;&gt;&gt; v = jnp.array([3, 4, 2]) 
 
    &gt;&gt;&gt; f(M, v) 
    Array([ 64,  82, 100, 118], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">use_tracer:</span>
    <span class="s2">return </span><span class="s1">_sparsify_with_tracer(f)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">_sparsify_with_interpreter(f)</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># Sparse rules for various primitives</span>

<span class="s2">def </span><span class="s1">_ensure_unique_indices(spenv</span><span class="s2">, </span><span class="s1">spvalue):</span>
  <span class="s4">&quot;&quot;&quot;Return an spvalue representation with deduplicated indices.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">spvalue.is_dense() </span><span class="s2">or </span><span class="s1">spvalue.unique_indices:</span>
    <span class="s2">return </span><span class="s1">spvalue</span>
  <span class="s1">arr = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalue)</span>
  <span class="s1">arr = arr.sum_duplicates(nse=arr.nse</span><span class="s2">, </span><span class="s1">remove_zeros=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">arr)</span>

<span class="s2">def </span><span class="s1">_zero_preserving_unary_op(prim</span><span class="s2">, </span><span class="s1">linear):</span>
  <span class="s2">def </span><span class="s1">func(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">assert </span><span class="s1">len(spvalues) == </span><span class="s5">1</span>
    <span class="s1">spvalue = spvalues[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if not </span><span class="s1">linear:</span>
      <span class="s0"># For non-linear unary operations, we need to ensure that</span>
      <span class="s0"># indices are unique before applying the operator elementwise.</span>
      <span class="s1">spvalue = _ensure_unique_indices(spenv</span><span class="s2">, </span><span class="s1">spvalue)</span>
    <span class="s1">buf = spenv.data(spvalue)</span>
    <span class="s1">buf_out = prim.bind(buf</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">if </span><span class="s1">spvalues[</span><span class="s5">0</span><span class="s1">].is_sparse():</span>
      <span class="s1">out_spvalue = spenv.sparse(spvalue.shape</span><span class="s2">, </span><span class="s1">buf_out</span><span class="s2">,</span>
                                 <span class="s1">indices_ref=spvalue.indices_ref</span><span class="s2">,</span>
                                 <span class="s1">indptr_ref=spvalue.indptr_ref</span><span class="s2">,</span>
                                 <span class="s1">indices_sorted=spvalue.indices_sorted</span><span class="s2">,</span>
                                 <span class="s1">unique_indices=spvalue.unique_indices)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">out_spvalue = spenv.dense(buf)</span>
    <span class="s2">return </span><span class="s1">(out_spvalue</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">func</span>

<span class="s2">for </span><span class="s1">_prim </span><span class="s2">in </span><span class="s1">_zero_preserving_unary_primitives:</span>
  <span class="s1">sparse_rules_bcoo[_prim] = _zero_preserving_unary_op(_prim</span><span class="s2">, </span><span class="s1">linear=</span><span class="s2">False</span><span class="s1">)</span>
  <span class="s1">sparse_rules_bcsr[_prim] = _zero_preserving_unary_op(_prim</span><span class="s2">, </span><span class="s1">linear=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s2">for </span><span class="s1">_prim </span><span class="s2">in </span><span class="s1">_zero_preserving_linear_unary_primitives:</span>
  <span class="s1">sparse_rules_bcoo[_prim] = _zero_preserving_unary_op(_prim</span><span class="s2">, </span><span class="s1">linear=</span><span class="s2">True</span><span class="s1">)</span>
  <span class="s1">sparse_rules_bcsr[_prim] = _zero_preserving_unary_op(_prim</span><span class="s2">, </span><span class="s1">linear=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_standard_sparse_rule(prim</span><span class="s2">, </span><span class="s1">sparse_op):</span>
  <span class="s2">def </span><span class="s1">_sparse_rule(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s1">result = sparse_op(*spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues)</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">result </span><span class="s2">if </span><span class="s1">prim.multiple_results </span><span class="s2">else </span><span class="s1">[result])</span>
  <span class="s2">return </span><span class="s1">_sparse_rule</span>

<span class="s1">_BCOO_STANDARD_PRIMITIVES = {</span>
  <span class="s1">lax.broadcast_in_dim_p: sparse.bcoo_broadcast_in_dim</span><span class="s2">,</span>
  <span class="s1">lax.concatenate_p: </span><span class="s2">lambda </span><span class="s1">*a</span><span class="s2">, </span><span class="s1">**k: sparse.bcoo_concatenate(a</span><span class="s2">, </span><span class="s1">**k)</span><span class="s2">,</span>
  <span class="s1">lax.conv_general_dilated_p: sparse.bcoo_conv_general_dilated</span><span class="s2">,</span>
  <span class="s1">lax.dot_general_p: sparse.bcoo_dot_general</span><span class="s2">,</span>
  <span class="s1">lax.dynamic_slice_p: </span><span class="s2">lambda </span><span class="s1">*a</span><span class="s2">, </span><span class="s1">**k: sparse.bcoo_dynamic_slice(a[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">a[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">**k)</span><span class="s2">,</span>
  <span class="s1">lax.reshape_p: sparse.bcoo_reshape</span><span class="s2">,</span>
  <span class="s1">lax.rev_p: sparse.bcoo_rev</span><span class="s2">,</span>
  <span class="s1">lax.slice_p: sparse.bcoo_slice</span><span class="s2">,</span>
  <span class="s1">lax.squeeze_p: sparse.bcoo_squeeze</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">for </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">bcoo_impl </span><span class="s2">in </span><span class="s1">_BCOO_STANDARD_PRIMITIVES.items():</span>
  <span class="s1">sparse_rules_bcoo[prim] = _standard_sparse_rule(prim</span><span class="s2">, </span><span class="s1">bcoo_impl)</span>

<span class="s1">_BCSR_STANDARD_PRIMITIVES = {</span>
  <span class="s1">lax.dot_general_p: sparse.bcsr_dot_general</span><span class="s2">,</span>
  <span class="s1">lax.broadcast_in_dim_p: sparse.bcsr_broadcast_in_dim</span><span class="s2">,</span>
  <span class="s1">lax.concatenate_p: </span><span class="s2">lambda </span><span class="s1">*a</span><span class="s2">, </span><span class="s1">**k: sparse.bcsr_concatenate(a</span><span class="s2">, </span><span class="s1">**k)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">for </span><span class="s1">prim</span><span class="s2">, </span><span class="s1">bcsr_impl </span><span class="s2">in </span><span class="s1">_BCSR_STANDARD_PRIMITIVES.items():</span>
  <span class="s1">sparse_rules_bcsr[prim] = _standard_sparse_rule(prim</span><span class="s2">, </span><span class="s1">bcsr_impl)</span>

<span class="s2">def </span><span class="s1">_integer_pow_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">y):</span>
  <span class="s2">if </span><span class="s1">y &lt;= </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;sparse rule for </span><span class="s2">{</span><span class="s1">lax.integer_pow_p</span><span class="s2">} </span><span class="s3">with non-positive exponent </span><span class="s2">{</span><span class="s1">y</span><span class="s2">} </span><span class="s3">is &quot;</span>
                              <span class="s3">&quot;not implemented because it would result in dense output. If this is your &quot;</span>
                              <span class="s3">&quot;intent, use sparse.todense() to convert your argument to a dense array.&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">_zero_preserving_unary_op(lax.integer_pow_p</span><span class="s2">, False</span><span class="s1">)(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">y=y)</span>

<span class="s1">sparse_rules_bcoo[lax.integer_pow_p] = _integer_pow_sparse</span>
<span class="s1">sparse_rules_bcsr[lax.integer_pow_p] = _integer_pow_sparse</span>

<span class="s2">def </span><span class="s1">_transpose_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">permutation):</span>
  <span class="s1">permutation = tuple(permutation)</span>
  <span class="s1">args = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues)</span>
  <span class="s1">shape = args[</span><span class="s5">0</span><span class="s1">].shape</span>
  <span class="s1">mat_transposed = sparse.bcoo_transpose(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">permutation=permutation)</span>
  <span class="s1">out_shape = tuple(shape[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">permutation)</span>

  <span class="s1">n_batch = args[</span><span class="s5">0</span><span class="s1">].indices.ndim - </span><span class="s5">2</span>
  <span class="s1">n_sparse = args[</span><span class="s5">0</span><span class="s1">].indices.shape[-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">batch_dims_unchanged = (permutation[:n_batch] == tuple(range(n_batch)))</span>
  <span class="s1">dense_dims_unchanged = (permutation[n_batch + n_sparse:] == tuple(range(n_batch + n_sparse</span><span class="s2">, </span><span class="s1">len(shape))))</span>
  <span class="s1">sparse_dims_unchanged = (permutation[n_batch:n_batch + n_sparse] == tuple(range(n_batch</span><span class="s2">, </span><span class="s1">n_batch + n_sparse)))</span>

  <span class="s0"># Data is unchanged if batch &amp; dense dims are not permuted</span>
  <span class="s1">kwds = {}</span>
  <span class="s2">if </span><span class="s1">batch_dims_unchanged </span><span class="s2">and </span><span class="s1">dense_dims_unchanged:</span>
    <span class="s1">kwds[</span><span class="s3">'data_ref'</span><span class="s1">] = spvalues[</span><span class="s5">0</span><span class="s1">].data_ref</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">kwds[</span><span class="s3">'data'</span><span class="s1">] = mat_transposed.data</span>

  <span class="s0"># Indices unchanged if batch &amp; sparse dims are not permuted</span>
  <span class="s2">if </span><span class="s1">batch_dims_unchanged </span><span class="s2">and </span><span class="s1">sparse_dims_unchanged:</span>
    <span class="s1">kwds[</span><span class="s3">'indices_ref'</span><span class="s1">] = spvalues[</span><span class="s5">0</span><span class="s1">].indices_ref</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">kwds[</span><span class="s3">'indices'</span><span class="s1">] = mat_transposed.indices</span>

  <span class="s1">kwds[</span><span class="s3">'indices_sorted'</span><span class="s1">] = mat_transposed.indices_sorted</span>
  <span class="s1">kwds[</span><span class="s3">'unique_indices'</span><span class="s1">] = mat_transposed.unique_indices</span>
  <span class="s1">spvalue = spenv.sparse(out_shape</span><span class="s2">, </span><span class="s1">**kwds)</span>
  <span class="s2">return </span><span class="s1">(spvalue</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.transpose_p] = _transpose_sparse</span>

<span class="s2">def </span><span class="s1">_add_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues):</span>
  <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = spvalues</span>
  <span class="s2">if </span><span class="s1">X.is_sparse() </span><span class="s2">and </span><span class="s1">Y.is_sparse():</span>
    <span class="s2">if </span><span class="s1">X.shape != Y.shape:</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Addition between sparse matrices of different shapes.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">X.indices_ref == Y.indices_ref:</span>
      <span class="s1">out_data = lax.add(spenv.data(X)</span><span class="s2">, </span><span class="s1">spenv.data(Y))</span>
      <span class="s2">if </span><span class="s1">config.jax_enable_checks:</span>
        <span class="s2">assert </span><span class="s1">X.indices_sorted == Y.indices_sorted</span>
        <span class="s2">assert </span><span class="s1">X.unique_indices == Y.unique_indices</span>
      <span class="s1">out_spvalue = spenv.sparse(X.shape</span><span class="s2">, </span><span class="s1">out_data</span><span class="s2">, </span><span class="s1">indices_ref=X.indices_ref</span><span class="s2">,</span>
                                 <span class="s1">indices_sorted=X.indices_sorted</span><span class="s2">,</span>
                                 <span class="s1">unique_indices=X.unique_indices)</span>
    <span class="s2">elif </span><span class="s1">spenv.indices(X).ndim != spenv.indices(Y).ndim </span><span class="s2">or </span><span class="s1">spenv.data(X).ndim != spenv.data(Y).ndim:</span>
      <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Addition between sparse matrices with different batch/dense dimensions.&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">out_indices = lax.concatenate([spenv.indices(X)</span><span class="s2">, </span><span class="s1">spenv.indices(Y)]</span><span class="s2">, </span><span class="s1">dimension=spenv.indices(X).ndim - </span><span class="s5">2</span><span class="s1">)</span>
      <span class="s1">out_data = lax.concatenate([spenv.data(X)</span><span class="s2">, </span><span class="s1">spenv.data(Y)]</span><span class="s2">, </span><span class="s1">dimension=spenv.indices(X).ndim - </span><span class="s5">2</span><span class="s1">)</span>
      <span class="s1">out_spvalue = spenv.sparse(X.shape</span><span class="s2">, </span><span class="s1">out_data</span><span class="s2">, </span><span class="s1">out_indices)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Addition between sparse and dense array.&quot;</span><span class="s1">)</span>

  <span class="s2">return </span><span class="s1">(out_spvalue</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.add_p] = _add_sparse</span>

<span class="s2">def </span><span class="s1">_sub_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues):</span>
  <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = spvalues</span>
  <span class="s2">if </span><span class="s1">X.is_sparse() </span><span class="s2">and </span><span class="s1">Y.is_sparse():</span>
    <span class="s2">return </span><span class="s1">_add_sparse(spenv</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">*sparse_rules_bcoo[lax.neg_p](spenv</span><span class="s2">, </span><span class="s1">Y))</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Subtraction between sparse and dense array.&quot;</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.sub_p] = _sub_sparse</span>

<span class="s2">def </span><span class="s1">_mul_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues):</span>
  <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = spvalues</span>
  <span class="s2">if </span><span class="s1">X.is_sparse() </span><span class="s2">and </span><span class="s1">Y.is_sparse():</span>
    <span class="s2">if </span><span class="s1">X.indices_ref == Y.indices_ref </span><span class="s2">and </span><span class="s1">X.unique_indices:</span>
      <span class="s2">if </span><span class="s1">config.jax_enable_checks:</span>
        <span class="s2">assert </span><span class="s1">X.indices_sorted == Y.indices_sorted</span>
        <span class="s2">assert </span><span class="s1">X.unique_indices == Y.unique_indices</span>
      <span class="s1">out_data = lax.mul(spenv.data(X)</span><span class="s2">, </span><span class="s1">spenv.data(Y))</span>
      <span class="s1">out_spvalue = spenv.sparse(X.shape</span><span class="s2">, </span><span class="s1">out_data</span><span class="s2">, </span><span class="s1">indices_ref=X.indices_ref</span><span class="s2">,</span>
                                 <span class="s1">indices_sorted=X.indices_sorted</span><span class="s2">,</span>
                                 <span class="s1">unique_indices=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">X_promoted</span><span class="s2">, </span><span class="s1">Y_promoted = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues)</span>
      <span class="s1">mat = bcoo_multiply_sparse(X_promoted</span><span class="s2">, </span><span class="s1">Y_promoted)</span>
      <span class="s1">out_spvalue = spenv.sparse(mat.shape</span><span class="s2">, </span><span class="s1">mat.data</span><span class="s2">, </span><span class="s1">mat.indices)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">Y.is_sparse():</span>
      <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = Y</span><span class="s2">, </span><span class="s1">X</span>
    <span class="s1">X_promoted = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">X)</span>
    <span class="s1">out_data = bcoo_multiply_dense(X_promoted</span><span class="s2">, </span><span class="s1">spenv.data(Y))</span>
    <span class="s1">out_spvalue = spenv.sparse(X.shape</span><span class="s2">, </span><span class="s1">out_data</span><span class="s2">, </span><span class="s1">indices_ref=X.indices_ref</span><span class="s2">,</span>
                               <span class="s1">indices_sorted=X.indices_sorted</span><span class="s2">,</span>
                               <span class="s1">unique_indices=X.unique_indices)</span>

  <span class="s2">return </span><span class="s1">(out_spvalue</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.mul_p] = _mul_sparse</span>

<span class="s2">def </span><span class="s1">_div_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues):</span>
  <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = spvalues</span>
  <span class="s2">if </span><span class="s1">Y.is_sparse():</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
      <span class="s3">&quot;Division by a sparse array is not implemented because it &quot;</span>
      <span class="s3">&quot;would result in dense output. If this is your intent, use &quot;</span>
      <span class="s3">&quot;sparse.todense() to convert your arguments to a dense array.&quot;</span><span class="s1">)</span>
  <span class="s1">X_promoted = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">X)</span>
  <span class="s1">out_data = bcoo_multiply_dense(X_promoted</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ spenv.data(Y))</span>
  <span class="s1">out_spvalue = spenv.sparse(X.shape</span><span class="s2">, </span><span class="s1">out_data</span><span class="s2">, </span><span class="s1">indices_ref=X.indices_ref</span><span class="s2">,</span>
                              <span class="s1">indices_sorted=X.indices_sorted</span><span class="s2">,</span>
                              <span class="s1">unique_indices=X.unique_indices)</span>
  <span class="s2">return </span><span class="s1">(out_spvalue</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.div_p] = _div_sparse</span>

<span class="s2">def </span><span class="s1">_reduce_sum_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">axes):</span>
  <span class="s1">X</span><span class="s2">, </span><span class="s1">= spvalues</span>
  <span class="s1">X_promoted = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">X)</span>
  <span class="s1">mat = sparse.bcoo_reduce_sum(X_promoted</span><span class="s2">, </span><span class="s1">axes=axes)</span>
  <span class="s1">out_shape = mat.shape</span>
  <span class="s2">if </span><span class="s1">out_shape == ():</span>
    <span class="s1">out_spvalue = spenv.dense(mat.data.sum())</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">out_spvalue = spenv.sparse(out_shape</span><span class="s2">, </span><span class="s1">mat.data</span><span class="s2">, </span><span class="s1">mat.indices)</span>
  <span class="s2">return </span><span class="s1">(out_spvalue</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[lax.reduce_sum_p] = _reduce_sum_sparse</span>


<span class="s2">def </span><span class="s1">_gather_sparse_rule(spenv</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">dimension_numbers</span><span class="s2">, </span><span class="s1">slice_sizes</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">,</span>
                        <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">fill_value):</span>
  <span class="s1">operand</span><span class="s2">, </span><span class="s1">start_indices = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">args)</span>
  <span class="s1">result = sparse.bcoo_gather(operand</span><span class="s2">, </span><span class="s1">start_indices</span><span class="s2">, </span><span class="s1">dimension_numbers=dimension_numbers</span><span class="s2">,</span>
                              <span class="s1">slice_sizes=slice_sizes</span><span class="s2">, </span><span class="s1">unique_indices=unique_indices</span><span class="s2">,</span>
                              <span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s2">,</span>
                              <span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">fill_value=fill_value)</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">(result</span><span class="s2">,</span><span class="s1">))</span>

<span class="s1">sparse_rules_bcoo[lax.gather_p] = _gather_sparse_rule</span>

<span class="s2">def </span><span class="s1">_sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">*spvalues):</span>
  <span class="s0"># TODO(jakevdp): currently this approach discards all information about</span>
  <span class="s0">#   shared data &amp; indices when generating the sparsified jaxpr. The</span>
  <span class="s0">#   current approach produces valid sparsified while loops, but they</span>
  <span class="s0">#   don't work in corner cases (see associated TODO in sparsify_test.py)</span>
  <span class="s1">out_tree: Optional[pytree.PyTreeDef] = </span><span class="s2">None</span>

  <span class="s1">@lu.wrap_init</span>
  <span class="s2">def </span><span class="s1">wrapped(*args_flat):</span>
    <span class="s0"># TODO(frostig,jakevdp): This closes over `spenv`, which can bring</span>
    <span class="s0"># in buffers from the &quot;outer scope&quot; as constants. Is this a</span>
    <span class="s0"># problem for primitives like cond and while_loop, which always</span>
    <span class="s0"># convert constvars to invars when staging out their subjaxprs?</span>
    <span class="s2">nonlocal </span><span class="s1">out_tree</span>
    <span class="s1">args = tree_unflatten(in_tree</span><span class="s2">, </span><span class="s1">args_flat)</span>
    <span class="s1">spvalues = arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">args)</span>
    <span class="s1">result = eval_sparse(jaxpr.jaxpr</span><span class="s2">, </span><span class="s1">jaxpr.consts</span><span class="s2">, </span><span class="s1">spvalues</span><span class="s2">, </span><span class="s1">spenv)</span>
    <span class="s1">out = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">result)</span>
    <span class="s1">out_flat</span><span class="s2">, </span><span class="s1">out_tree = tree_flatten(out)</span>
    <span class="s2">return </span><span class="s1">out_flat</span>

  <span class="s1">args = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues)</span>
  <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">in_tree = tree_flatten(args)</span>
  <span class="s1">avals_flat = [core.raise_to_shaped(core.get_aval(arg)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args_flat]</span>
  <span class="s1">sp_jaxpr</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(wrapped</span><span class="s2">, </span><span class="s1">avals_flat)</span>
  <span class="s1">sp_jaxpr = pe.ClosedJaxpr(sp_jaxpr</span><span class="s2">, </span><span class="s1">consts)</span>
  <span class="s2">assert </span><span class="s1">out_tree </span><span class="s2">is not None</span>
  <span class="s2">return </span><span class="s1">sp_jaxpr</span><span class="s2">, </span><span class="s1">out_tree</span>

<span class="s2">def </span><span class="s1">_while_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">cond_jaxpr</span><span class="s2">, </span><span class="s1">cond_nconsts</span><span class="s2">, </span><span class="s1">body_jaxpr</span><span class="s2">, </span><span class="s1">body_nconsts):</span>
  <span class="s1">cond_const_spvalues</span><span class="s2">, </span><span class="s1">body_const_spvalues</span><span class="s2">, </span><span class="s1">init_val_spvalues = split_list(</span>
    <span class="s1">spvalues</span><span class="s2">, </span><span class="s1">[cond_nconsts</span><span class="s2">, </span><span class="s1">body_nconsts])</span>

  <span class="s1">cond_sp_jaxpr</span><span class="s2">, </span><span class="s1">_ = _sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">cond_jaxpr</span><span class="s2">, </span><span class="s1">*cond_const_spvalues</span><span class="s2">, </span><span class="s1">*init_val_spvalues)</span>
  <span class="s1">body_sp_jaxpr</span><span class="s2">, </span><span class="s1">out_tree = _sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">body_jaxpr</span><span class="s2">, </span><span class="s1">*body_const_spvalues</span><span class="s2">, </span><span class="s1">*init_val_spvalues)</span>

  <span class="s1">cond_consts</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">cond_const_spvalues))</span>
  <span class="s1">body_consts</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">body_const_spvalues))</span>
  <span class="s1">init_vals</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">init_val_spvalues))</span>

  <span class="s1">out_flat = lax.while_p.bind(*cond_consts</span><span class="s2">, </span><span class="s1">*body_consts</span><span class="s2">, </span><span class="s1">*init_vals</span><span class="s2">,</span>
                              <span class="s1">cond_nconsts=len(cond_consts)</span><span class="s2">, </span><span class="s1">cond_jaxpr=cond_sp_jaxpr</span><span class="s2">,</span>
                              <span class="s1">body_nconsts=len(body_consts)</span><span class="s2">, </span><span class="s1">body_jaxpr=body_sp_jaxpr)</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">tree_unflatten(out_tree</span><span class="s2">, </span><span class="s1">out_flat))</span>

<span class="s1">sparse_rules_bcoo[lax.while_p] = _while_sparse</span>


<span class="s2">def </span><span class="s1">_pjit_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">out_shardings</span><span class="s2">,</span>
                 <span class="s1">resource_env</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">inline):</span>
  <span class="s2">if </span><span class="s1">any(donated_invars):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;sparse xla_call with donated_invars&quot;</span><span class="s1">)</span>

  <span class="s1">sp_call_jaxpr</span><span class="s2">, </span><span class="s1">out_tree = _sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">*spvalues)</span>
  <span class="s1">args_flat</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalues))</span>
  <span class="s1">donated_invars = tuple(</span><span class="s2">False for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args_flat)</span>

  <span class="s0"># TODO(yashkatariya, vanderplas): Flatten twice and set the correct sharding</span>
  <span class="s0"># for data and indices.</span>
  <span class="s1">in_shardings = in_shardings + tuple(</span>
      <span class="s1">pxla._UNSPECIFIED </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(len(args_flat) - len(in_shardings)))</span>
  <span class="s1">out_shardings = out_shardings + tuple(</span>
      <span class="s1">pxla._UNSPECIFIED </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(len(sp_call_jaxpr.out_avals) - len(out_shardings)))</span>

  <span class="s1">out_flat = pjit.pjit_p.bind(</span>
      <span class="s1">*args_flat</span><span class="s2">,</span>
      <span class="s1">jaxpr=sp_call_jaxpr</span><span class="s2">,</span>
      <span class="s1">in_shardings=in_shardings</span><span class="s2">,</span>
      <span class="s1">out_shardings=out_shardings</span><span class="s2">,</span>
      <span class="s1">resource_env=resource_env</span><span class="s2">,</span>
      <span class="s1">donated_invars=donated_invars</span><span class="s2">,</span>
      <span class="s1">name=name</span><span class="s2">,</span>
      <span class="s1">keep_unused=keep_unused</span><span class="s2">,</span>
      <span class="s1">inline=inline)</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">tree_unflatten(out_tree</span><span class="s2">, </span><span class="s1">out_flat))</span>

<span class="s1">sparse_rules_bcoo[pjit.pjit_p] = _pjit_sparse</span>


<span class="s2">def </span><span class="s1">_duplicate_for_sparse_spvalues(spvalues</span><span class="s2">, </span><span class="s1">params):</span>
  <span class="s2">for </span><span class="s1">spvalue</span><span class="s2">, </span><span class="s1">param </span><span class="s2">in </span><span class="s1">safe_zip(spvalues</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s2">yield from </span><span class="s1">[param</span><span class="s2">, </span><span class="s1">param] </span><span class="s2">if </span><span class="s1">spvalue.is_sparse() </span><span class="s2">else </span><span class="s1">[param]</span>

<span class="s2">def </span><span class="s1">_scan_sparse(spenv</span><span class="s2">, </span><span class="s1">*spvalues</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">num_consts</span><span class="s2">, </span><span class="s1">num_carry</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s1">const_spvalues</span><span class="s2">, </span><span class="s1">carry_spvalues</span><span class="s2">, </span><span class="s1">xs_spvalues = split_list(</span>
    <span class="s1">spvalues</span><span class="s2">, </span><span class="s1">[num_consts</span><span class="s2">, </span><span class="s1">num_carry])</span>
  <span class="s2">if </span><span class="s1">xs_spvalues:</span>
    <span class="s0"># TODO(jakevdp): we don't want to pass xs_spvalues, we want to pass one row</span>
    <span class="s0"># of xs spvalues. How to do this?</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;sparse rule for scan with x values.&quot;</span><span class="s1">)</span>
  <span class="s1">sp_jaxpr</span><span class="s2">, </span><span class="s1">_ = _sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">*const_spvalues</span><span class="s2">, </span><span class="s1">*carry_spvalues</span><span class="s2">, </span><span class="s1">*xs_spvalues)</span>

  <span class="s1">consts</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">const_spvalues))</span>
  <span class="s1">carry</span><span class="s2">, </span><span class="s1">carry_tree = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">carry_spvalues))</span>
  <span class="s1">xs</span><span class="s2">, </span><span class="s1">xs_tree = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">xs_spvalues))</span>

  <span class="s0"># params['linear'] has one entry per arg; expand it to match the sparsified args.</span>
  <span class="s1">const_linear</span><span class="s2">, </span><span class="s1">carry_linear</span><span class="s2">, </span><span class="s1">xs_linear = split_list(</span>
    <span class="s1">params.pop(</span><span class="s3">'linear'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[num_consts</span><span class="s2">, </span><span class="s1">num_carry])</span>
  <span class="s1">sp_linear = tuple([</span>
    <span class="s1">*_duplicate_for_sparse_spvalues(const_spvalues</span><span class="s2">, </span><span class="s1">const_linear)</span><span class="s2">,</span>
    <span class="s1">*_duplicate_for_sparse_spvalues(carry_spvalues</span><span class="s2">, </span><span class="s1">carry_linear)</span><span class="s2">,</span>
    <span class="s1">*_duplicate_for_sparse_spvalues(xs_spvalues</span><span class="s2">, </span><span class="s1">xs_linear)])</span>

  <span class="s1">out = lax.scan_p.bind(*consts</span><span class="s2">, </span><span class="s1">*carry</span><span class="s2">, </span><span class="s1">*xs</span><span class="s2">, </span><span class="s1">jaxpr=sp_jaxpr</span><span class="s2">, </span><span class="s1">linear=sp_linear</span><span class="s2">,</span>
                        <span class="s1">num_consts=len(consts)</span><span class="s2">, </span><span class="s1">num_carry=len(carry)</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s1">carry_out = tree_unflatten(carry_tree</span><span class="s2">, </span><span class="s1">out[:len(carry)])</span>
  <span class="s1">xs_out = tree_unflatten(xs_tree</span><span class="s2">, </span><span class="s1">out[len(carry):])</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">carry_out + xs_out)</span>

<span class="s1">sparse_rules_bcoo[lax.scan_p] = _scan_sparse</span>

<span class="s2">def </span><span class="s1">_cond_sparse(spenv</span><span class="s2">, </span><span class="s1">pred</span><span class="s2">, </span><span class="s1">*operands</span><span class="s2">, </span><span class="s1">branches</span><span class="s2">, </span><span class="s1">linear</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s1">sp_branches</span><span class="s2">, </span><span class="s1">treedefs = zip(*(_sparsify_jaxpr(spenv</span><span class="s2">, </span><span class="s1">jaxpr</span><span class="s2">, </span><span class="s1">*operands)</span>
                                <span class="s2">for </span><span class="s1">jaxpr </span><span class="s2">in </span><span class="s1">branches))</span>
  <span class="s1">_check_tree_and_avals(</span><span class="s3">&quot;sparsified true_fun and false_fun output&quot;</span><span class="s2">,</span>
                        <span class="s1">treedefs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sp_branches[</span><span class="s5">0</span><span class="s1">].out_avals</span><span class="s2">,</span>
                        <span class="s1">treedefs[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sp_branches[</span><span class="s5">1</span><span class="s1">].out_avals)</span>
  <span class="s1">sp_linear = tuple(_duplicate_for_sparse_spvalues(operands</span><span class="s2">, </span><span class="s1">linear))</span>
  <span class="s1">args</span><span class="s2">, </span><span class="s1">_ = tree_flatten(spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">(pred</span><span class="s2">, </span><span class="s1">*operands)))</span>
  <span class="s1">out_flat = lax.cond_p.bind(*args</span><span class="s2">, </span><span class="s1">branches=sp_branches</span><span class="s2">, </span><span class="s1">linear=sp_linear</span><span class="s2">, </span><span class="s1">**params)</span>
  <span class="s1">out = tree_unflatten(treedefs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">out_flat)</span>
  <span class="s2">return </span><span class="s1">arrays_to_spvalues(spenv</span><span class="s2">, </span><span class="s1">out)</span>

<span class="s1">sparse_rules_bcoo[lax.cond_p] = _cond_sparse</span>

<span class="s2">def </span><span class="s1">_todense_sparse_rule(spenv</span><span class="s2">, </span><span class="s1">spvalue</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">tree):</span>
  <span class="s2">del </span><span class="s1">tree  </span><span class="s0"># TODO(jakvdp): we should assert that tree is PytreeDef(*)</span>
  <span class="s1">out = spvalues_to_arrays(spenv</span><span class="s2">, </span><span class="s1">spvalue).todense()</span>
  <span class="s2">return </span><span class="s1">(spenv.dense(out)</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">sparse_rules_bcoo[sparse.todense_p] = _todense_sparse_rule</span>


<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># BCOO methods derived from sparsify</span>
<span class="s0"># defined here to avoid circular imports</span>

<span class="s2">def </span><span class="s1">_sum(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s4">&quot;&quot;&quot;Sum array along axis.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">sparsify(</span><span class="s2">lambda </span><span class="s1">x: x.sum(*args</span><span class="s2">, </span><span class="s1">**kwargs))(self)</span>

<span class="s2">def </span><span class="s1">_reshape(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s4">&quot;&quot;&quot;Sum array along axis.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">sparsify(</span><span class="s2">lambda </span><span class="s1">x: x.reshape(*args</span><span class="s2">, </span><span class="s1">**kwargs))(self)</span>

<span class="s2">def </span><span class="s1">_astype(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
  <span class="s4">&quot;&quot;&quot;Copy the array and cast to a specified dtype.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">sparsify(</span><span class="s2">lambda </span><span class="s1">x: x.astype(*args</span><span class="s2">, </span><span class="s1">**kwargs))(self)</span>

<span class="s2">def </span><span class="s1">_bcoo_rewriting_take(arr</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">indices_are_sorted=</span><span class="s2">False, </span><span class="s1">unique_indices=</span><span class="s2">False,</span>
                           <span class="s1">mode=</span><span class="s2">None, </span><span class="s1">fill_value=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s0"># Only sparsify the array argument; sparse indices not yet supported</span>
  <span class="s1">result = sparsify(functools.partial(</span>
    <span class="s1">lax_numpy._rewriting_take</span><span class="s2">, </span><span class="s1">idx=idx</span><span class="s2">, </span><span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s2">,</span>
    <span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">unique_indices=unique_indices</span><span class="s2">, </span><span class="s1">fill_value=fill_value))(arr)</span>
  <span class="s0"># Account for a corner case in the rewriting_take implementation.</span>
  <span class="s2">if not </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">BCOO) </span><span class="s2">and </span><span class="s1">np.size(result) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">result = BCOO.fromdense(result)</span>
  <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">_sparse_iter(arr):</span>
  <span class="s2">return </span><span class="s1">iter(arr[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(arr.shape[</span><span class="s5">0</span><span class="s1">]))</span>

<span class="s1">_swap_args = </span><span class="s2">lambda </span><span class="s1">f: </span><span class="s2">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b: f(b</span><span class="s2">, </span><span class="s1">a)</span>

<span class="s1">_bcoo_methods = {</span>
  <span class="s3">&quot;astype&quot;</span><span class="s1">: _astype</span><span class="s2">,</span>
  <span class="s3">&quot;reshape&quot;</span><span class="s1">: _reshape</span><span class="s2">,</span>
  <span class="s3">&quot;sum&quot;</span><span class="s1">: _sum</span><span class="s2">,</span>
  <span class="s3">&quot;__abs__&quot;</span><span class="s1">: sparsify(jnp.abs)</span><span class="s2">,</span>
  <span class="s3">&quot;__neg__&quot;</span><span class="s1">: sparsify(jnp.negative)</span><span class="s2">,</span>
  <span class="s3">&quot;__pos__&quot;</span><span class="s1">: sparsify(jnp.positive)</span><span class="s2">,</span>
  <span class="s3">&quot;__matmul__&quot;</span><span class="s1">: sparsify(jnp.matmul)</span><span class="s2">,</span>
  <span class="s3">&quot;__rmatmul__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.matmul))</span><span class="s2">,</span>
  <span class="s3">&quot;__mul__&quot;</span><span class="s1">: sparsify(jnp.multiply)</span><span class="s2">,</span>
  <span class="s3">&quot;__rmul__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.multiply))</span><span class="s2">,</span>
  <span class="s3">&quot;__truediv__&quot;</span><span class="s1">: sparsify(jnp.divide)</span><span class="s2">,</span>
  <span class="s3">&quot;__rtruediv__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.divide))</span><span class="s2">,</span>
  <span class="s3">&quot;__add__&quot;</span><span class="s1">: sparsify(jnp.add)</span><span class="s2">,</span>
  <span class="s3">&quot;__radd__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.add))</span><span class="s2">,</span>
  <span class="s3">&quot;__sub__&quot;</span><span class="s1">: sparsify(jnp.subtract)</span><span class="s2">,</span>
  <span class="s3">&quot;__rsub__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.subtract))</span><span class="s2">,</span>
  <span class="s3">&quot;__pow__&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: sparsify(</span><span class="s2">lambda </span><span class="s1">x: jnp.power(x</span><span class="s2">, </span><span class="s1">y))(x)</span><span class="s2">,</span>
  <span class="s3">&quot;__rpow__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.power))</span><span class="s2">,</span>
  <span class="s3">&quot;__getitem__&quot;</span><span class="s1">: _bcoo_rewriting_take</span><span class="s2">,</span>
  <span class="s3">&quot;__iter__&quot;</span><span class="s1">: _sparse_iter</span><span class="s2">,</span>
  <span class="s3">&quot;__gt__&quot;</span><span class="s1">: sparsify(jnp.greater)</span><span class="s2">,</span>
  <span class="s3">&quot;__ge__&quot;</span><span class="s1">: sparsify(jnp.greater_equal)</span><span class="s2">,</span>
  <span class="s3">&quot;__lt__&quot;</span><span class="s1">: sparsify(jnp.less)</span><span class="s2">,</span>
  <span class="s3">&quot;__le__&quot;</span><span class="s1">: sparsify(jnp.less_equal)</span><span class="s2">,</span>
  <span class="s3">&quot;__eq__&quot;</span><span class="s1">: sparsify(jnp.equal)</span><span class="s2">,</span>
  <span class="s3">&quot;__ne__&quot;</span><span class="s1">: sparsify(jnp.not_equal)</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">for </span><span class="s1">method</span><span class="s2">, </span><span class="s1">impl </span><span class="s2">in </span><span class="s1">_bcoo_methods.items():</span>
  <span class="s1">setattr(BCOO</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">impl)</span>

<span class="s0"># ------------------------------------------------------------------------------</span>
<span class="s0"># BCSR methods derived from sparsify</span>
<span class="s0"># defined here to avoid circular imports</span>

<span class="s2">def </span><span class="s1">_bcsr_rewriting_take(arr</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">indices_are_sorted=</span><span class="s2">False, </span><span class="s1">unique_indices=</span><span class="s2">False,</span>
                           <span class="s1">mode=</span><span class="s2">None, </span><span class="s1">fill_value=</span><span class="s2">None</span><span class="s1">):</span>
  <span class="s0"># Only sparsify the array argument; sparse indices not yet supported</span>
  <span class="s1">result = sparsify(functools.partial(</span>
    <span class="s1">lax_numpy._rewriting_take</span><span class="s2">, </span><span class="s1">idx=idx</span><span class="s2">, </span><span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s2">,</span>
    <span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">unique_indices=unique_indices</span><span class="s2">, </span><span class="s1">fill_value=fill_value))(arr)</span>
  <span class="s2">return </span><span class="s1">result</span>

<span class="s1">_bcoo_methods = {</span>
  <span class="s3">&quot;__matmul__&quot;</span><span class="s1">: sparsify(jnp.matmul)</span><span class="s2">,</span>
  <span class="s3">&quot;__rmatmul__&quot;</span><span class="s1">: sparsify(_swap_args(jnp.matmul))</span><span class="s2">,</span>
  <span class="s3">&quot;__getitem__&quot;</span><span class="s1">: _bcsr_rewriting_take</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">for </span><span class="s1">method</span><span class="s2">, </span><span class="s1">impl </span><span class="s2">in </span><span class="s1">_bcoo_methods.items():</span>
  <span class="s1">setattr(BCSR</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">impl)</span>
</pre>
</body>
</html>