<html>
<head>
<title>profiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
profiler.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>
<span class="s2">import </span><span class="s1">glob</span>
<span class="s2">import </span><span class="s1">gzip</span>
<span class="s2">import </span><span class="s1">http.server</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">socketserver</span>
<span class="s2">import </span><span class="s1">threading</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Optional</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">xla_bridge</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client</span>

<span class="s1">_profiler_server: Optional[xla_client.profiler.ProfilerServer] = </span><span class="s2">None</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">start_server(port: int) -&gt; xla_client.profiler.ProfilerServer:</span>
  <span class="s3">&quot;&quot;&quot;Starts the profiler server on port `port`. 
 
  Using the &quot;TensorFlow profiler&quot; feature in `TensorBoard 
  &lt;https://www.tensorflow.org/tensorboard&gt;`_ 2.2 or newer, you can 
  connect to the profiler server and sample execution traces that show CPU, 
  GPU, and/or TPU device activity. 
  &quot;&quot;&quot;</span>
  <span class="s2">global </span><span class="s1">_profiler_server</span>
  <span class="s2">if </span><span class="s1">_profiler_server </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only one profiler server can be active at a time.&quot;</span><span class="s1">)</span>

  <span class="s0"># Make sure backends are initialized before creating a profiler</span>
  <span class="s0"># session. Otherwise on Cloud TPU, libtpu may not be initialized before</span>
  <span class="s0"># creating the tracer, which will cause the TPU tracer initialization to</span>
  <span class="s0"># fail and no TPU operations will be included in the profile.</span>
  <span class="s0"># NOTE(skyewm): I'm not sure this is necessary for start_server (is definitely</span>
  <span class="s0"># is for start_trace), but I'm putting it here to be safe.</span>
  <span class="s1">xla_bridge.get_backend()</span>

  <span class="s1">_profiler_server = xla_client.profiler.start_server(port)</span>
  <span class="s2">return </span><span class="s1">_profiler_server</span>


<span class="s2">def </span><span class="s1">stop_server():</span>
  <span class="s3">&quot;&quot;&quot;Stops the running profiler server.&quot;&quot;&quot;</span>
  <span class="s2">global </span><span class="s1">_profiler_server</span>
  <span class="s2">if </span><span class="s1">_profiler_server </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No active profiler server.&quot;</span><span class="s1">)</span>
  <span class="s1">_profiler_server = </span><span class="s2">None </span><span class="s0"># Should destroy the profiler server</span>


<span class="s2">class </span><span class="s1">_ProfileState:</span>
  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.profile_session = </span><span class="s2">None</span>
    <span class="s1">self.log_dir = </span><span class="s2">None</span>
    <span class="s1">self.create_perfetto_link = </span><span class="s2">False</span>
    <span class="s1">self.create_perfetto_trace = </span><span class="s2">False</span>
    <span class="s1">self.lock = threading.Lock()</span>

<span class="s1">_profile_state = _ProfileState()</span>


<span class="s2">def </span><span class="s1">start_trace(log_dir</span><span class="s2">, </span><span class="s1">create_perfetto_link: bool = </span><span class="s2">False,</span>
                <span class="s1">create_perfetto_trace: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
  <span class="s3">&quot;&quot;&quot;Starts a profiler trace. 
 
  The trace will capture CPU, GPU, and/or TPU activity, including Python 
  functions and JAX on-device operations. Use :func:`stop_trace` to end the trace 
  and save the results to ``log_dir``. 
 
  The resulting trace can be viewed with TensorBoard. Note that TensorBoard 
  doesn't need to be running when collecting the trace. 
 
  Only once trace may be collected a time. A RuntimeError will be raised if 
  :func:`start_trace` is called while another trace is running. 
 
  Args: 
    log_dir: The directory to save the profiler trace to (usually the 
      TensorBoard log directory). 
    create_perfetto_link: A boolean which, if true, creates and prints link to 
      the Perfetto trace viewer UI (https://ui.perfetto.dev). The program will 
      block until the link is opened and Perfetto loads the trace. 
    create_perfetto_trace: A boolean which, if true, additionally dumps a 
      ``perfetto_trace.json.gz`` file that is compatible for upload with the 
      Perfetto trace viewer UI (https://ui.perfetto.dev). The file will also be 
      generated if ``create_perfetto_link`` is true. This could be useful if you 
      want to generate a Perfetto-compatible trace without blocking the 
      processs. 
  &quot;&quot;&quot;</span>
  <span class="s2">with </span><span class="s1">_profile_state.lock:</span>
    <span class="s2">if </span><span class="s1">_profile_state.profile_session </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Profile has already been started. &quot;</span>
                         <span class="s4">&quot;Only one profile may be run at a time.&quot;</span><span class="s1">)</span>
    <span class="s0"># Make sure backends are initialized before creating a profiler</span>
    <span class="s0"># session. Otherwise on Cloud TPU, libtpu may not be initialized before</span>
    <span class="s0"># creating the tracer, which will cause the TPU tracer initialization to</span>
    <span class="s0"># fail and no TPU operations will be included in the profile.</span>
    <span class="s1">xla_bridge.get_backend()</span>

    <span class="s1">_profile_state.profile_session = xla_client.profiler.ProfilerSession()</span>
    <span class="s1">_profile_state.create_perfetto_link = create_perfetto_link</span>
    <span class="s1">_profile_state.create_perfetto_trace = (</span>
        <span class="s1">create_perfetto_trace </span><span class="s2">or </span><span class="s1">create_perfetto_link)</span>
    <span class="s1">_profile_state.log_dir = log_dir</span>


<span class="s2">def </span><span class="s1">_write_perfetto_trace_file(log_dir):</span>
  <span class="s0"># Navigate to folder with the latest trace dump to find `trace.json.jz`</span>
  <span class="s1">curr_path = os.path.abspath(log_dir)</span>
  <span class="s1">root_trace_folder = os.path.join(curr_path</span><span class="s2">, </span><span class="s4">&quot;plugins&quot;</span><span class="s2">, </span><span class="s4">&quot;profile&quot;</span><span class="s1">)</span>
  <span class="s1">trace_folders = [os.path.join(root_trace_folder</span><span class="s2">, </span><span class="s1">trace_folder) </span><span class="s2">for</span>
      <span class="s1">trace_folder </span><span class="s2">in </span><span class="s1">os.listdir(root_trace_folder)]</span>
  <span class="s1">latest_folder = max(trace_folders</span><span class="s2">, </span><span class="s1">key=os.path.getmtime)</span>
  <span class="s1">trace_jsons = glob.glob(os.path.join(latest_folder</span><span class="s2">, </span><span class="s4">&quot;*.trace.json.gz&quot;</span><span class="s1">))</span>
  <span class="s2">if </span><span class="s1">len(trace_jsons) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid trace folder: </span><span class="s2">{</span><span class="s1">latest_folder</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">trace_json</span><span class="s2">, </span><span class="s1">= trace_jsons</span>

  <span class="s1">logger.info(</span><span class="s4">&quot;Loading trace.json.gz and removing its metadata...&quot;</span><span class="s1">)</span>
  <span class="s0"># Perfetto doesn't like the `metadata` field in `trace.json` so we remove</span>
  <span class="s0"># it.</span>
  <span class="s0"># TODO(sharadmv): speed this up by updating the generated `trace.json`</span>
  <span class="s0"># to not include metadata if possible.</span>
  <span class="s2">with </span><span class="s1">gzip.open(trace_json</span><span class="s2">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
    <span class="s1">trace = json.load(fp)</span>
    <span class="s2">del </span><span class="s1">trace[</span><span class="s4">&quot;metadata&quot;</span><span class="s1">]</span>
  <span class="s1">filename = </span><span class="s4">&quot;perfetto_trace.json.gz&quot;</span>
  <span class="s1">perfetto_trace = os.path.join(latest_folder</span><span class="s2">, </span><span class="s1">filename)</span>
  <span class="s1">logger.info(</span><span class="s4">&quot;Writing perfetto_trace.json.gz...&quot;</span><span class="s1">)</span>
  <span class="s2">with </span><span class="s1">gzip.open(perfetto_trace</span><span class="s2">, </span><span class="s4">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
    <span class="s1">fp.write(json.dumps(trace).encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">))</span>
  <span class="s2">return </span><span class="s1">perfetto_trace</span>

<span class="s2">class </span><span class="s1">_PerfettoServer(http.server.SimpleHTTPRequestHandler):</span>
  <span class="s3">&quot;&quot;&quot;Handles requests from `ui.perfetto.dev` for the `trace.json`&quot;&quot;&quot;</span>

  <span class="s2">def </span><span class="s1">end_headers(self):</span>
    <span class="s1">self.send_header(</span><span class="s4">'Access-Control-Allow-Origin'</span><span class="s2">, </span><span class="s4">'*'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">super().end_headers()</span>

  <span class="s2">def </span><span class="s1">do_GET(self):</span>
    <span class="s1">self.server.last_request = self.path</span>
    <span class="s2">return </span><span class="s1">super().do_GET()</span>

  <span class="s2">def </span><span class="s1">do_POST(self):</span>
    <span class="s1">self.send_error(</span><span class="s5">404</span><span class="s2">, </span><span class="s4">&quot;File not found&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_host_perfetto_trace_file(path):</span>
  <span class="s0"># ui.perfetto.dev looks for files hosted on `127.0.0.1:9001`. We set up a</span>
  <span class="s0"># TCP server that is hosting the `perfetto_trace.json.gz` file.</span>
  <span class="s1">port = </span><span class="s5">9001</span>
  <span class="s1">orig_directory = os.path.abspath(os.getcwd())</span>
  <span class="s1">directory</span><span class="s2">, </span><span class="s1">filename = os.path.split(path)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">os.chdir(directory)</span>
    <span class="s1">socketserver.TCPServer.allow_reuse_address = </span><span class="s2">True</span>
    <span class="s2">with </span><span class="s1">socketserver.TCPServer((</span><span class="s4">'127.0.0.1'</span><span class="s2">, </span><span class="s1">port)</span><span class="s2">, </span><span class="s1">_PerfettoServer) </span><span class="s2">as </span><span class="s1">httpd:</span>
      <span class="s1">url = </span><span class="s4">f&quot;https://ui.perfetto.dev/#!/?url=http://127.0.0.1:</span><span class="s2">{</span><span class="s1">port</span><span class="s2">}</span><span class="s4">/</span><span class="s2">{</span><span class="s1">filename</span><span class="s2">}</span><span class="s4">&quot;</span>
      <span class="s1">print(</span><span class="s4">f&quot;Open URL in browser: </span><span class="s2">{</span><span class="s1">url</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

      <span class="s0"># Once ui.perfetto.dev acquires trace.json from this server we can close</span>
      <span class="s0"># it down.</span>
      <span class="s2">while </span><span class="s1">httpd.__dict__.get(</span><span class="s4">'last_request'</span><span class="s1">) != </span><span class="s4">'/' </span><span class="s1">+ filename:</span>
        <span class="s1">httpd.handle_request()</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">os.chdir(orig_directory)</span>

<span class="s2">def </span><span class="s1">stop_trace():</span>
  <span class="s3">&quot;&quot;&quot;Stops the currently-running profiler trace. 
 
  The trace will be saved to the ``log_dir`` passed to the corresponding 
  :func:`start_trace` call. Raises a RuntimeError if a trace hasn't been started. 
  &quot;&quot;&quot;</span>
  <span class="s2">with </span><span class="s1">_profile_state.lock:</span>
    <span class="s2">if </span><span class="s1">_profile_state.profile_session </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;No profile started&quot;</span><span class="s1">)</span>
    <span class="s1">_profile_state.profile_session.stop_and_export(_profile_state.log_dir)</span>
    <span class="s2">if </span><span class="s1">_profile_state.create_perfetto_trace:</span>
      <span class="s1">abs_filename = _write_perfetto_trace_file(_profile_state.log_dir)</span>
      <span class="s2">if </span><span class="s1">_profile_state.create_perfetto_link:</span>
        <span class="s1">_host_perfetto_trace_file(abs_filename)</span>
    <span class="s1">_profile_state.profile_session = </span><span class="s2">None</span>
    <span class="s1">_profile_state.create_perfetto_link = </span><span class="s2">False</span>
    <span class="s1">_profile_state.create_perfetto_trace = </span><span class="s2">False</span>
    <span class="s1">_profile_state.log_dir = </span><span class="s2">None</span>


<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">trace(log_dir</span><span class="s2">, </span><span class="s1">create_perfetto_link=</span><span class="s2">False, </span><span class="s1">create_perfetto_trace=</span><span class="s2">False</span><span class="s1">):</span>
  <span class="s3">&quot;&quot;&quot;Context manager to take a profiler trace. 
 
  The trace will capture CPU, GPU, and/or TPU activity, including Python 
  functions and JAX on-device operations. 
 
  The resulting trace can be viewed with TensorBoard. Note that TensorBoard 
  doesn't need to be running when collecting the trace. 
 
  Only once trace may be collected a time. A RuntimeError will be raised if a 
  trace is started while another trace is running. 
 
  Args: 
    log_dir: The directory to save the profiler trace to (usually the 
      TensorBoard log directory). 
    create_perfetto_link: A boolean which, if true, creates and prints link to 
      the Perfetto trace viewer UI (https://ui.perfetto.dev). The program will 
      block until the link is opened and Perfetto loads the trace. 
    create_perfetto_trace: A boolean which, if true, additionally dumps a 
      ``perfetto_trace.json.gz`` file that is compatible for upload with the 
      Perfetto trace viewer UI (https://ui.perfetto.dev). The file will also be 
      generated if ``create_perfetto_link`` is true. This could be useful if you 
      want to generate a Perfetto-compatible trace without blocking the 
      processs. 
  &quot;&quot;&quot;</span>
  <span class="s1">start_trace(log_dir</span><span class="s2">, </span><span class="s1">create_perfetto_link</span><span class="s2">, </span><span class="s1">create_perfetto_trace)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">yield</span>
  <span class="s2">finally</span><span class="s1">:</span>
    <span class="s1">stop_trace()</span>


<span class="s2">class </span><span class="s1">TraceAnnotation(xla_client.profiler.TraceMe):</span>
  <span class="s3">&quot;&quot;&quot;Context manager that generates a trace event in the profiler. 
 
  The trace event spans the duration of the code enclosed by the context. 
 
  For example: 
 
  &gt;&gt;&gt; x = jnp.ones((1000, 1000)) 
  &gt;&gt;&gt; with jax.profiler.TraceAnnotation(&quot;my_label&quot;): 
  ...   result = jnp.dot(x, x.T).block_until_ready() 
 
  This will cause a &quot;my_label&quot; event to show up on the trace timeline if the 
  event occurs while the process is being traced. 
  &quot;&quot;&quot;</span>
  <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">StepTraceAnnotation(TraceAnnotation):</span>
  <span class="s3">&quot;&quot;&quot;Context manager that generates a step trace event in the profiler. 
 
  The step trace event spans the duration of the code enclosed by the context. 
  The profiler will provide the performance analysis for each step trace event. 
 
  For example, it can be used to mark training steps and enable the profiler to 
  provide the performance analysis per step: 
 
  &gt;&gt;&gt; while global_step &lt; NUM_STEPS:                                           # doctest: +SKIP 
  ...   with jax.profiler.StepTraceAnnotation(&quot;train&quot;, step_num=global_step):  # doctest: +SKIP 
  ...     train_step()                                                         # doctest: +SKIP 
  ...     global_step += 1                                                     # doctest: +SKIP 
 
  This will cause a &quot;train xx&quot; event to show up on the trace timeline if the 
  event occurs while the process is being traced by TensorBoard. In addition, 
  if using accelerators, the device trace timeline will also show a &quot;train xx&quot; 
  event. Note that &quot;step_num&quot; can be set as a keyword argument to pass the 
  global step number to the profiler. 
 
  &quot;&quot;&quot;</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">_r=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">annotate_function(func: Callable</span><span class="s2">, </span><span class="s1">name: Optional[str] = </span><span class="s2">None,</span>
                      <span class="s1">**decorator_kwargs):</span>
  <span class="s3">&quot;&quot;&quot;Decorator that generates a trace event for the execution of a function. 
 
  For example: 
 
  &gt;&gt;&gt; @jax.profiler.annotate_function 
  ... def f(x): 
  ...   return jnp.dot(x, x.T).block_until_ready() 
  &gt;&gt;&gt; 
  &gt;&gt;&gt; result = f(jnp.ones((1000, 1000))) 
 
  This will cause an &quot;f&quot; event to show up on the trace timeline if the 
  function execution occurs while the process is being traced by TensorBoard. 
 
  Arguments can be passed to the decorator via :py:func:`functools.partial`. 
 
  &gt;&gt;&gt; from functools import partial 
 
  &gt;&gt;&gt; @partial(jax.profiler.annotate_function, name=&quot;event_name&quot;) 
  ... def f(x): 
  ...   return jnp.dot(x, x.T).block_until_ready() 
 
  &gt;&gt;&gt; result = f(jnp.ones((1000, 1000))) 
  &quot;&quot;&quot;</span>

  <span class="s1">name = name </span><span class="s2">or </span><span class="s1">getattr(func</span><span class="s2">, </span><span class="s4">'__qualname__'</span><span class="s2">, None</span><span class="s1">)</span>
  <span class="s1">name = name </span><span class="s2">or </span><span class="s1">func.__name__</span>
  <span class="s1">@wraps(func)</span>
  <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">with </span><span class="s1">TraceAnnotation(name</span><span class="s2">, </span><span class="s1">**decorator_kwargs):</span>
      <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">return </span><span class="s1">wrapper</span>
  <span class="s2">return </span><span class="s1">wrapper</span>



<span class="s2">def </span><span class="s1">device_memory_profile(backend: Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; bytes:</span>
  <span class="s3">&quot;&quot;&quot;Captures a JAX device memory profile as ``pprof``-format protocol buffer. 
 
  A device memory profile is a snapshot of the state of memory, that describes the JAX 
  :class:`jax.DeviceArray` and executable objects present in memory and their 
  allocation sites. 
 
  For more information how to use the device memory profiler, see 
  :doc:`/device_memory_profiling`. 
 
  The profiling system works by instrumenting JAX on-device allocations, 
  capturing a Python stack trace for each allocation. The instrumentation is 
  always enabled; :func:`device_memory_profile` provides an API to capture it. 
 
  The output of :func:`device_memory_profile` is a binary protocol buffer that 
  can be interpreted and visualized by the `pprof tool 
  &lt;https://github.com/google/pprof&gt;`_. 
 
  Args: 
    backend: optional; the name of the JAX backend for which the device memory 
      profile should be collected. 
 
  Returns: 
    A byte string containing a binary `pprof`-format protocol buffer. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">xla_client.heap_profile(xla_bridge.get_backend(backend))</span>


<span class="s2">def </span><span class="s1">save_device_memory_profile(filename</span><span class="s2">, </span><span class="s1">backend: Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
  <span class="s3">&quot;&quot;&quot;Collects a device memory profile and writes it to a file. 
 
  :func:`save_device_memory_profile` is a convenience wrapper around :func:`device_memory_profile` 
  that saves its output to a ``filename``. See the 
  :func:`device_memory_profile` documentation for more information. 
 
  Args: 
    filename: the filename to which the profile should be written. 
    backend: optional; the name of the JAX backend for which the device memory 
      profile should be collected. 
  &quot;&quot;&quot;</span>
  <span class="s1">profile = device_memory_profile(backend)</span>
  <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s4">&quot;wb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
    <span class="s1">f.write(profile)</span>
</pre>
</body>
</html>