<html>
<head>
<title>lax_numpy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lax_numpy.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s0"># pytype: skip-file</span>
<span class="s2">&quot;&quot;&quot; 
Implements the NumPy API, using the primitives in :mod:`jax.lax`. 
 
NumPy operations are implemented in Python in terms of the primitive operations 
in :mod:`jax.lax`. Since NumPy operations are not primitive and instead are 
implemented in terms of :mod:`jax.lax` operations, we do not need to define 
transformation rules such as gradient or batching rules. Instead, 
transformations for NumPy primitives can be derived from the transformation 
rules for the underlying :code:`lax` primitives. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">builtins</span>
<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">import </span><span class="s1">math</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">types</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">(</span>
  <span class="s1">overload</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">FrozenSet</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">,</span>
  <span class="s1">NamedTuple</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">TypeVar</span><span class="s3">, </span><span class="s1">Union)</span>
<span class="s3">from </span><span class="s1">textwrap </span><span class="s3">import </span><span class="s1">dedent </span><span class="s3">as </span><span class="s1">_dedent</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">opt_einsum</span>

<span class="s3">import </span><span class="s1">jax</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">jit</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">errors</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax.tree_util </span><span class="s3">import </span><span class="s1">tree_leaves</span><span class="s3">, </span><span class="s1">tree_flatten</span><span class="s3">, </span><span class="s1">tree_map</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">api_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">device_array</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax._src.api_util </span><span class="s3">import </span><span class="s1">_ensure_index_tuple</span>
<span class="s3">from </span><span class="s1">jax._src.core </span><span class="s3">import </span><span class="s1">ShapedArray</span><span class="s3">, </span><span class="s1">ConcreteArray</span>
<span class="s3">from </span><span class="s1">jax._src.lax.lax </span><span class="s3">import </span><span class="s1">(_array_copy</span><span class="s3">, </span><span class="s1">_sort_lt_comparator</span><span class="s3">,</span>
                              <span class="s1">_sort_le_comparator</span><span class="s3">, </span><span class="s1">PrecisionLike)</span>
<span class="s3">from </span><span class="s1">jax._src.lax </span><span class="s3">import </span><span class="s1">lax </span><span class="s3">as </span><span class="s1">lax_internal</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">xla_client</span>
<span class="s3">from </span><span class="s1">jax._src.numpy </span><span class="s3">import </span><span class="s1">reductions</span>
<span class="s3">from </span><span class="s1">jax._src.numpy </span><span class="s3">import </span><span class="s1">ufuncs</span>
<span class="s3">from </span><span class="s1">jax._src.numpy </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">jax._src.numpy.vectorize </span><span class="s3">import </span><span class="s1">vectorize</span>
<span class="s3">from </span><span class="s1">jax._src.typing </span><span class="s3">import </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">ArrayLike</span><span class="s3">, </span><span class="s1">DimSize</span><span class="s3">, </span><span class="s1">DType</span><span class="s3">, </span><span class="s1">DTypeLike</span><span class="s3">, </span><span class="s1">Shape</span>
<span class="s3">from </span><span class="s1">jax._src.util </span><span class="s3">import </span><span class="s1">(unzip2</span><span class="s3">, </span><span class="s1">subvals</span><span class="s3">, </span><span class="s1">safe_zip</span><span class="s3">,</span>
                           <span class="s1">ceil_of_ratio</span><span class="s3">, </span><span class="s1">partition_list</span><span class="s3">,</span>
                           <span class="s1">canonicalize_axis </span><span class="s3">as </span><span class="s1">_canonicalize_axis)</span>
<span class="s3">from </span><span class="s1">jax._src.array </span><span class="s3">import </span><span class="s1">ArrayImpl</span>

<span class="s1">newaxis = </span><span class="s3">None</span>
<span class="s1">T = TypeVar(</span><span class="s4">'T'</span><span class="s1">)</span>


<span class="s0"># Like core.canonicalize_shape, but also accept int-like (non-sequence)</span>
<span class="s0"># arguments for `shape`.</span>
<span class="s3">def </span><span class="s1">canonicalize_shape(shape: Any</span><span class="s3">, </span><span class="s1">context: str=</span><span class="s4">&quot;&quot;</span><span class="s1">) -&gt; core.Shape:</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">isinstance(shape</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)) </span><span class="s3">and</span>
      <span class="s1">(getattr(shape</span><span class="s3">, </span><span class="s4">'ndim'</span><span class="s3">, None</span><span class="s1">) == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ndim(shape) == </span><span class="s5">0</span><span class="s1">)):</span>
    <span class="s3">return </span><span class="s1">core.canonicalize_shape((shape</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">context)  </span><span class="s0"># type: ignore</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">core.canonicalize_shape(shape</span><span class="s3">, </span><span class="s1">context)  </span><span class="s0"># type: ignore</span>

<span class="s0"># Common docstring additions:</span>

<span class="s1">_PRECISION_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">In addition to the original NumPy arguments listed below, also supports 
``precision`` for extra control over matrix-multiplication precision 
on supported devices. ``precision`` may be set to ``None``, which means 
default precision for the backend, a :class:`~jax.lax.Precision` enum value 
(``Precision.DEFAULT``, ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple 
of two :class:`~jax.lax.Precision` enums indicating separate precision for each argument. 
&quot;&quot;&quot;</span>

<span class="s0"># Some objects below rewrite their __module__ attribute to this name.</span>
<span class="s1">_PUBLIC_MODULE_NAME = </span><span class="s4">&quot;jax.numpy&quot;</span>

<span class="s0"># We replace some builtin names to follow Numpy's API, so we capture here.</span>
<span class="s1">_abs = builtins.abs</span>
<span class="s1">_all = builtins.all</span>
<span class="s1">_any = builtins.any</span>
<span class="s1">_max = builtins.max</span>
<span class="s1">_min = builtins.min</span>
<span class="s1">_sum = builtins.sum</span>
<span class="s1">_divmod = builtins.divmod</span>

<span class="s0"># NumPy constants</span>

<span class="s1">pi = np.pi</span>
<span class="s1">e = np.e</span>
<span class="s1">euler_gamma = np.euler_gamma</span>
<span class="s1">inf = np.inf</span>
<span class="s1">NINF = np.NINF</span>
<span class="s1">PZERO = np.PZERO</span>
<span class="s1">NZERO = np.NZERO</span>
<span class="s1">nan = np.nan</span>

<span class="s0"># NumPy utility functions</span>

<span class="s1">get_printoptions = np.get_printoptions</span>
<span class="s1">printoptions = np.printoptions</span>
<span class="s1">set_printoptions = np.set_printoptions</span>

<span class="s1">@util._wraps(np.iscomplexobj)</span>
<span class="s3">def </span><span class="s1">iscomplexobj(x: Any) -&gt; bool:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">typ = x.dtype.type</span>
  <span class="s3">except </span><span class="s1">AttributeError:</span>
    <span class="s1">typ = asarray(x).dtype.type</span>
  <span class="s3">return </span><span class="s1">issubdtype(typ</span><span class="s3">, </span><span class="s1">complexfloating)</span>

<span class="s1">shape = _shape = np.shape</span>
<span class="s1">ndim = _ndim = np.ndim</span>
<span class="s1">size = np.size</span>

<span class="s3">def </span><span class="s1">_dtype(x: Any) -&gt; DType:</span>
  <span class="s3">return </span><span class="s1">dtypes.dtype(x</span><span class="s3">, </span><span class="s1">canonicalize=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s0"># At present JAX doesn't have a reason to distinguish between scalars and arrays</span>
<span class="s0"># in its object system. Further, we want JAX scalars to have the same type</span>
<span class="s0"># promotion behaviors as JAX arrays. Rather than introducing a new type of JAX</span>
<span class="s0"># scalar object with JAX promotion behaviors, instead we make the JAX scalar</span>
<span class="s0"># types return JAX arrays when instantiated.</span>

<span class="s3">class </span><span class="s1">_ScalarMeta(type):</span>
  <span class="s1">dtype: np.dtype</span>

  <span class="s3">def </span><span class="s1">__hash__(self) -&gt; int:</span>
    <span class="s3">return </span><span class="s1">hash(self.dtype.type)</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other: Any) -&gt; bool:</span>
    <span class="s3">return </span><span class="s1">id(self) == id(other) </span><span class="s3">or </span><span class="s1">self.dtype.type == other</span>

  <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other: Any) -&gt; bool:</span>
    <span class="s3">return not </span><span class="s1">(self == other)</span>

  <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">x: Any) -&gt; Array:</span>
    <span class="s3">return </span><span class="s1">asarray(x</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>

  <span class="s3">def </span><span class="s1">__instancecheck__(self</span><span class="s3">, </span><span class="s1">instance: Any) -&gt; bool:</span>
    <span class="s3">return </span><span class="s1">isinstance(instance</span><span class="s3">, </span><span class="s1">self.dtype.type)</span>

<span class="s3">def </span><span class="s1">_abstractify_scalar_meta(x):</span>
  <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;JAX scalar type </span><span class="s3">{</span><span class="s1">x</span><span class="s3">} </span><span class="s4">cannot be interpreted as a JAX array.&quot;</span><span class="s1">)</span>
<span class="s1">api_util._shaped_abstractify_handlers[_ScalarMeta] = _abstractify_scalar_meta</span>

<span class="s3">def </span><span class="s1">_make_scalar_type(np_scalar_type: type) -&gt; _ScalarMeta:</span>
  <span class="s1">meta = _ScalarMeta(np_scalar_type.__name__</span><span class="s3">, </span><span class="s1">(object</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                     <span class="s1">{</span><span class="s4">&quot;dtype&quot;</span><span class="s1">: np.dtype(np_scalar_type)})</span>
  <span class="s1">meta.__module__ = _PUBLIC_MODULE_NAME</span>
  <span class="s3">return </span><span class="s1">meta</span>

<span class="s1">bool_ = _make_scalar_type(np.bool_)</span>
<span class="s1">uint8 = _make_scalar_type(np.uint8)</span>
<span class="s1">uint16 = _make_scalar_type(np.uint16)</span>
<span class="s1">uint32 = _make_scalar_type(np.uint32)</span>
<span class="s1">uint64 = _make_scalar_type(np.uint64)</span>
<span class="s1">int8 = _make_scalar_type(np.int8)</span>
<span class="s1">int16 = _make_scalar_type(np.int16)</span>
<span class="s1">int32 = _make_scalar_type(np.int32)</span>
<span class="s1">int64 = _make_scalar_type(np.int64)</span>
<span class="s3">if </span><span class="s1">xla_client._version &gt;= </span><span class="s5">117</span><span class="s1">:</span>
  <span class="s1">float8_e4m3fn = _make_scalar_type(dtypes.float8_e4m3fn)</span>
  <span class="s1">float8_e5m2 = _make_scalar_type(dtypes.float8_e5m2)</span>
<span class="s1">bfloat16 = _make_scalar_type(dtypes.bfloat16)</span>
<span class="s1">float16 = _make_scalar_type(np.float16)</span>
<span class="s1">float32 = single = _make_scalar_type(np.float32)</span>
<span class="s1">float64 = double = _make_scalar_type(np.float64)</span>
<span class="s1">complex64 = csingle = _make_scalar_type(np.complex64)</span>
<span class="s1">complex128 = cdouble = _make_scalar_type(np.complex128)</span>

<span class="s1">int_ = int32 </span><span class="s3">if </span><span class="s1">dtypes.int_ == np.int32 </span><span class="s3">else </span><span class="s1">int64</span>
<span class="s1">uint = uint32 </span><span class="s3">if </span><span class="s1">dtypes.uint == np.uint32 </span><span class="s3">else </span><span class="s1">uint64</span>
<span class="s1">float_: Any = float32 </span><span class="s3">if </span><span class="s1">dtypes.float_ == np.float32 </span><span class="s3">else </span><span class="s1">float64</span>
<span class="s1">complex_ = complex64 </span><span class="s3">if </span><span class="s1">dtypes.complex_ == np.complex64 </span><span class="s3">else </span><span class="s1">complex128</span>

<span class="s1">generic = np.generic</span>
<span class="s1">number = np.number</span>
<span class="s1">inexact = np.inexact</span>
<span class="s1">complexfloating = np.complexfloating</span>
<span class="s1">floating = np.floating</span>
<span class="s1">integer = np.integer</span>
<span class="s1">signedinteger = np.signedinteger</span>
<span class="s1">unsignedinteger = np.unsignedinteger</span>

<span class="s1">flexible = np.flexible</span>
<span class="s1">character = np.character</span>
<span class="s1">object_ = np.object_</span>

<span class="s1">iinfo = dtypes.iinfo</span>
<span class="s1">finfo = dtypes.finfo</span>

<span class="s1">dtype = np.dtype</span>
<span class="s1">can_cast = dtypes.can_cast</span>
<span class="s1">issubsctype = dtypes.issubsctype</span>
<span class="s1">promote_types = dtypes.promote_types</span>

<span class="s1">ComplexWarning = np.ComplexWarning</span>

<span class="s1">array_str = np.array_str</span>
<span class="s1">array_repr = np.array_repr</span>

<span class="s1">save = np.save</span>
<span class="s1">savez = np.savez</span>

<span class="s1">@util._wraps(np.dtype)</span>
<span class="s3">def </span><span class="s1">_jnp_dtype(obj: Optional[DTypeLike]</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">align: bool = </span><span class="s3">False,</span>
               <span class="s1">copy: bool = </span><span class="s3">False</span><span class="s1">) -&gt; DType:</span>
  <span class="s2">&quot;&quot;&quot;Similar to np.dtype, but respects JAX dtype defaults.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">obj = dtypes.float_</span>
  <span class="s3">elif </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">type) </span><span class="s3">and </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">dtypes.python_scalar_dtypes:</span>
    <span class="s1">obj = _DEFAULT_TYPEMAP[np.dtype(obj</span><span class="s3">, </span><span class="s1">align=align</span><span class="s3">, </span><span class="s1">copy=copy).type]</span>
  <span class="s3">return </span><span class="s1">np.dtype(obj</span><span class="s3">, </span><span class="s1">align=align</span><span class="s3">, </span><span class="s1">copy=copy)</span>

<span class="s0">### utility functions</span>

<span class="s1">_DEFAULT_TYPEMAP: Dict[type</span><span class="s3">, </span><span class="s1">_ScalarMeta] = {</span>
  <span class="s1">np.bool_: bool_</span><span class="s3">,</span>
  <span class="s1">np.int_: int_</span><span class="s3">,</span>
  <span class="s1">np.float_: float_</span><span class="s3">,</span>
  <span class="s1">np.complex_: complex_</span>
<span class="s1">}</span>

<span class="s1">_lax_const = lax_internal._const</span>


<span class="s3">def </span><span class="s1">_convert_and_clip_integer(val: ArrayLike</span><span class="s3">, </span><span class="s1">dtype: DType) -&gt; Array:</span>
  <span class="s2">&quot;&quot;&quot; 
  Convert integer-typed val to specified integer dtype, clipping to dtype 
  range rather than wrapping. 
 
  Args: 
    val: value to be converted 
    dtype: dtype of output 
 
  Returns: 
    equivalent of val in new dtype 
 
  Examples 
  -------- 
  Normal integer type conversion will wrap: 
 
  &gt;&gt;&gt; val = jnp.uint32(0xFFFFFFFF) 
  &gt;&gt;&gt; val.astype('int32') 
  Array(-1, dtype=int32) 
 
  This function clips to the values representable in the new type: 
 
  &gt;&gt;&gt; _convert_and_clip_integer(val, 'int32') 
  Array(2147483647, dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s1">val = val </span><span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">Array) </span><span class="s3">else </span><span class="s1">asarray(val)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(dtype)</span>
  <span class="s3">if not </span><span class="s1">(issubdtype(dtype</span><span class="s3">, </span><span class="s1">integer) </span><span class="s3">and </span><span class="s1">issubdtype(val.dtype</span><span class="s3">, </span><span class="s1">integer)):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;_convert_and_clip_integer only accepts integer dtypes.&quot;</span><span class="s1">)</span>

  <span class="s1">val_dtype = dtypes.canonicalize_dtype(val.dtype)</span>
  <span class="s3">if </span><span class="s1">val_dtype != val.dtype:</span>
    <span class="s0"># TODO(jakevdp): this is a weird corner case; need to figure out how to handle it.</span>
    <span class="s0"># This happens in X32 mode and can either come from a jax value created in another</span>
    <span class="s0"># context, or a Python integer converted to int64.</span>
    <span class="s3">pass</span>
  <span class="s1">min_val = _lax_const(val</span><span class="s3">, </span><span class="s1">_max(iinfo(dtype).min</span><span class="s3">, </span><span class="s1">iinfo(val_dtype).min))</span>
  <span class="s1">max_val = _lax_const(val</span><span class="s3">, </span><span class="s1">_min(iinfo(dtype).max</span><span class="s3">, </span><span class="s1">iinfo(val_dtype).max))</span>
  <span class="s3">return </span><span class="s1">clip(val</span><span class="s3">, </span><span class="s1">min_val</span><span class="s3">, </span><span class="s1">max_val).astype(dtype)</span>


<span class="s1">@util._wraps(np.load</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">load(*args: Any</span><span class="s3">, </span><span class="s1">**kwargs: Any) -&gt; Array:</span>
  <span class="s0"># The main purpose of this wrapper is to recover bfloat16 data types.</span>
  <span class="s0"># Note: this will only work for files created via np.save(), not np.savez().</span>
  <span class="s1">out = np.load(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
  <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
    <span class="s0"># numpy does not recognize bfloat16, so arrays are serialized as void16</span>
    <span class="s3">if </span><span class="s1">out.dtype == </span><span class="s4">'V2'</span><span class="s1">:</span>
      <span class="s1">out = out.view(bfloat16)</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">out = asarray(out)</span>
    <span class="s3">except </span><span class="s1">TypeError:  </span><span class="s0"># Unsupported dtype</span>
      <span class="s3">pass</span>
  <span class="s3">return </span><span class="s1">out</span>

<span class="s0">### implementations of numpy functions in terms of lax</span>

<span class="s1">@util._wraps(np.fmin</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">fmin(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">where(ufuncs.less(x1</span><span class="s3">, </span><span class="s1">x2) | ufuncs.isnan(x2)</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>

<span class="s1">@util._wraps(np.fmax</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">fmax(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">where(ufuncs.greater(x1</span><span class="s3">, </span><span class="s1">x2) | ufuncs.isnan(x2)</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>

<span class="s1">@util._wraps(np.issubdtype)</span>
<span class="s3">def </span><span class="s1">issubdtype(arg1: DTypeLike</span><span class="s3">, </span><span class="s1">arg2: DTypeLike) -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">dtypes.issubdtype(arg1</span><span class="s3">, </span><span class="s1">arg2)</span>

<span class="s1">@util._wraps(np.isscalar)</span>
<span class="s3">def </span><span class="s1">isscalar(element: Any) -&gt; bool:</span>
  <span class="s3">if </span><span class="s1">hasattr(element</span><span class="s3">, </span><span class="s4">'__jax_array__'</span><span class="s1">):</span>
    <span class="s1">element = element.__jax_array__()</span>
  <span class="s3">return </span><span class="s1">dtypes.is_python_scalar(element) </span><span class="s3">or </span><span class="s1">np.isscalar(element)</span>

<span class="s1">iterable = np.iterable</span>

<span class="s1">@util._wraps(np.result_type)</span>
<span class="s3">def </span><span class="s1">result_type(*args: ArrayLike) -&gt; DType:</span>
  <span class="s3">return </span><span class="s1">dtypes.result_type(*args)</span>


<span class="s1">@util._wraps(np.trapz)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">trapz(y: ArrayLike</span><span class="s3">, </span><span class="s1">x: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">dx: ArrayLike = </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">'trapz'</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s1">y_arr</span><span class="s3">, </span><span class="s1">= util.promote_dtypes_inexact(y)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">'trapz'</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">y_arr</span><span class="s3">, </span><span class="s1">x_arr = util.promote_dtypes_inexact(y</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">if </span><span class="s1">x_arr.ndim == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">dx = diff(x_arr)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">dx = moveaxis(diff(x_arr</span><span class="s3">, </span><span class="s1">axis=axis)</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">y_arr = moveaxis(y_arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">* (dx * (y_arr[...</span><span class="s3">, </span><span class="s5">1</span><span class="s1">:] + y_arr[...</span><span class="s3">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">])).sum(-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.trunc</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">trunc(x: ArrayLike) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">'trunc'</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">where(lax.lt(x</span><span class="s3">, </span><span class="s1">_lax_const(x</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">, </span><span class="s1">ufuncs.ceil(x)</span><span class="s3">, </span><span class="s1">ufuncs.floor(x))</span>


<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_conv(x: Array</span><span class="s3">, </span><span class="s1">y: Array</span><span class="s3">, </span><span class="s1">mode: str</span><span class="s3">, </span><span class="s1">op: str</span><span class="s3">, </span><span class="s1">precision: PrecisionLike) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">ndim(x) != </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">ndim(y) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">op</span><span class="s3">}</span><span class="s4">() only support 1-dimensional inputs.&quot;</span><span class="s1">)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">y = util.promote_dtypes_inexact(x</span><span class="s3">, </span><span class="s1">y)</span>
  <span class="s3">if </span><span class="s1">len(x) == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">len(y) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">op</span><span class="s3">}</span><span class="s4">: inputs cannot be empty, got shapes </span><span class="s3">{</span><span class="s1">x.shape</span><span class="s3">} </span><span class="s4">and </span><span class="s3">{</span><span class="s1">y.shape</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

  <span class="s1">out_order = slice(</span><span class="s3">None</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">op == </span><span class="s4">'correlate'</span><span class="s1">:</span>
    <span class="s1">y = ufuncs.conj(y)</span>
    <span class="s3">if </span><span class="s1">len(x) &lt; len(y):</span>
      <span class="s1">x</span><span class="s3">, </span><span class="s1">y = y</span><span class="s3">, </span><span class="s1">x</span>
      <span class="s1">out_order = slice(</span><span class="s3">None, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">op == </span><span class="s4">'convolve'</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">len(x) &lt; len(y):</span>
      <span class="s1">x</span><span class="s3">, </span><span class="s1">y = y</span><span class="s3">, </span><span class="s1">x</span>
    <span class="s1">y = flip(y)</span>

  <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'valid'</span><span class="s1">:</span>
    <span class="s1">padding = [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)]</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'same'</span><span class="s1">:</span>
    <span class="s1">padding = [(y.shape[</span><span class="s5">0</span><span class="s1">] // </span><span class="s5">2</span><span class="s3">, </span><span class="s1">y.shape[</span><span class="s5">0</span><span class="s1">] - y.shape[</span><span class="s5">0</span><span class="s1">] // </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)]</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'full'</span><span class="s1">:</span>
    <span class="s1">padding = [(y.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">y.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode must be one of ['full', 'same', 'valid']&quot;</span><span class="s1">)</span>

  <span class="s1">result = lax.conv_general_dilated(x[</span><span class="s3">None, None, </span><span class="s1">:]</span><span class="s3">, </span><span class="s1">y[</span><span class="s3">None, None, </span><span class="s1">:]</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                                    <span class="s1">padding</span><span class="s3">, </span><span class="s1">precision=precision)</span>
  <span class="s3">return </span><span class="s1">result[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">out_order]</span>


<span class="s1">@util._wraps(np.convolve</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'precision'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">convolve(a: ArrayLike</span><span class="s3">, </span><span class="s1">v: ArrayLike</span><span class="s3">, </span><span class="s1">mode: str = </span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
             <span class="s1">precision: PrecisionLike = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;convolve&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s3">return </span><span class="s1">_conv(asarray(a)</span><span class="s3">, </span><span class="s1">asarray(v)</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s4">'convolve'</span><span class="s3">, </span><span class="s1">precision)</span>


<span class="s1">@util._wraps(np.correlate</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'precision'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">correlate(a: ArrayLike</span><span class="s3">, </span><span class="s1">v: ArrayLike</span><span class="s3">, </span><span class="s1">mode: str = </span><span class="s4">'valid'</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
              <span class="s1">precision: PrecisionLike = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;correlate&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s3">return </span><span class="s1">_conv(asarray(a)</span><span class="s3">, </span><span class="s1">asarray(v)</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s4">'correlate'</span><span class="s3">, </span><span class="s1">precision)</span>


<span class="s1">@util._wraps(np.histogram_bin_edges)</span>
<span class="s3">def </span><span class="s1">histogram_bin_edges(a: ArrayLike</span><span class="s3">, </span><span class="s1">bins: ArrayLike = </span><span class="s5">10</span><span class="s3">,</span>
                        <span class="s1">range: Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]] = </span><span class="s3">None,</span>
                        <span class="s1">weights: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">del </span><span class="s1">weights  </span><span class="s0"># unused, because string bins is not supported.</span>
  <span class="s3">if </span><span class="s1">isinstance(bins</span><span class="s3">, </span><span class="s1">str):</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;string values for `bins` not implemented.&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogram_bin_edges&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins)</span>
  <span class="s1">arr = ravel(a)</span>
  <span class="s1">dtype = dtypes.to_inexact_dtype(arr.dtype)</span>
  <span class="s3">if </span><span class="s1">_ndim(bins) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">asarray(bins</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

  <span class="s1">bins_int = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">,</span>
                                    <span class="s4">&quot;bins argument of histogram_bin_edges&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">range </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">range = [arr.min()</span><span class="s3">, </span><span class="s1">arr.max()]</span>
  <span class="s1">range = asarray(range</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s3">if </span><span class="s1">shape(range) != (</span><span class="s5">2</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;`range` must be either None or a sequence of scalars, got </span><span class="s3">{</span><span class="s1">range</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">range = (where(reductions.ptp(range) == </span><span class="s5">0</span><span class="s3">, </span><span class="s1">range[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">range[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">,</span>
           <span class="s1">where(reductions.ptp(range) == </span><span class="s5">0</span><span class="s3">, </span><span class="s1">range[</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">range[</span><span class="s5">1</span><span class="s1">]))</span>
  <span class="s3">assert </span><span class="s1">range </span><span class="s3">is not None</span>
  <span class="s3">return </span><span class="s1">linspace(range[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">range[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">bins_int + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@util._wraps(np.histogram)</span>
<span class="s3">def </span><span class="s1">histogram(a: ArrayLike</span><span class="s3">, </span><span class="s1">bins: ArrayLike = </span><span class="s5">10</span><span class="s3">,</span>
              <span class="s1">range: Optional[Sequence[ArrayLike]] = </span><span class="s3">None,</span>
              <span class="s1">weights: Optional[ArrayLike] = </span><span class="s3">None,</span>
              <span class="s1">density: Optional[bool] = </span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogram&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins)</span>
    <span class="s1">a = ravel(*util.promote_dtypes_inexact(a))</span>
    <span class="s1">weights = ones_like(a)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogram&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">weights)</span>
    <span class="s3">if </span><span class="s1">shape(a) != shape(weights):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;weights should have the same shape as a.&quot;</span><span class="s1">)</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">weights = map(ravel</span><span class="s3">, </span><span class="s1">util.promote_dtypes_inexact(a</span><span class="s3">, </span><span class="s1">weights))</span>

  <span class="s1">bin_edges = histogram_bin_edges(a</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">range</span><span class="s3">, </span><span class="s1">weights)</span>
  <span class="s1">bin_idx = searchsorted(bin_edges</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">side=</span><span class="s4">'right'</span><span class="s1">)</span>
  <span class="s1">bin_idx = where(a == bin_edges[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">len(bin_edges) - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">bin_idx)</span>
  <span class="s1">counts = bincount(bin_idx</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">length=len(bin_edges))[</span><span class="s5">1</span><span class="s1">:]</span>
  <span class="s3">if </span><span class="s1">density:</span>
    <span class="s1">bin_widths = diff(bin_edges)</span>
    <span class="s1">counts = counts / bin_widths / counts.sum()</span>
  <span class="s3">return </span><span class="s1">counts</span><span class="s3">, </span><span class="s1">bin_edges</span>

<span class="s1">@util._wraps(np.histogram2d)</span>
<span class="s3">def </span><span class="s1">histogram2d(x: ArrayLike</span><span class="s3">, </span><span class="s1">y: ArrayLike</span><span class="s3">, </span><span class="s1">bins: Union[ArrayLike</span><span class="s3">, </span><span class="s1">List[ArrayLike]] = </span><span class="s5">10</span><span class="s3">,</span>
                <span class="s1">range: Optional[Sequence[Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]]]=</span><span class="s3">None,</span>
                <span class="s1">weights: Optional[ArrayLike] = </span><span class="s3">None,</span>
                <span class="s1">density: Optional[bool] = </span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogram2d&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y)</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">N = len(bins)  </span><span class="s0"># type: ignore[arg-type]</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s1">N = </span><span class="s5">1</span>

  <span class="s3">if </span><span class="s1">N != </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">N != </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s1">x_edges = y_edges = asarray(bins)</span>
    <span class="s1">bins = [x_edges</span><span class="s3">, </span><span class="s1">y_edges]</span>

  <span class="s1">sample = transpose(asarray([x</span><span class="s3">, </span><span class="s1">y]))</span>
  <span class="s1">hist</span><span class="s3">, </span><span class="s1">edges = histogramdd(sample</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">range</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">density)</span>
  <span class="s3">return </span><span class="s1">hist</span><span class="s3">, </span><span class="s1">edges[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">edges[</span><span class="s5">1</span><span class="s1">]</span>

<span class="s1">@util._wraps(np.histogramdd)</span>
<span class="s3">def </span><span class="s1">histogramdd(sample: ArrayLike</span><span class="s3">, </span><span class="s1">bins: Union[ArrayLike</span><span class="s3">, </span><span class="s1">List[ArrayLike]] = </span><span class="s5">10</span><span class="s3">,</span>
                <span class="s1">range: Optional[Sequence[Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]]] = </span><span class="s3">None,</span>
                <span class="s1">weights: Optional[ArrayLike] = </span><span class="s3">None,</span>
                <span class="s1">density: Optional[bool] = </span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogramdd&quot;</span><span class="s3">, </span><span class="s1">sample)</span>
    <span class="s1">sample</span><span class="s3">, </span><span class="s1">= util.promote_dtypes_inexact(sample)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;histogramdd&quot;</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">weights)</span>
    <span class="s3">if </span><span class="s1">shape(weights) != shape(sample)[:</span><span class="s5">1</span><span class="s1">]:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;should have one weight for each sample.&quot;</span><span class="s1">)</span>
    <span class="s1">sample</span><span class="s3">, </span><span class="s1">weights = util.promote_dtypes_inexact(sample</span><span class="s3">, </span><span class="s1">weights)</span>
  <span class="s1">N</span><span class="s3">, </span><span class="s1">D = shape(sample)</span>

  <span class="s3">if </span><span class="s1">range </span><span class="s3">is not None and </span><span class="s1">(</span>
      <span class="s1">len(range) != D </span><span class="s3">or </span><span class="s1">_any(r </span><span class="s3">is not None and </span><span class="s1">shape(r)[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">2 </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">range)):  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;For sample.shape=</span><span class="s3">{</span><span class="s1">(N</span><span class="s3">, </span><span class="s1">D)</span><span class="s3">}</span><span class="s4">, range must be a sequence &quot;</span>
                     <span class="s4">f&quot;of </span><span class="s3">{</span><span class="s1">D</span><span class="s3">} </span><span class="s4">pairs or Nones; got </span><span class="s3">{</span><span class="s1">range=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">num_bins = len(bins)  </span><span class="s0"># type: ignore[arg-type]</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s0"># when bin_size is integer, the same bin is used for each dimension</span>
    <span class="s1">bins_per_dimension: List[ArrayLike] = D * [bins]  </span><span class="s0"># type: ignore[assignment]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">num_bins != D:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;should be a bin for each dimension.&quot;</span><span class="s1">)</span>
    <span class="s1">bins_per_dimension = list(bins)  </span><span class="s0"># type: ignore[arg-type]</span>

  <span class="s1">bin_idx_by_dim: List[Array] = []</span>
  <span class="s1">bin_edges_by_dim: List[Array] = []</span>

  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">builtins.range(D):</span>
    <span class="s1">range_i = </span><span class="s3">None if </span><span class="s1">range </span><span class="s3">is None else </span><span class="s1">range[i]</span>
    <span class="s1">bin_edges = histogram_bin_edges(sample[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">bins_per_dimension[i]</span><span class="s3">, </span><span class="s1">range_i</span><span class="s3">, </span><span class="s1">weights)</span>
    <span class="s1">bin_idx = searchsorted(bin_edges</span><span class="s3">, </span><span class="s1">sample[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">side=</span><span class="s4">'right'</span><span class="s1">)</span>
    <span class="s1">bin_idx = where(sample[:</span><span class="s3">, </span><span class="s1">i] == bin_edges[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">bin_idx - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">bin_idx)</span>
    <span class="s1">bin_idx_by_dim.append(bin_idx)</span>
    <span class="s1">bin_edges_by_dim.append(bin_edges)</span>

  <span class="s1">nbins = tuple(len(bin_edges) + </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">bin_edges </span><span class="s3">in </span><span class="s1">bin_edges_by_dim)</span>
  <span class="s1">dedges = [diff(bin_edges) </span><span class="s3">for </span><span class="s1">bin_edges </span><span class="s3">in </span><span class="s1">bin_edges_by_dim]</span>

  <span class="s1">xy = ravel_multi_index(tuple(bin_idx_by_dim)</span><span class="s3">, </span><span class="s1">nbins</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'clip'</span><span class="s1">)</span>
  <span class="s1">hist = bincount(xy</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">length=math.prod(nbins))</span>
  <span class="s1">hist = reshape(hist</span><span class="s3">, </span><span class="s1">nbins)</span>
  <span class="s1">core = D*(slice(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s1">hist = hist[core]</span>

  <span class="s3">if </span><span class="s1">density:</span>
    <span class="s1">hist = hist.astype(sample.dtype)</span>
    <span class="s1">hist /= hist.sum()</span>
    <span class="s3">for </span><span class="s1">norm </span><span class="s3">in </span><span class="s1">ix_(*dedges):</span>
      <span class="s1">hist /= norm</span>

  <span class="s3">return </span><span class="s1">hist</span><span class="s3">, </span><span class="s1">bin_edges_by_dim</span>


<span class="s1">_ARRAY_VIEW_DOC = </span><span class="s4">&quot;&quot;&quot; 
The JAX version of this function may in some cases return a copy rather than a 
view of the input. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.transpose</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">transpose(a: ArrayLike</span><span class="s3">, </span><span class="s1">axes: Optional[Sequence[int]] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util._stackable(a) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;transpose&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">axes_ = list(range(ndim(a))[::-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">axes </span><span class="s3">is None else </span><span class="s1">axes</span>
  <span class="s1">axes_ = [_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">ndim(a)) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">axes_]</span>
  <span class="s3">return </span><span class="s1">lax.transpose(a</span><span class="s3">, </span><span class="s1">axes_)</span>


<span class="s1">@util._wraps(np.rot90</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'k'</span><span class="s3">, </span><span class="s4">'axes'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">rot90(m: ArrayLike</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axes: Tuple[int</span><span class="s3">, </span><span class="s1">int] = (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;rot90&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s1">ax1</span><span class="s3">, </span><span class="s1">ax2 = axes</span>
  <span class="s1">ax1 = _canonicalize_axis(ax1</span><span class="s3">, </span><span class="s1">ndim(m))</span>
  <span class="s1">ax2 = _canonicalize_axis(ax2</span><span class="s3">, </span><span class="s1">ndim(m))</span>
  <span class="s3">if </span><span class="s1">ax1 == ax2:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Axes must be different&quot;</span><span class="s1">)  </span><span class="s0"># same as numpy error</span>
  <span class="s1">k = k % </span><span class="s5">4</span>
  <span class="s3">if </span><span class="s1">k == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">asarray(m)</span>
  <span class="s3">elif </span><span class="s1">k == </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">flip(flip(m</span><span class="s3">, </span><span class="s1">ax1)</span><span class="s3">, </span><span class="s1">ax2)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">perm = list(range(ndim(m)))</span>
    <span class="s1">perm[ax1]</span><span class="s3">, </span><span class="s1">perm[ax2] = perm[ax2]</span><span class="s3">, </span><span class="s1">perm[ax1]</span>
    <span class="s3">if </span><span class="s1">k == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">transpose(flip(m</span><span class="s3">, </span><span class="s1">ax2)</span><span class="s3">, </span><span class="s1">perm)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">flip(transpose(m</span><span class="s3">, </span><span class="s1">perm)</span><span class="s3">, </span><span class="s1">ax2)</span>


<span class="s1">@util._wraps(np.flip</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">flip(m: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[Union[int</span><span class="s3">, </span><span class="s1">Tuple[int</span><span class="s3">, </span><span class="s1">...]]] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;flip&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s3">return </span><span class="s1">_flip(asarray(m)</span><span class="s3">, </span><span class="s1">reductions._ensure_optional_axes(axis))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_flip(m: Array</span><span class="s3">, </span><span class="s1">axis: Optional[Union[int</span><span class="s3">, </span><span class="s1">Tuple[int</span><span class="s3">, </span><span class="s1">...]]] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.rev(m</span><span class="s3">, </span><span class="s1">list(range(len(shape(m)))))</span>
  <span class="s1">axis = _ensure_index_tuple(axis)</span>
  <span class="s3">return </span><span class="s1">lax.rev(m</span><span class="s3">, </span><span class="s1">[_canonicalize_axis(ax</span><span class="s3">, </span><span class="s1">ndim(m)) </span><span class="s3">for </span><span class="s1">ax </span><span class="s3">in </span><span class="s1">axis])</span>


<span class="s1">@util._wraps(np.fliplr</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">fliplr(m: ArrayLike) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;fliplr&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s3">return </span><span class="s1">_flip(asarray(m)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.flipud</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">flipud(m: ArrayLike) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;flipud&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s3">return </span><span class="s1">_flip(asarray(m)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s1">@util._wraps(np.iscomplex)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">iscomplex(x: ArrayLike) -&gt; Array:</span>
  <span class="s1">i = ufuncs.imag(x)</span>
  <span class="s3">return </span><span class="s1">lax.ne(i</span><span class="s3">, </span><span class="s1">_lax_const(i</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>

<span class="s1">@util._wraps(np.isreal)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">isreal(x: ArrayLike) -&gt; Array:</span>
  <span class="s1">i = ufuncs.imag(x)</span>
  <span class="s3">return </span><span class="s1">lax.eq(i</span><span class="s3">, </span><span class="s1">_lax_const(i</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>

<span class="s1">@util._wraps(np.angle)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=[</span><span class="s4">'deg'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">angle(z: ArrayLike</span><span class="s3">, </span><span class="s1">deg: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">re = ufuncs.real(z)</span>
  <span class="s1">im = ufuncs.imag(z)</span>
  <span class="s1">dtype = _dtype(re)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">inexact) </span><span class="s3">or </span><span class="s1">(</span>
      <span class="s1">issubdtype(_dtype(z)</span><span class="s3">, </span><span class="s1">floating) </span><span class="s3">and </span><span class="s1">ndim(z) == </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
    <span class="s1">re = lax.convert_element_type(re</span><span class="s3">, </span><span class="s1">dtype)</span>
    <span class="s1">im = lax.convert_element_type(im</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">result = lax.atan2(im</span><span class="s3">, </span><span class="s1">re)</span>
  <span class="s3">return </span><span class="s1">ufuncs.degrees(result) </span><span class="s3">if </span><span class="s1">deg </span><span class="s3">else </span><span class="s1">result</span>


<span class="s1">@util._wraps(np.diff)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'n'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">diff(a: ArrayLike</span><span class="s3">, </span><span class="s1">n: int = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s3">,</span>
         <span class="s1">prepend: Optional[ArrayLike] = </span><span class="s3">None,</span>
         <span class="s1">append: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diff&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">arr = asarray(a)</span>
  <span class="s1">n = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s4">&quot;'n' argument of jnp.diff&quot;</span><span class="s1">)</span>
  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;'axis' argument of jnp.diff&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">arr</span>
  <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;order must be non-negative but got </span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">arr.ndim == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;diff requires input that is at least one dimensional; got </span><span class="s3">{</span><span class="s1">a</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s1">nd = arr.ndim</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">nd)</span>

  <span class="s1">combined: List[Array] = []</span>
  <span class="s3">if </span><span class="s1">prepend </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diff&quot;</span><span class="s3">, </span><span class="s1">prepend)</span>
    <span class="s3">if </span><span class="s1">isscalar(prepend):</span>
      <span class="s1">shape = list(arr.shape)</span>
      <span class="s1">shape[axis] = </span><span class="s5">1</span>
      <span class="s1">prepend = broadcast_to(prepend</span><span class="s3">, </span><span class="s1">tuple(shape))</span>
    <span class="s1">combined.append(asarray(prepend))</span>

  <span class="s1">combined.append(arr)</span>

  <span class="s3">if </span><span class="s1">append </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diff&quot;</span><span class="s3">, </span><span class="s1">append)</span>
    <span class="s3">if </span><span class="s1">isscalar(append):</span>
      <span class="s1">shape = list(arr.shape)</span>
      <span class="s1">shape[axis] = </span><span class="s5">1</span>
      <span class="s1">append = broadcast_to(append</span><span class="s3">, </span><span class="s1">tuple(shape))</span>
    <span class="s1">combined.append(asarray(append))</span>

  <span class="s3">if </span><span class="s1">len(combined) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">arr = concatenate(combined</span><span class="s3">, </span><span class="s1">axis)</span>

  <span class="s1">slice1 = [slice(</span><span class="s3">None</span><span class="s1">)] * nd</span>
  <span class="s1">slice2 = [slice(</span><span class="s3">None</span><span class="s1">)] * nd</span>
  <span class="s1">slice1[axis] = slice(</span><span class="s5">1</span><span class="s3">, None</span><span class="s1">)</span>
  <span class="s1">slice2[axis] = slice(</span><span class="s3">None, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">slice1_tuple = tuple(slice1)</span>
  <span class="s1">slice2_tuple = tuple(slice2)</span>

  <span class="s1">op = ufuncs.not_equal </span><span class="s3">if </span><span class="s1">arr.dtype == np.bool_ </span><span class="s3">else </span><span class="s1">ufuncs.subtract</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(n):</span>
    <span class="s1">arr = op(arr[slice1_tuple]</span><span class="s3">, </span><span class="s1">arr[slice2_tuple])</span>

  <span class="s3">return </span><span class="s1">arr</span>

<span class="s1">_EDIFF1D_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Unlike NumPy's implementation of ediff1d, :py:func:`jax.numpy.ediff1d` will not 
issue an error if casting ``to_end`` or ``to_begin`` to the type of ``ary`` 
loses precision. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.ediff1d</span><span class="s3">, </span><span class="s1">lax_description=_EDIFF1D_DOC)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">ediff1d(ary: ArrayLike</span><span class="s3">, </span><span class="s1">to_end: Optional[ArrayLike] = </span><span class="s3">None,</span>
            <span class="s1">to_begin: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ediff1d&quot;</span><span class="s3">, </span><span class="s1">ary)</span>
  <span class="s1">arr = ravel(ary)</span>
  <span class="s1">result = lax.sub(arr[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">arr[:-</span><span class="s5">1</span><span class="s1">])</span>
  <span class="s3">if </span><span class="s1">to_begin </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ediff1d&quot;</span><span class="s3">, </span><span class="s1">to_begin)</span>
    <span class="s1">result = concatenate((ravel(asarray(to_begin</span><span class="s3">, </span><span class="s1">dtype=arr.dtype))</span><span class="s3">, </span><span class="s1">result))</span>
  <span class="s3">if </span><span class="s1">to_end </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ediff1d&quot;</span><span class="s3">, </span><span class="s1">to_end)</span>
    <span class="s1">result = concatenate((result</span><span class="s3">, </span><span class="s1">ravel(asarray(to_end</span><span class="s3">, </span><span class="s1">dtype=arr.dtype))))</span>
  <span class="s3">return </span><span class="s1">result</span>


<span class="s1">@util._wraps(np.gradient</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'edge_order'</span><span class="s1">])</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'edge_order'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">gradient(f: ArrayLike</span><span class="s3">, </span><span class="s1">*varargs: ArrayLike</span><span class="s3">,</span>
             <span class="s1">axis: Optional[Union[int</span><span class="s3">, </span><span class="s1">Tuple[int</span><span class="s3">, </span><span class="s1">...]]] = </span><span class="s3">None,</span>
             <span class="s1">edge_order: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s3">if </span><span class="s1">edge_order </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'edge_order' argument to jnp.gradient is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">*spacing = util.promote_args_inexact(</span><span class="s4">&quot;gradient&quot;</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">*varargs)</span>

  <span class="s3">def </span><span class="s1">gradient_along_axis(a</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">axis):</span>
    <span class="s1">sliced = partial(lax.slice_in_dim</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">a_grad = concatenate((</span>
      <span class="s1">(sliced(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">) - sliced(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># upper edge</span>
      <span class="s1">(sliced(</span><span class="s5">2</span><span class="s3">, None</span><span class="s1">) - sliced(</span><span class="s3">None, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">)) * </span><span class="s5">0.5</span><span class="s3">,  </span><span class="s0"># inner</span>
      <span class="s1">(sliced(-</span><span class="s5">1</span><span class="s3">, None</span><span class="s1">) - sliced(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span><span class="s3">,  </span><span class="s0"># lower edge</span>
    <span class="s1">)</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">return </span><span class="s1">a_grad / h</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">axis_tuple = tuple(range(a.ndim))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">isinstance(axis</span><span class="s3">, </span><span class="s1">int):</span>
      <span class="s1">axis = (axis</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">elif not </span><span class="s1">isinstance(axis</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and not </span><span class="s1">isinstance(axis</span><span class="s3">, </span><span class="s1">list):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Give `axis` either as int or iterable&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">len(axis) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">[]</span>
    <span class="s1">axis_tuple = tuple(_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">a.ndim) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">axis)</span>

  <span class="s3">if </span><span class="s1">_min([s </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">enumerate(a.shape) </span><span class="s3">if </span><span class="s1">i </span><span class="s3">in </span><span class="s1">axis_tuple]) &lt; </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Shape of array too small to calculate &quot;</span>
                     <span class="s4">&quot;a numerical gradient, &quot;</span>
                     <span class="s4">&quot;at least 2 elements are required.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">len(spacing) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">dx: Sequence[ArrayLike] = [</span><span class="s5">1.0</span><span class="s1">] * len(axis_tuple)</span>
  <span class="s3">elif </span><span class="s1">len(spacing) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">dx = list(spacing) * len(axis_tuple)</span>
  <span class="s3">elif </span><span class="s1">len(spacing) == len(axis_tuple):</span>
    <span class="s1">dx = list(spacing)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">TypeError(</span><span class="s4">f&quot;Invalid number of spacing arguments </span><span class="s3">{</span><span class="s1">len(spacing)</span><span class="s3">} </span><span class="s4">for </span><span class="s3">{</span><span class="s1">axis=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">ndim(dx[</span><span class="s5">0</span><span class="s1">]) != </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Non-constant spacing not implemented&quot;</span><span class="s1">)</span>

  <span class="s1">a_grad = [gradient_along_axis(a</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">ax) </span><span class="s3">for </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">h </span><span class="s3">in </span><span class="s1">zip(axis_tuple</span><span class="s3">, </span><span class="s1">dx)]</span>
  <span class="s3">return </span><span class="s1">a_grad[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">len(axis_tuple) == </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">a_grad</span>


<span class="s1">@util._wraps(np.isrealobj)</span>
<span class="s3">def </span><span class="s1">isrealobj(x: Any) -&gt; bool:</span>
  <span class="s3">return not </span><span class="s1">iscomplexobj(x)</span>


<span class="s1">@util._wraps(np.reshape</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">reshape(a: ArrayLike</span><span class="s3">, </span><span class="s1">newshape: Union[DimSize</span><span class="s3">, </span><span class="s1">Shape]</span><span class="s3">, </span><span class="s1">order: str = </span><span class="s4">&quot;C&quot;</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util._stackable(a) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;reshape&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s0"># forward to method for ndarrays</span>
    <span class="s3">return </span><span class="s1">a.reshape(newshape</span><span class="s3">, </span><span class="s1">order=order)  </span><span class="s0"># type: ignore[call-overload,union-attr]</span>
  <span class="s3">except </span><span class="s1">AttributeError:</span>
    <span class="s3">return </span><span class="s1">asarray(a).reshape(newshape</span><span class="s3">, </span><span class="s1">order=order)</span>


<span class="s1">@util._wraps(np.ravel</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'order'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">ravel(a: ArrayLike</span><span class="s3">, </span><span class="s1">order: str = </span><span class="s4">&quot;C&quot;</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util._stackable(a) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;ravel&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">order == </span><span class="s4">&quot;K&quot;</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Ravel not implemented for order='K'.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">reshape(a</span><span class="s3">, </span><span class="s1">(size(a)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">order)</span>


<span class="s1">@util._wraps(np.ravel_multi_index)</span>
<span class="s3">def </span><span class="s1">ravel_multi_index(multi_index: Tuple[ArrayLike</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dims: Tuple[int</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">,</span>
                      <span class="s1">mode: str = </span><span class="s4">'raise'</span><span class="s3">, </span><span class="s1">order: str = </span><span class="s4">'C'</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">assert </span><span class="s1">len(multi_index) == len(dims)</span><span class="s3">, </span><span class="s4">f&quot;len(multi_index)=</span><span class="s3">{</span><span class="s1">len(multi_index)</span><span class="s3">} </span><span class="s4">!= len(dims)=</span><span class="s3">{</span><span class="s1">len(dims)</span><span class="s3">}</span><span class="s4">&quot;</span>
  <span class="s1">dims = tuple(core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s4">&quot;in `dims` argument of ravel_multi_index().&quot;</span><span class="s1">) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dims)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ravel_multi_index&quot;</span><span class="s3">, </span><span class="s1">*multi_index)</span>
  <span class="s1">multi_index_arr = [asarray(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">multi_index]</span>
  <span class="s3">for </span><span class="s1">index </span><span class="s3">in </span><span class="s1">multi_index_arr:</span>
    <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'raise'</span><span class="s1">:</span>
      <span class="s1">core.concrete_or_error(array</span><span class="s3">, </span><span class="s1">index</span><span class="s3">,</span>
        <span class="s4">&quot;The error occurred because ravel_multi_index was jit-compiled&quot;</span>
        <span class="s4">&quot; with mode='raise'. Use mode='wrap' or mode='clip' instead.&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">issubdtype(_dtype(index)</span><span class="s3">, </span><span class="s1">integer):</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;only int indices permitted&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">mode == </span><span class="s4">&quot;raise&quot;</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">_any(reductions.any((i &lt; </span><span class="s5">0</span><span class="s1">) | (i &gt;= d)) </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">zip(multi_index_arr</span><span class="s3">, </span><span class="s1">dims)):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid entry in coordinates array&quot;</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;clip&quot;</span><span class="s1">:</span>
    <span class="s1">multi_index_arr = [clip(i</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">d - </span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">zip(multi_index_arr</span><span class="s3">, </span><span class="s1">dims)]</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;wrap&quot;</span><span class="s1">:</span>
    <span class="s1">multi_index_arr = [i % d </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">zip(multi_index_arr</span><span class="s3">, </span><span class="s1">dims)]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;invalid mode=</span><span class="s3">{</span><span class="s1">mode</span><span class="s3">!r}</span><span class="s4">. Expected 'raise', 'wrap', or 'clip'&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">order == </span><span class="s4">&quot;F&quot;</span><span class="s1">:</span>
    <span class="s1">strides = np.cumprod((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + dims[:-</span><span class="s5">1</span><span class="s1">])</span>
  <span class="s3">elif </span><span class="s1">order == </span><span class="s4">&quot;C&quot;</span><span class="s1">:</span>
    <span class="s1">strides = np.cumprod((</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) + dims[</span><span class="s5">1</span><span class="s1">:][::-</span><span class="s5">1</span><span class="s1">])[::-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;invalid order=</span><span class="s3">{</span><span class="s1">order</span><span class="s3">!r}</span><span class="s4">. Expected 'C' or 'F'&quot;</span><span class="s1">)</span>

  <span class="s1">result = array(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=(multi_index_arr[</span><span class="s5">0</span><span class="s1">].dtype </span><span class="s3">if </span><span class="s1">multi_index_arr</span>
                           <span class="s3">else </span><span class="s1">dtypes.canonicalize_dtype(int_)))</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">zip(multi_index_arr</span><span class="s3">, </span><span class="s1">strides):</span>
    <span class="s1">result = result + i * int(s)</span>
  <span class="s3">return </span><span class="s1">result</span>


<span class="s1">_UNRAVEL_INDEX_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Unlike numpy's implementation of unravel_index, negative indices are accepted 
and out-of-bounds indices are clipped into the valid range. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.unravel_index</span><span class="s3">, </span><span class="s1">lax_description=_UNRAVEL_INDEX_DOC)</span>
<span class="s3">def </span><span class="s1">unravel_index(indices: ArrayLike</span><span class="s3">, </span><span class="s1">shape: Shape) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">...]:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;unravel_index&quot;</span><span class="s3">, </span><span class="s1">indices)</span>
  <span class="s1">indices_arr = asarray(indices)</span>
  <span class="s0"># Note: we do not convert shape to an array, because it may be passed as a</span>
  <span class="s0"># tuple of weakly-typed values, and asarray() would strip these weak types.</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">shape = list(shape)</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s1">shape = [shape]</span>
  <span class="s3">if </span><span class="s1">_any(ndim(s) != </span><span class="s5">0 </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">shape):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unravel_index: shape should be a scalar or 1D sequence.&quot;</span><span class="s1">)</span>
  <span class="s1">out_indices = [</span><span class="s5">0</span><span class="s1">] * len(shape)</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">reversed(list(enumerate(shape))):</span>
    <span class="s1">indices_arr</span><span class="s3">, </span><span class="s1">out_indices[i] = ufuncs.divmod(indices_arr</span><span class="s3">, </span><span class="s1">s)</span>
  <span class="s1">oob_pos = indices_arr &gt; </span><span class="s5">0</span>
  <span class="s1">oob_neg = indices_arr &lt; -</span><span class="s5">1</span>
  <span class="s3">return </span><span class="s1">tuple(where(oob_pos</span><span class="s3">, </span><span class="s1">s - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">where(oob_neg</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">i))</span>
               <span class="s3">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">safe_zip(shape</span><span class="s3">, </span><span class="s1">out_indices))</span>

<span class="s1">@util._wraps(np.resize)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'new_shape'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">resize(a: ArrayLike</span><span class="s3">, </span><span class="s1">new_shape: Shape) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;resize&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">new_shape = _ensure_index_tuple(new_shape)</span>

  <span class="s3">if </span><span class="s1">_any(dim_length &lt; </span><span class="s5">0 </span><span class="s3">for </span><span class="s1">dim_length </span><span class="s3">in </span><span class="s1">new_shape):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;all elements of `new_shape` must be non-negative&quot;</span><span class="s1">)</span>

  <span class="s1">arr = ravel(a)</span>

  <span class="s1">new_size = math.prod(new_shape)</span>
  <span class="s3">if </span><span class="s1">arr.size == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">new_size == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">zeros_like(arr</span><span class="s3">, </span><span class="s1">shape=new_shape)</span>

  <span class="s1">repeats = ceil_of_ratio(new_size</span><span class="s3">, </span><span class="s1">arr.size)</span>
  <span class="s1">arr = tile(arr</span><span class="s3">, </span><span class="s1">repeats)[:new_size]</span>

  <span class="s3">return </span><span class="s1">reshape(arr</span><span class="s3">, </span><span class="s1">new_shape)</span>

<span class="s1">@util._wraps(np.squeeze</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">squeeze(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[Union[int</span><span class="s3">, </span><span class="s1">Tuple[int</span><span class="s3">, </span><span class="s1">...]]] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;squeeze&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">return </span><span class="s1">_squeeze(asarray(a)</span><span class="s3">, </span><span class="s1">_ensure_index_tuple(axis) </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None else None</span><span class="s1">)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_squeeze(a: Array</span><span class="s3">, </span><span class="s1">axis: Tuple[int]) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">a_shape = shape(a)</span>
    <span class="s3">if not </span><span class="s1">core.is_constant_shape(a_shape):</span>
      <span class="s0"># We do not even know the rank of the output if the input shape is not known</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.squeeze with axis=None is not supported with shape polymorphism&quot;</span><span class="s1">)</span>
    <span class="s1">axis = tuple(i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(a_shape) </span><span class="s3">if </span><span class="s1">d == </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">lax.squeeze(a</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@util._wraps(np.expand_dims)</span>
<span class="s3">def </span><span class="s1">expand_dims(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Union[int</span><span class="s3">, </span><span class="s1">Sequence[int]]) -&gt; Array:</span>
  <span class="s1">util._stackable(a) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;expand_dims&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">axis = _ensure_index_tuple(axis)</span>
  <span class="s3">if </span><span class="s1">hasattr(a</span><span class="s3">, </span><span class="s4">&quot;expand_dims&quot;</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">a.expand_dims(axis)  </span><span class="s0"># type: ignore</span>
  <span class="s3">return </span><span class="s1">lax.expand_dims(a</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@util._wraps(np.swapaxes</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis1'</span><span class="s3">, </span><span class="s4">'axis2'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">swapaxes(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis1: int</span><span class="s3">, </span><span class="s1">axis2: int) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;swapaxes&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">perm = np.arange(ndim(a))</span>
  <span class="s1">perm[axis1]</span><span class="s3">, </span><span class="s1">perm[axis2] = perm[axis2]</span><span class="s3">, </span><span class="s1">perm[axis1]</span>
  <span class="s3">return </span><span class="s1">lax.transpose(a</span><span class="s3">, </span><span class="s1">list(perm))</span>


<span class="s1">@util._wraps(np.moveaxis</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">moveaxis(a: ArrayLike</span><span class="s3">, </span><span class="s1">source: Union[int</span><span class="s3">, </span><span class="s1">Sequence[int]]</span><span class="s3">,</span>
             <span class="s1">destination: Union[int</span><span class="s3">, </span><span class="s1">Sequence[int]]) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;moveaxis&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">return </span><span class="s1">_moveaxis(asarray(a)</span><span class="s3">, </span><span class="s1">_ensure_index_tuple(source)</span><span class="s3">,</span>
                   <span class="s1">_ensure_index_tuple(destination))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'source'</span><span class="s3">, </span><span class="s4">'destination'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_moveaxis(a: Array</span><span class="s3">, </span><span class="s1">source: Tuple[int</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">destination: Tuple[int</span><span class="s3">, </span><span class="s1">...]) -&gt; Array:</span>
  <span class="s1">source = tuple(_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">ndim(a)) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">source)</span>
  <span class="s1">destination = tuple(_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">ndim(a)) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">destination)</span>
  <span class="s3">if </span><span class="s1">len(source) != len(destination):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Inconsistent number of elements: {} vs {}&quot;</span>
                     <span class="s1">.format(len(source)</span><span class="s3">, </span><span class="s1">len(destination)))</span>
  <span class="s1">perm = [i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ndim(a)) </span><span class="s3">if </span><span class="s1">i </span><span class="s3">not in </span><span class="s1">source]</span>
  <span class="s3">for </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">src </span><span class="s3">in </span><span class="s1">sorted(zip(destination</span><span class="s3">, </span><span class="s1">source)):</span>
    <span class="s1">perm.insert(dest</span><span class="s3">, </span><span class="s1">src)</span>
  <span class="s3">return </span><span class="s1">lax.transpose(a</span><span class="s3">, </span><span class="s1">perm)</span>


<span class="s1">@util._wraps(np.isclose)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'equal_nan'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">isclose(a: ArrayLike</span><span class="s3">, </span><span class="s1">b: ArrayLike</span><span class="s3">, </span><span class="s1">rtol: ArrayLike = </span><span class="s5">1e-05</span><span class="s3">, </span><span class="s1">atol: ArrayLike = </span><span class="s5">1e-08</span><span class="s3">,</span>
            <span class="s1">equal_nan: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_args(</span><span class="s4">&quot;isclose&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s1">dtype = _dtype(a)</span>
  <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">inexact):</span>
    <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">complexfloating):</span>
      <span class="s1">dtype = util._complex_elem_type(dtype)</span>
    <span class="s1">rtol = lax.convert_element_type(rtol</span><span class="s3">, </span><span class="s1">dtype)</span>
    <span class="s1">atol = lax.convert_element_type(atol</span><span class="s3">, </span><span class="s1">dtype)</span>
    <span class="s1">out = lax.le(</span>
      <span class="s1">lax.abs(lax.sub(a</span><span class="s3">, </span><span class="s1">b))</span><span class="s3">,</span>
      <span class="s1">lax.add(atol</span><span class="s3">, </span><span class="s1">lax.mul(rtol</span><span class="s3">, </span><span class="s1">lax.abs(b))))</span>
    <span class="s0"># This corrects the comparisons for infinite and nan values</span>
    <span class="s1">a_inf = ufuncs.isinf(a)</span>
    <span class="s1">b_inf = ufuncs.isinf(b)</span>
    <span class="s1">any_inf = ufuncs.logical_or(a_inf</span><span class="s3">, </span><span class="s1">b_inf)</span>
    <span class="s1">both_inf = ufuncs.logical_and(a_inf</span><span class="s3">, </span><span class="s1">b_inf)</span>
    <span class="s0"># Make all elements where either a or b are infinite to False</span>
    <span class="s1">out = ufuncs.logical_and(out</span><span class="s3">, </span><span class="s1">ufuncs.logical_not(any_inf))</span>
    <span class="s0"># Make all elements where both a or b are the same inf to True</span>
    <span class="s1">same_value = lax.eq(a</span><span class="s3">, </span><span class="s1">b)</span>
    <span class="s1">same_inf = ufuncs.logical_and(both_inf</span><span class="s3">, </span><span class="s1">same_value)</span>
    <span class="s1">out = ufuncs.logical_or(out</span><span class="s3">, </span><span class="s1">same_inf)</span>

    <span class="s0"># Make all elements where either a or b is NaN to False</span>
    <span class="s1">a_nan = ufuncs.isnan(a)</span>
    <span class="s1">b_nan = ufuncs.isnan(b)</span>
    <span class="s1">any_nan = ufuncs.logical_or(a_nan</span><span class="s3">, </span><span class="s1">b_nan)</span>
    <span class="s1">out = ufuncs.logical_and(out</span><span class="s3">, </span><span class="s1">ufuncs.logical_not(any_nan))</span>
    <span class="s3">if </span><span class="s1">equal_nan:</span>
      <span class="s0"># Make all elements where both a and b is NaN to True</span>
      <span class="s1">both_nan = ufuncs.logical_and(a_nan</span><span class="s3">, </span><span class="s1">b_nan)</span>
      <span class="s1">out = ufuncs.logical_or(out</span><span class="s3">, </span><span class="s1">both_nan)</span>
    <span class="s3">return </span><span class="s1">out</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.eq(a</span><span class="s3">, </span><span class="s1">b)</span>


<span class="s1">@util._wraps(np.interp)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">interp(x: ArrayLike</span><span class="s3">, </span><span class="s1">xp: ArrayLike</span><span class="s3">, </span><span class="s1">fp: ArrayLike</span><span class="s3">,</span>
           <span class="s1">left: Optional[ArrayLike] = </span><span class="s3">None,</span>
           <span class="s1">right: Optional[ArrayLike] = </span><span class="s3">None,</span>
           <span class="s1">period: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;interp&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp)</span>
  <span class="s3">if </span><span class="s1">shape(xp) != shape(fp) </span><span class="s3">or </span><span class="s1">ndim(xp) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;xp and fp must be one-dimensional arrays of equal size&quot;</span><span class="s1">)</span>
  <span class="s1">x_arr</span><span class="s3">, </span><span class="s1">xp_arr = util.promote_dtypes_inexact(x</span><span class="s3">, </span><span class="s1">xp)</span>
  <span class="s1">fp_arr</span><span class="s3">, </span><span class="s1">= util.promote_dtypes_inexact(fp)</span>
  <span class="s3">del </span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span>

  <span class="s3">if </span><span class="s1">dtypes.issubdtype(x_arr.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.interp: complex x values not supported.&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">period </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">ndim(period) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;period must be a scalar; got </span><span class="s3">{</span><span class="s1">period</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">period = ufuncs.abs(period)</span>
    <span class="s1">x_arr = x_arr % period</span>
    <span class="s1">xp_arr = xp_arr % period</span>
    <span class="s1">xp_arr</span><span class="s3">, </span><span class="s1">fp_arr = lax.sort_key_val(xp_arr</span><span class="s3">, </span><span class="s1">fp_arr)</span>
    <span class="s1">xp_arr = concatenate([xp_arr[-</span><span class="s5">1</span><span class="s1">:] - period</span><span class="s3">, </span><span class="s1">xp_arr</span><span class="s3">, </span><span class="s1">xp_arr[:</span><span class="s5">1</span><span class="s1">] + period])</span>
    <span class="s1">fp_arr = concatenate([fp_arr[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">fp_arr</span><span class="s3">, </span><span class="s1">fp_arr[:</span><span class="s5">1</span><span class="s1">]])</span>

  <span class="s1">i = clip(searchsorted(xp_arr</span><span class="s3">, </span><span class="s1">x_arr</span><span class="s3">, </span><span class="s1">side=</span><span class="s4">'right'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">len(xp_arr) - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">df = fp_arr[i] - fp_arr[i - </span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">dx = xp_arr[i] - xp_arr[i - </span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">delta = x_arr - xp_arr[i - </span><span class="s5">1</span><span class="s1">]</span>

  <span class="s1">epsilon = np.spacing(np.finfo(xp_arr.dtype).eps)</span>
  <span class="s1">dx0 = lax.abs(dx) &lt;= epsilon  </span><span class="s0"># Prevent NaN gradients when `dx` is small.</span>
  <span class="s1">f = where(dx0</span><span class="s3">, </span><span class="s1">fp_arr[i - </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fp_arr[i - </span><span class="s5">1</span><span class="s1">] + (delta / where(dx0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dx)) * df)</span>

  <span class="s1">left_arr: ArrayLike = fp_arr[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">left </span><span class="s3">is None else </span><span class="s1">left</span>
  <span class="s1">right_arr: ArrayLike = fp_arr[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">if </span><span class="s1">right </span><span class="s3">is None else </span><span class="s1">right</span>

  <span class="s3">if </span><span class="s1">period </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">f = where(x_arr &lt; xp_arr[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">left_arr</span><span class="s3">, </span><span class="s1">f)</span>
    <span class="s1">f = where(x_arr &gt; xp_arr[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">right_arr</span><span class="s3">, </span><span class="s1">f)</span>
  <span class="s3">return </span><span class="s1">f</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">where(condition: ArrayLike</span><span class="s3">, </span><span class="s1">x: Literal[</span><span class="s3">None</span><span class="s1">] = </span><span class="s3">None, </span><span class="s1">y: Literal[</span><span class="s3">None</span><span class="s1">] = </span><span class="s3">None, </span><span class="s1">*</span><span class="s3">,</span>
          <span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
          <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span>
          <span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">...]: ...</span>

<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">where(condition: ArrayLike</span><span class="s3">, </span><span class="s1">x: ArrayLike</span><span class="s3">, </span><span class="s1">y: ArrayLike</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
          <span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
          <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span>
          <span class="s1">) -&gt; Array: ...</span>

<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">where(condition: ArrayLike</span><span class="s3">, </span><span class="s1">x: Optional[ArrayLike] = </span><span class="s3">None,</span>
          <span class="s1">y: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
          <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span>
          <span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">...]]: ...</span>

<span class="s1">@util._wraps(np.where</span><span class="s3">,</span>
  <span class="s1">lax_description=_dedent(</span><span class="s4">&quot;&quot;&quot; 
    At present, JAX does not support JIT-compilation of the single-argument form 
    of :py:func:`jax.numpy.where` because its output shape is data-dependent. The 
    three-argument form does not have a data-dependent shape and can be JIT-compiled 
    successfully. Alternatively, you can use the optional ``size`` keyword to 
    statically specify the expected size of the output.</span><span class="s3">\n\n</span>

    <span class="s4">Special care is needed when the ``x`` or ``y`` input to 
    :py:func:`jax.numpy.where` could have a value of NaN. 
    Specifically, when a gradient is taken 
    with :py:func:`jax.grad` (reverse-mode differentiation), a NaN in either 
    ``x`` or ``y`` will propagate into the gradient, regardless of the value 
    of ``condition``.  More information on this behavior and workarounds 
    is available in the JAX FAQ: 
    https://jax.readthedocs.io/en/latest/faq.html#gradients-contain-nan-where-using-where&quot;&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
  <span class="s1">extra_params=_dedent(</span><span class="s4">&quot;&quot;&quot; 
    size : int, optional 
        Only referenced when ``x`` and ``y`` are ``None``. If specified, the indices of the first 
        ``size`` elements of the result will be returned. If there are fewer elements than ``size`` 
        indicates, the return value will be padded with ``fill_value``. 
    fill_value : array_like, optional 
        When ``size`` is specified and there are fewer than the indicated number of elements, the 
        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">where(condition: ArrayLike</span><span class="s3">, </span><span class="s1">x: Optional[ArrayLike] = </span><span class="s3">None,</span>
          <span class="s1">y: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
          <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">...]]:</span>
  <span class="s3">if </span><span class="s1">x </span><span class="s3">is None and </span><span class="s1">y </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;where&quot;</span><span class="s3">, </span><span class="s1">condition)</span>
    <span class="s3">return </span><span class="s1">nonzero(condition</span><span class="s3">, </span><span class="s1">size=size</span><span class="s3">, </span><span class="s1">fill_value=fill_value)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;where&quot;</span><span class="s3">, </span><span class="s1">condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s3">if </span><span class="s1">size </span><span class="s3">is not None or </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;size and fill_value arguments cannot be used in three-term where function.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">util._where(condition</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y)</span>


<span class="s1">@util._wraps(np.select)</span>
<span class="s3">def </span><span class="s1">select(condlist</span><span class="s3">, </span><span class="s1">choicelist</span><span class="s3">, </span><span class="s1">default=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">len(condlist) != len(choicelist):</span>
    <span class="s1">msg = </span><span class="s4">&quot;condlist must have length equal to choicelist ({} vs {})&quot;</span>
    <span class="s3">raise </span><span class="s1">ValueError(msg.format(len(condlist)</span><span class="s3">, </span><span class="s1">len(choicelist)))</span>
  <span class="s3">if </span><span class="s1">len(condlist) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;condlist must be non-empty&quot;</span><span class="s1">)</span>
  <span class="s1">choices = util.promote_dtypes(default</span><span class="s3">, </span><span class="s1">*choicelist)</span>
  <span class="s1">choicelist = choices[</span><span class="s5">1</span><span class="s1">:]</span>
  <span class="s1">output = choices[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s3">for </span><span class="s1">cond</span><span class="s3">, </span><span class="s1">choice </span><span class="s3">in </span><span class="s1">zip(condlist[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">choicelist[::-</span><span class="s5">1</span><span class="s1">]):</span>
    <span class="s1">output = where(cond</span><span class="s3">, </span><span class="s1">choice</span><span class="s3">, </span><span class="s1">output)</span>
  <span class="s3">return </span><span class="s1">output</span>


<span class="s1">@util._wraps(np.bincount</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Jax adds the optional `length` parameter which specifies the output length, and 
defaults to ``x.max() + 1``. It must be specified for bincount to be compiled 
with non-static operands. Values larger than the specified length will be discarded. 
If `length` is specified, `minlength` will be ignored. 
 
Additionally, while ``np.bincount`` raises an error if the input array contains 
negative values, ``jax.numpy.bincount`` clips negative values to zero. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">bincount(x: ArrayLike</span><span class="s3">, </span><span class="s1">weights: Optional[ArrayLike] = </span><span class="s3">None,</span>
             <span class="s1">minlength: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">length: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;bincount&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(x)</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;x argument to bincount must have an integer type; got </span><span class="s3">{</span><span class="s1">_dtype(x)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ndim(x) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;only 1-dimensional input supported.&quot;</span><span class="s1">)</span>
  <span class="s1">minlength = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">,</span>
      <span class="s4">&quot;The error occurred because of argument 'minlength' of jnp.bincount.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">length </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">x_arr = core.concrete_or_error(asarray</span><span class="s3">, </span><span class="s1">x</span><span class="s3">,</span>
      <span class="s4">&quot;The error occurred because of argument 'x' of jnp.bincount. &quot;</span>
      <span class="s4">&quot;To avoid this error, pass a static `length` argument.&quot;</span><span class="s1">)</span>
    <span class="s1">length = _max(minlength</span><span class="s3">, </span><span class="s1">x_arr.size </span><span class="s3">and </span><span class="s1">int(x_arr.max()) + </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">elif not </span><span class="s1">core.is_special_dim_size(length):</span>
    <span class="s1">length = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">length</span><span class="s3">,</span>
        <span class="s4">&quot;The error occurred because of argument 'length' of jnp.bincount.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">weights </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">weights = np.array(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=int_)</span>
  <span class="s3">elif </span><span class="s1">shape(x) != shape(weights):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;shape of weights must match shape of x.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">zeros(length</span><span class="s3">, </span><span class="s1">_dtype(weights)).at[clip(x</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)].add(weights)</span>

<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">broadcast_shapes(*shapes: Tuple[int</span><span class="s3">, </span><span class="s1">...]) -&gt; Tuple[int</span><span class="s3">, </span><span class="s1">...]: ...</span>

<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">broadcast_shapes(*shapes: Tuple[Union[int</span><span class="s3">, </span><span class="s1">core.Tracer]</span><span class="s3">, </span><span class="s1">...]</span>
                     <span class="s1">) -&gt; Tuple[Union[int</span><span class="s3">, </span><span class="s1">core.Tracer]</span><span class="s3">, </span><span class="s1">...]: ...</span>

<span class="s1">@util._wraps(getattr(np</span><span class="s3">, </span><span class="s4">&quot;broadcast_shapes&quot;</span><span class="s3">, None</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">broadcast_shapes(*shapes):</span>
  <span class="s3">if not </span><span class="s1">shapes:</span>
    <span class="s3">return </span><span class="s1">()</span>
  <span class="s1">shapes = [(shape</span><span class="s3">,</span><span class="s1">) </span><span class="s3">if </span><span class="s1">np.ndim(shape) == </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">tuple(shape) </span><span class="s3">for </span><span class="s1">shape </span><span class="s3">in </span><span class="s1">shapes]</span>
  <span class="s3">return </span><span class="s1">lax.broadcast_shapes(*shapes)</span>


<span class="s1">@util._wraps(np.broadcast_arrays</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">The JAX version does not necessarily return a view of the input. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">broadcast_arrays(*args: ArrayLike) -&gt; List[Array]:</span>
  <span class="s3">return </span><span class="s1">util._broadcast_arrays(*args)</span>


<span class="s1">@util._wraps(np.broadcast_to</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">The JAX version does not necessarily return a view of the input. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">broadcast_to(array: ArrayLike</span><span class="s3">, </span><span class="s1">shape: Shape) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">util._broadcast_to(array</span><span class="s3">, </span><span class="s1">shape)</span>


<span class="s3">def </span><span class="s1">_split(op: str</span><span class="s3">, </span><span class="s1">ary: ArrayLike</span><span class="s3">, </span><span class="s1">indices_or_sections: Union[int</span><span class="s3">, </span><span class="s1">ArrayLike]</span><span class="s3">,</span>
           <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; List[Array]:</span>
  <span class="s1">util.check_arraylike(op</span><span class="s3">, </span><span class="s1">ary)</span>
  <span class="s1">ary = asarray(ary)</span>
  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">f&quot;in jax.numpy.</span><span class="s3">{</span><span class="s1">op</span><span class="s3">} </span><span class="s4">argument `axis`&quot;</span><span class="s1">)</span>
  <span class="s1">size = ary.shape[axis]</span>
  <span class="s3">if </span><span class="s1">isinstance(indices_or_sections</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)):</span>
    <span class="s1">indices_or_sections = np.array(</span>
        <span class="s1">[core.concrete_or_error(np.int64</span><span class="s3">, </span><span class="s1">i_s</span><span class="s3">, </span><span class="s4">f&quot;in jax.numpy.</span><span class="s3">{</span><span class="s1">op</span><span class="s3">} </span><span class="s4">argument 1&quot;</span><span class="s1">)</span>
         <span class="s3">for </span><span class="s1">i_s </span><span class="s3">in </span><span class="s1">indices_or_sections]</span><span class="s3">, </span><span class="s1">np.int64)</span>
    <span class="s1">split_indices = np.concatenate([[np.int64(</span><span class="s5">0</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">,</span>
                                    <span class="s1">[np.int64(size)]])</span>
  <span class="s3">elif </span><span class="s1">(isinstance(indices_or_sections</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)) </span><span class="s3">and</span>
        <span class="s1">indices_or_sections.ndim &gt; </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s1">indices_or_sections = np.array(</span>
        <span class="s1">[core.concrete_or_error(np.int64</span><span class="s3">, </span><span class="s1">i_s</span><span class="s3">, </span><span class="s4">f&quot;in jax.numpy.</span><span class="s3">{</span><span class="s1">op</span><span class="s3">} </span><span class="s4">argument 1&quot;</span><span class="s1">)</span>
         <span class="s3">for </span><span class="s1">i_s </span><span class="s3">in </span><span class="s1">indices_or_sections]</span><span class="s3">, </span><span class="s1">np.int64)</span>
    <span class="s1">split_indices = np.concatenate([[np.int64(</span><span class="s5">0</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">,</span>
                                    <span class="s1">[np.int64(size)]])</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">indices_or_sections = core.concrete_or_error(np.int64</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">,</span>
                                                 <span class="s4">f&quot;in jax.numpy.</span><span class="s3">{</span><span class="s1">op</span><span class="s3">} </span><span class="s4">argument 1&quot;</span><span class="s1">)</span>
    <span class="s1">part_size</span><span class="s3">, </span><span class="s1">r = _divmod(size</span><span class="s3">, </span><span class="s1">indices_or_sections)  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s3">if </span><span class="s1">r == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">split_indices = [np.int64(i) * part_size  </span><span class="s0"># type: ignore</span>
                       <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(indices_or_sections + </span><span class="s5">1</span><span class="s1">)]  </span><span class="s0"># type: ignore</span>
    <span class="s3">elif </span><span class="s1">op == </span><span class="s4">&quot;array_split&quot;</span><span class="s1">:</span>
      <span class="s1">split_indices = (</span>
        <span class="s1">[np.int64(i) * (part_size + </span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(r + </span><span class="s5">1</span><span class="s1">)] +  </span><span class="s0"># type: ignore</span>
        <span class="s1">[np.int64(i) * part_size + ((r + </span><span class="s5">1</span><span class="s1">) * (part_size + </span><span class="s5">1</span><span class="s1">) - </span><span class="s5">1</span><span class="s1">)</span>
         <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(indices_or_sections - r)])</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;array split does not result in an equal division&quot;</span><span class="s1">)</span>
  <span class="s1">starts</span><span class="s3">, </span><span class="s1">ends = [</span><span class="s5">0</span><span class="s1">] * ndim(ary)</span><span class="s3">, </span><span class="s1">shape(ary)</span>
  <span class="s1">_subval = </span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v: subvals(x</span><span class="s3">, </span><span class="s1">[(i</span><span class="s3">, </span><span class="s1">v)])</span>
  <span class="s3">return </span><span class="s1">[lax.slice(ary</span><span class="s3">, </span><span class="s1">_subval(starts</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">start)</span><span class="s3">, </span><span class="s1">_subval(ends</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">end))</span>
          <span class="s3">for </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">in </span><span class="s1">zip(split_indices[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">split_indices[</span><span class="s5">1</span><span class="s1">:])]</span>

<span class="s1">@util._wraps(np.split</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">split(ary: ArrayLike</span><span class="s3">, </span><span class="s1">indices_or_sections: Union[int</span><span class="s3">, </span><span class="s1">ArrayLike]</span><span class="s3">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; List[Array]:</span>
  <span class="s3">return </span><span class="s1">_split(</span><span class="s4">&quot;split&quot;</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis=axis)</span>

<span class="s3">def </span><span class="s1">_split_on_axis(op: str</span><span class="s3">, </span><span class="s1">axis: int) -&gt; Callable[[ArrayLike</span><span class="s3">, </span><span class="s1">Union[int</span><span class="s3">, </span><span class="s1">ArrayLike]]</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s1">@util._wraps(getattr(np</span><span class="s3">, </span><span class="s1">op)</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">def </span><span class="s1">f(ary: ArrayLike</span><span class="s3">, </span><span class="s1">indices_or_sections: Union[int</span><span class="s3">, </span><span class="s1">ArrayLike]) -&gt; List[Array]:</span>
    <span class="s0"># for 1-D array, hsplit becomes vsplit</span>
    <span class="s3">nonlocal </span><span class="s1">axis</span>
    <span class="s1">util.check_arraylike(op</span><span class="s3">, </span><span class="s1">ary)</span>
    <span class="s1">a = asarray(ary)</span>
    <span class="s3">if </span><span class="s1">axis == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">len(a.shape) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">_split(op</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis=axis)</span>
  <span class="s3">return </span><span class="s1">f</span>

<span class="s1">vsplit = _split_on_axis(</span><span class="s4">&quot;vsplit&quot;</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">hsplit = _split_on_axis(</span><span class="s4">&quot;hsplit&quot;</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">dsplit = _split_on_axis(</span><span class="s4">&quot;dsplit&quot;</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>

<span class="s1">@util._wraps(np.array_split)</span>
<span class="s3">def </span><span class="s1">array_split(ary: ArrayLike</span><span class="s3">, </span><span class="s1">indices_or_sections: Union[int</span><span class="s3">, </span><span class="s1">ArrayLike]</span><span class="s3">, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; List[Array]:</span>
  <span class="s3">return </span><span class="s1">_split(</span><span class="s4">&quot;array_split&quot;</span><span class="s3">, </span><span class="s1">ary</span><span class="s3">, </span><span class="s1">indices_or_sections</span><span class="s3">, </span><span class="s1">axis=axis)</span>

<span class="s1">@util._wraps(np.clip</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">clip(a: ArrayLike</span><span class="s3">, </span><span class="s1">a_min: Optional[ArrayLike] = </span><span class="s3">None,</span>
         <span class="s1">a_max: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;clip&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.clip is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">a_min </span><span class="s3">is None and </span><span class="s1">a_max </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;At most one of a_min and a_max may be None&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">a_min </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">a = ufuncs.maximum(a_min</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">a_max </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">a = ufuncs.minimum(a_max</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">return </span><span class="s1">asarray(a)</span>

<span class="s1">@util._wraps(np.around</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'decimals'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">round(a: ArrayLike</span><span class="s3">, </span><span class="s1">decimals: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;round&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">decimals = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">, </span><span class="s4">&quot;'decimals' argument of jnp.round&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.round is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = _dtype(a)</span>
  <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">if </span><span class="s1">decimals &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
        <span class="s4">&quot;integer np.round not implemented for decimals &lt; 0&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">asarray(a)  </span><span class="s0"># no-op on integer types</span>

  <span class="s3">def </span><span class="s1">_round_float(x: ArrayLike) -&gt; Array:</span>
    <span class="s3">if </span><span class="s1">decimals == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">lax.round(x</span><span class="s3">, </span><span class="s1">lax.RoundingMethod.TO_NEAREST_EVEN)</span>

    <span class="s0"># TODO(phawkins): the strategy of rescaling the value isn't necessarily a</span>
    <span class="s0"># good one since we may be left with an incorrectly rounded value at the</span>
    <span class="s0"># end due to precision problems. As a workaround for float16, convert to</span>
    <span class="s0"># float32,</span>
    <span class="s1">x = lax.convert_element_type(x</span><span class="s3">, </span><span class="s1">np.float32) </span><span class="s3">if </span><span class="s1">dtype == np.float16 </span><span class="s3">else </span><span class="s1">x</span>
    <span class="s1">factor = _lax_const(x</span><span class="s3">, </span><span class="s5">10 </span><span class="s1">** decimals)</span>
    <span class="s1">out = lax.div(lax.round(lax.mul(x</span><span class="s3">, </span><span class="s1">factor)</span><span class="s3">,</span>
                            <span class="s1">lax.RoundingMethod.TO_NEAREST_EVEN)</span><span class="s3">, </span><span class="s1">factor)</span>
    <span class="s3">return </span><span class="s1">lax.convert_element_type(out</span><span class="s3">, </span><span class="s1">dtype) </span><span class="s3">if </span><span class="s1">dtype == np.float16 </span><span class="s3">else </span><span class="s1">out</span>

  <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">complexfloating):</span>
    <span class="s3">return </span><span class="s1">lax.complex(_round_float(lax.real(a))</span><span class="s3">, </span><span class="s1">_round_float(lax.imag(a)))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_round_float(a)</span>
<span class="s1">around = round</span>
<span class="s1">round_ = round</span>


<span class="s1">@util._wraps(np.fix</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">fix(x: ArrayLike</span><span class="s3">, </span><span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;fix&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.fix is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">zero = _lax_const(x</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">where(lax.ge(x</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">ufuncs.floor(x)</span><span class="s3">, </span><span class="s1">ufuncs.ceil(x))</span>


<span class="s1">@util._wraps(np.nan_to_num)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">nan_to_num(x: ArrayLike</span><span class="s3">, </span><span class="s1">copy: bool = </span><span class="s3">True, </span><span class="s1">nan: ArrayLike = </span><span class="s5">0.0</span><span class="s3">,</span>
               <span class="s1">posinf: Optional[ArrayLike] = </span><span class="s3">None,</span>
               <span class="s1">neginf: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">del </span><span class="s1">copy</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;nan_to_num&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = _dtype(x)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">inexact):</span>
    <span class="s3">return </span><span class="s1">asarray(x)</span>
  <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">complexfloating):</span>
    <span class="s3">return </span><span class="s1">lax.complex(</span>
      <span class="s1">nan_to_num(lax.real(x)</span><span class="s3">, </span><span class="s1">nan=nan</span><span class="s3">, </span><span class="s1">posinf=posinf</span><span class="s3">, </span><span class="s1">neginf=neginf)</span><span class="s3">,</span>
      <span class="s1">nan_to_num(lax.imag(x)</span><span class="s3">, </span><span class="s1">nan=nan</span><span class="s3">, </span><span class="s1">posinf=posinf</span><span class="s3">, </span><span class="s1">neginf=neginf))</span>
  <span class="s1">info = finfo(dtypes.canonicalize_dtype(dtype))</span>
  <span class="s1">posinf = info.max </span><span class="s3">if </span><span class="s1">posinf </span><span class="s3">is None else </span><span class="s1">posinf</span>
  <span class="s1">neginf = info.min </span><span class="s3">if </span><span class="s1">neginf </span><span class="s3">is None else </span><span class="s1">neginf</span>
  <span class="s1">out = where(ufuncs.isnan(x)</span><span class="s3">, </span><span class="s1">asarray(nan</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">out = where(ufuncs.isposinf(out)</span><span class="s3">, </span><span class="s1">asarray(posinf</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">out)</span>
  <span class="s1">out = where(ufuncs.isneginf(out)</span><span class="s3">, </span><span class="s1">asarray(neginf</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">out)</span>
  <span class="s3">return </span><span class="s1">out</span>


<span class="s1">@util._wraps(np.allclose)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'equal_nan'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">allclose(a: ArrayLike</span><span class="s3">, </span><span class="s1">b: ArrayLike</span><span class="s3">, </span><span class="s1">rtol: ArrayLike = </span><span class="s5">1e-05</span><span class="s3">,</span>
             <span class="s1">atol: ArrayLike = </span><span class="s5">1e-08</span><span class="s3">, </span><span class="s1">equal_nan: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;allclose&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">return </span><span class="s1">reductions.all(isclose(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">equal_nan))</span>


<span class="s1">_NONZERO_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Because the size of the output of ``nonzero`` is data-dependent, the function is not 
typically compatible with JIT. The JAX version adds the optional ``size`` argument which 
must be specified statically for ``jnp.nonzero`` to be used within some of JAX's 
transformations. 
&quot;&quot;&quot;</span>
<span class="s1">_NONZERO_EXTRA_PARAMS = </span><span class="s4">&quot;&quot;&quot; 
size : int, optional 
    If specified, the indices of the first ``size`` True elements will be returned. If there are 
    fewer unique elements than ``size`` indicates, the return value will be padded with ``fill_value``. 
fill_value : array_like, optional 
    When ``size`` is specified and there are fewer than the indicated number of elements, the 
    remaining elements will be filled with ``fill_value``, which defaults to zero. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.nonzero</span><span class="s3">, </span><span class="s1">lax_description=_NONZERO_DOC</span><span class="s3">, </span><span class="s1">extra_params=_NONZERO_EXTRA_PARAMS)</span>
<span class="s3">def </span><span class="s1">nonzero(a: ArrayLike</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
            <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">ArrayLike</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">...]:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;nonzero&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">arr = atleast_1d(a)</span>
  <span class="s3">del </span><span class="s1">a</span>
  <span class="s1">mask = arr </span><span class="s3">if </span><span class="s1">arr.dtype == bool </span><span class="s3">else </span><span class="s1">(arr != </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">size </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">size = mask.sum()</span>
  <span class="s3">if not </span><span class="s1">core.is_special_dim_size(size):</span>
    <span class="s1">size = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">size</span><span class="s3">,</span>
      <span class="s4">&quot;The size argument of jnp.nonzero must be statically specified &quot;</span>
      <span class="s4">&quot;to use jnp.nonzero within JAX transformations.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">arr.size == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">size == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">tuple(zeros(size</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">for </span><span class="s1">dim </span><span class="s3">in </span><span class="s1">arr.shape)</span>
  <span class="s1">flat_indices = reductions.cumsum(bincount(reductions.cumsum(mask)</span><span class="s3">, </span><span class="s1">length=size))</span>
  <span class="s1">strides = (np.cumprod(arr.shape[::-</span><span class="s5">1</span><span class="s1">])[::-</span><span class="s5">1</span><span class="s1">] // arr.shape).astype(int_)</span>
  <span class="s1">out = tuple((flat_indices // stride) % size </span><span class="s3">for </span><span class="s1">stride</span><span class="s3">, </span><span class="s1">size </span><span class="s3">in </span><span class="s1">zip(strides</span><span class="s3">, </span><span class="s1">arr.shape))</span>
  <span class="s3">if </span><span class="s1">size </span><span class="s3">is not None and </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">fill_value_tup = fill_value </span><span class="s3">if </span><span class="s1">isinstance(fill_value</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">else </span><span class="s1">arr.ndim * (fill_value</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">_any(_shape(val) != () </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">fill_value_tup):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;fill_value must be a scalar or a tuple of length </span><span class="s3">{</span><span class="s1">arr.ndim</span><span class="s3">}</span><span class="s4">; got </span><span class="s3">{</span><span class="s1">fill_value</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">fill_mask = arange(size) &gt;= mask.sum()</span>
    <span class="s1">out = tuple(where(fill_mask</span><span class="s3">, </span><span class="s1">fval</span><span class="s3">, </span><span class="s1">entry) </span><span class="s3">for </span><span class="s1">fval</span><span class="s3">, </span><span class="s1">entry </span><span class="s3">in </span><span class="s1">safe_zip(fill_value_tup</span><span class="s3">, </span><span class="s1">out))</span>
  <span class="s3">return </span><span class="s1">out</span>

<span class="s1">@util._wraps(np.flatnonzero</span><span class="s3">, </span><span class="s1">lax_description=_NONZERO_DOC</span><span class="s3">, </span><span class="s1">extra_params=_NONZERO_EXTRA_PARAMS)</span>
<span class="s3">def </span><span class="s1">flatnonzero(a: ArrayLike</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None,</span>
                <span class="s1">fill_value: Union[</span><span class="s3">None, </span><span class="s1">ArrayLike</span><span class="s3">, </span><span class="s1">Tuple[ArrayLike]] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">nonzero(ravel(a)</span><span class="s3">, </span><span class="s1">size=size</span><span class="s3">, </span><span class="s1">fill_value=fill_value)[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s1">@util._wraps(np.unwrap)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">unwrap(p: ArrayLike</span><span class="s3">, </span><span class="s1">discont: Optional[ArrayLike] = </span><span class="s3">None,</span>
           <span class="s1">axis: int = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">period: ArrayLike = </span><span class="s5">2 </span><span class="s1">* pi) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;unwrap&quot;</span><span class="s3">, </span><span class="s1">p)</span>
  <span class="s1">p = asarray(p)</span>
  <span class="s3">if </span><span class="s1">issubdtype(p.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.unwrap does not support complex inputs.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">p.shape[axis] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">util.promote_dtypes_inexact(p)[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s3">if </span><span class="s1">discont </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">discont = period / </span><span class="s5">2</span>
  <span class="s1">interval = period / </span><span class="s5">2</span>
  <span class="s1">dd = diff(p</span><span class="s3">, </span><span class="s1">axis=axis)</span>
  <span class="s1">ddmod = ufuncs.mod(dd + interval</span><span class="s3">, </span><span class="s1">period) - interval</span>
  <span class="s1">ddmod = where((ddmod == -interval) &amp; (dd &gt; </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">interval</span><span class="s3">, </span><span class="s1">ddmod)</span>

  <span class="s1">ph_correct = where(ufuncs.abs(dd) &lt; discont</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">ddmod - dd)</span>

  <span class="s1">up = concatenate((</span>
    <span class="s1">lax.slice_in_dim(p</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=axis)</span><span class="s3">,</span>
    <span class="s1">lax.slice_in_dim(p</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">axis=axis) + reductions.cumsum(ph_correct</span><span class="s3">, </span><span class="s1">axis=axis)</span>
  <span class="s1">)</span><span class="s3">, </span><span class="s1">axis=axis)</span>

  <span class="s3">return </span><span class="s1">up</span>


<span class="s0">### Padding</span>

<span class="s1">PadValueLike = Union[T</span><span class="s3">, </span><span class="s1">Sequence[T]</span><span class="s3">, </span><span class="s1">Sequence[Sequence[T]]]</span>
<span class="s1">PadValue = Tuple[Tuple[T</span><span class="s3">, </span><span class="s1">T]</span><span class="s3">, </span><span class="s1">...]</span>
<span class="s0"># TODO(jakevdp): make this a protocol</span>
<span class="s1">PadStatFunc = Callable[...</span><span class="s3">, </span><span class="s1">Array]</span>


<span class="s3">def </span><span class="s1">_broadcast_to_pairs(nvals: PadValueLike</span><span class="s3">, </span><span class="s1">nd: int</span><span class="s3">, </span><span class="s1">name: str) -&gt; PadValue:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">nvals = np.asarray(tree_map(</span>
      <span class="s3">lambda </span><span class="s1">x: core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">context=</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s4">argument of jnp.pad&quot;</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">nvals))</span>
  <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
    <span class="s0"># In numpy 1.24</span>
    <span class="s3">if </span><span class="s4">&quot;array has an inhomogeneous shape&quot; </span><span class="s3">in </span><span class="s1">str(e):</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f'`</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">` entries must be the same shape: </span><span class="s3">{</span><span class="s1">nvals</span><span class="s3">}</span><span class="s4">'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
    <span class="s3">raise</span>

  <span class="s3">def </span><span class="s1">as_scalar_dim(v):</span>
    <span class="s3">if </span><span class="s1">core.is_special_dim_size(v) </span><span class="s3">or not </span><span class="s1">np.shape(v):</span>
      <span class="s3">return </span><span class="s1">v</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f'`</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">` entries must be the same shape: </span><span class="s3">{</span><span class="s1">nvals</span><span class="s3">}</span><span class="s4">'</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">nvals.shape == (nd</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
    <span class="s0"># ((before_1, after_1), ..., (before_N, after_N))</span>
    <span class="s3">return </span><span class="s1">tuple((as_scalar_dim(nval[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">as_scalar_dim(nval[</span><span class="s5">1</span><span class="s1">])) </span><span class="s3">for </span><span class="s1">nval </span><span class="s3">in </span><span class="s1">nvals)</span>
  <span class="s3">elif </span><span class="s1">nvals.shape == (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
    <span class="s0"># ((before, after),)</span>
    <span class="s1">v1_2 = as_scalar_dim(nvals[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">as_scalar_dim(nvals[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">tuple(v1_2 </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd))</span>
  <span class="s3">elif </span><span class="s1">nvals.shape == (</span><span class="s5">2</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s0"># (before, after)  (not in the numpy docstring but works anyway)</span>
    <span class="s1">v1_2 = as_scalar_dim(nvals[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">as_scalar_dim(nvals[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">tuple(v1_2 </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd))</span>
  <span class="s3">elif </span><span class="s1">nvals.shape == (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">):</span>
    <span class="s0"># (pad,)</span>
    <span class="s1">v = as_scalar_dim(nvals[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">tuple((v</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd))</span>
  <span class="s3">elif </span><span class="s1">nvals.shape == ():</span>
    <span class="s0"># pad</span>
    <span class="s1">v = as_scalar_dim(nvals.flat[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">tuple((v</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;jnp.pad: </span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s4">with </span><span class="s3">{</span><span class="s1">nd=</span><span class="s3">} </span><span class="s4">has unsupported shape </span><span class="s3">{</span><span class="s1">nvals.shape</span><span class="s3">}</span><span class="s4">. &quot;</span>
                     <span class="s4">f&quot;Valid shapes are (</span><span class="s3">{</span><span class="s1">nd</span><span class="s3">}</span><span class="s4">, 2), (1, 2), (2,), (1,), or ().&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_check_no_padding(axis_padding: Tuple[Any</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">mode: str):</span>
  <span class="s3">if </span><span class="s1">(axis_padding[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">axis_padding[</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s1">msg = </span><span class="s4">&quot;Cannot apply '{}' padding to empty axis&quot;</span>
    <span class="s3">raise </span><span class="s1">ValueError(msg.format(mode))</span>


<span class="s3">def </span><span class="s1">_pad_constant(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]</span><span class="s3">, </span><span class="s1">constant_values: Array) -&gt; Array:</span>
  <span class="s1">nd = ndim(array)</span>
  <span class="s1">constant_values = broadcast_to(constant_values</span><span class="s3">, </span><span class="s1">(nd</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
  <span class="s1">constant_values = lax_internal._convert_element_type(</span>
      <span class="s1">constant_values</span><span class="s3">, </span><span class="s1">array.dtype</span><span class="s3">, </span><span class="s1">dtypes.is_weakly_typed(array))</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd):</span>
    <span class="s1">widths = [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)] * nd</span>
    <span class="s1">widths[i] = (pad_width[i][</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">array = lax.pad(array</span><span class="s3">, </span><span class="s1">constant_values[i</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">widths)</span>
    <span class="s1">widths[i] = (</span><span class="s5">0</span><span class="s3">, </span><span class="s1">pad_width[i][</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">array = lax.pad(array</span><span class="s3">, </span><span class="s1">constant_values[i</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">widths)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_wrap(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]) -&gt; Array:</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ndim(array)):</span>
    <span class="s3">if </span><span class="s1">array.shape[i] == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">_check_no_padding(pad_width[i]</span><span class="s3">, </span><span class="s4">&quot;wrap&quot;</span><span class="s1">)</span>
      <span class="s3">continue</span>
    <span class="s1">size = array.shape[i]</span>
    <span class="s1">repeats</span><span class="s3">, </span><span class="s1">(left_remainder</span><span class="s3">, </span><span class="s1">right_remainder) = np.divmod(pad_width[i]</span><span class="s3">, </span><span class="s1">size)</span>
    <span class="s1">total_repeats = repeats.sum() + </span><span class="s5">1</span>
    <span class="s1">parts = []</span>
    <span class="s3">if </span><span class="s1">left_remainder:</span>
      <span class="s1">parts += [lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">size - left_remainder</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis=i)]</span>
    <span class="s1">parts += total_repeats * [array]</span>
    <span class="s3">if </span><span class="s1">right_remainder:</span>
      <span class="s1">parts += [lax.slice_in_dim(array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">right_remainder</span><span class="s3">, </span><span class="s1">axis=i)]</span>
    <span class="s1">array = lax.concatenate(parts</span><span class="s3">, </span><span class="s1">dimension=i)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_symmetric_or_reflect(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]</span><span class="s3">,</span>
                              <span class="s1">mode: str</span><span class="s3">, </span><span class="s1">reflect_type: str) -&gt; Array:</span>
  <span class="s3">assert </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;symmetric&quot;</span><span class="s3">, </span><span class="s4">&quot;reflect&quot;</span><span class="s1">)</span>
  <span class="s3">assert </span><span class="s1">reflect_type </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;even&quot;</span><span class="s3">, </span><span class="s4">&quot;odd&quot;</span><span class="s1">)</span>

  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ndim(array)):</span>
    <span class="s3">if </span><span class="s1">array.shape[i] == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">_check_no_padding(pad_width[i]</span><span class="s3">, </span><span class="s1">mode)</span>
      <span class="s3">continue</span>

    <span class="s1">n = array.shape[i]</span>
    <span class="s1">offset = </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">(mode == </span><span class="s4">&quot;reflect&quot; </span><span class="s3">and </span><span class="s1">n &gt; </span><span class="s5">1</span><span class="s1">) </span><span class="s3">else </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">build_padding(array</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">, </span><span class="s1">before):</span>
      <span class="s3">if </span><span class="s1">before:</span>
        <span class="s1">edge = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=i)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">edge = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">axis=i)</span>

      <span class="s3">while </span><span class="s1">padding &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">curr_pad = _min(padding</span><span class="s3">, </span><span class="s1">n - offset)</span>
        <span class="s1">padding -= curr_pad</span>

        <span class="s3">if </span><span class="s1">before:</span>
          <span class="s1">start = offset</span>
          <span class="s1">stop = offset + curr_pad</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">start = -(curr_pad + offset)</span>
          <span class="s1">stop = </span><span class="s3">None if </span><span class="s1">(mode == </span><span class="s4">&quot;symmetric&quot; </span><span class="s3">or </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">) </span><span class="s3">else </span><span class="s1">-</span><span class="s5">1</span>

        <span class="s1">x = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">axis=i)</span>
        <span class="s1">x = flip(x</span><span class="s3">, </span><span class="s1">axis=i)</span>

        <span class="s3">if </span><span class="s1">reflect_type == </span><span class="s4">'odd'</span><span class="s1">:</span>
          <span class="s1">x = </span><span class="s5">2 </span><span class="s1">* edge - x</span>
          <span class="s3">if </span><span class="s1">n &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">before:</span>
              <span class="s1">edge = lax.slice_in_dim(x</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=i)</span>
            <span class="s3">else</span><span class="s1">:</span>
              <span class="s1">edge = lax.slice_in_dim(x</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">axis=i)</span>

        <span class="s3">if </span><span class="s1">before:</span>
          <span class="s1">array = lax.concatenate([x</span><span class="s3">, </span><span class="s1">array]</span><span class="s3">, </span><span class="s1">dimension=i)</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">array = lax.concatenate([array</span><span class="s3">, </span><span class="s1">x]</span><span class="s3">, </span><span class="s1">dimension=i)</span>
      <span class="s3">return </span><span class="s1">array</span>

    <span class="s1">array = build_padding(array</span><span class="s3">, </span><span class="s1">pad_width[i][</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">before=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">array = build_padding(array</span><span class="s3">, </span><span class="s1">pad_width[i][</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">before=</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_edge(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]) -&gt; Array:</span>
  <span class="s1">nd = ndim(array)</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd):</span>
    <span class="s3">if </span><span class="s1">array.shape[i] == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">_check_no_padding(pad_width[i]</span><span class="s3">, </span><span class="s4">&quot;edge&quot;</span><span class="s1">)</span>
      <span class="s3">continue</span>

    <span class="s1">n = array.shape[i]</span>
    <span class="s1">npad_before</span><span class="s3">, </span><span class="s1">npad_after = pad_width[i]</span>

    <span class="s1">edge_before = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=i)</span>
    <span class="s1">pad_before = repeat(edge_before</span><span class="s3">, </span><span class="s1">npad_before</span><span class="s3">, </span><span class="s1">axis=i)</span>

    <span class="s1">edge_after = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">n-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">axis=i)</span>
    <span class="s1">pad_after = repeat(edge_after</span><span class="s3">, </span><span class="s1">npad_after</span><span class="s3">, </span><span class="s1">axis=i)</span>

    <span class="s1">array = lax.concatenate([pad_before</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">pad_after]</span><span class="s3">, </span><span class="s1">dimension=i)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_linear_ramp(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]</span><span class="s3">,</span>
                     <span class="s1">end_values: PadValue[ArrayLike]) -&gt; Array:</span>
  <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">range(ndim(array)):</span>
    <span class="s1">edge_before = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s1">edge_after = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">axis=axis)</span>
    <span class="s1">ramp_before = linspace(</span>
        <span class="s1">start=end_values[axis][</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">stop=edge_before.squeeze(axis)</span><span class="s3">, </span><span class="s0"># Dimension is replaced by linspace</span>
        <span class="s1">num=pad_width[axis][</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">endpoint=</span><span class="s3">False,</span>
        <span class="s1">dtype=array.dtype</span><span class="s3">,</span>
        <span class="s1">axis=axis</span>
    <span class="s1">)</span>
    <span class="s1">ramp_before = lax_internal._convert_element_type(</span>
        <span class="s1">ramp_before</span><span class="s3">, </span><span class="s1">weak_type=dtypes.is_weakly_typed(array))</span>
    <span class="s1">ramp_after = linspace(</span>
        <span class="s1">start=end_values[axis][</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">stop=edge_after.squeeze(axis)</span><span class="s3">, </span><span class="s0"># Dimension is replaced by linspace</span>
        <span class="s1">num=pad_width[axis][</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">endpoint=</span><span class="s3">False,</span>
        <span class="s1">dtype=array.dtype</span><span class="s3">,</span>
        <span class="s1">axis=axis</span>
    <span class="s1">)</span>
    <span class="s1">ramp_after = lax_internal._convert_element_type(</span>
        <span class="s1">ramp_after</span><span class="s3">, </span><span class="s1">weak_type=dtypes.is_weakly_typed(array))</span>

    <span class="s0"># Reverse linear space in appropriate dimension</span>
    <span class="s1">ramp_after = flip(ramp_after</span><span class="s3">, </span><span class="s1">axis)</span>

    <span class="s1">array = lax.concatenate([ramp_before</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">ramp_after]</span><span class="s3">, </span><span class="s1">dimension=axis)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_stats(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]</span><span class="s3">, </span><span class="s1">stat_length: Optional[PadValue[int]]</span><span class="s3">,</span>
               <span class="s1">stat_func: PadStatFunc) -&gt; Array:</span>
  <span class="s1">nd = ndim(array)</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nd):</span>
    <span class="s3">if </span><span class="s1">stat_length </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">stat_before = stat_func(array</span><span class="s3">, </span><span class="s1">axis=i</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
      <span class="s1">stat_after = stat_before</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">array_length = array.shape[i]</span>
      <span class="s1">length_before</span><span class="s3">, </span><span class="s1">length_after = stat_length[i]</span>
      <span class="s3">if </span><span class="s1">length_before == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">length_after == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;stat_length of 0 yields no value for padding&quot;</span><span class="s1">)</span>

      <span class="s0"># Limit stat_length to length of array.</span>
      <span class="s1">length_before = _min(length_before</span><span class="s3">, </span><span class="s1">array_length)</span>
      <span class="s1">length_after = _min(length_after</span><span class="s3">, </span><span class="s1">array_length)</span>

      <span class="s1">slice_before = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length_before</span><span class="s3">, </span><span class="s1">axis=i)</span>
      <span class="s1">slice_after = lax.slice_in_dim(array</span><span class="s3">, </span><span class="s1">-length_after</span><span class="s3">, None, </span><span class="s1">axis=i)</span>
      <span class="s1">stat_before = stat_func(slice_before</span><span class="s3">, </span><span class="s1">axis=i</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>
      <span class="s1">stat_after = stat_func(slice_after</span><span class="s3">, </span><span class="s1">axis=i</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">np.issubdtype(array.dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
      <span class="s1">stat_before = round(stat_before)</span>
      <span class="s1">stat_after = round(stat_after)</span>

    <span class="s1">stat_before = lax_internal._convert_element_type(</span>
        <span class="s1">stat_before</span><span class="s3">, </span><span class="s1">array.dtype</span><span class="s3">, </span><span class="s1">dtypes.is_weakly_typed(array))</span>
    <span class="s1">stat_after = lax_internal._convert_element_type(</span>
        <span class="s1">stat_after</span><span class="s3">, </span><span class="s1">array.dtype</span><span class="s3">, </span><span class="s1">dtypes.is_weakly_typed(array))</span>

    <span class="s1">npad_before</span><span class="s3">, </span><span class="s1">npad_after = pad_width[i]</span>
    <span class="s1">pad_before = repeat(stat_before</span><span class="s3">, </span><span class="s1">npad_before</span><span class="s3">, </span><span class="s1">axis=i)</span>
    <span class="s1">pad_after = repeat(stat_after</span><span class="s3">, </span><span class="s1">npad_after</span><span class="s3">, </span><span class="s1">axis=i)</span>

    <span class="s1">array = lax.concatenate([pad_before</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">pad_after]</span><span class="s3">, </span><span class="s1">dimension=i)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_empty(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]) -&gt; Array:</span>
  <span class="s0"># Note: jax.numpy.empty = jax.numpy.zeros</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ndim(array)):</span>
    <span class="s1">shape_before = array.shape[:i] + (pad_width[i][</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1">) + array.shape[i + </span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">pad_before = empty_like(array</span><span class="s3">, </span><span class="s1">shape=shape_before)</span>

    <span class="s1">shape_after = array.shape[:i] + (pad_width[i][</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">) + array.shape[i + </span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">pad_after = empty_like(array</span><span class="s3">, </span><span class="s1">shape=shape_after)</span>
    <span class="s1">array = lax.concatenate([pad_before</span><span class="s3">, </span><span class="s1">array</span><span class="s3">, </span><span class="s1">pad_after]</span><span class="s3">, </span><span class="s1">dimension=i)</span>
  <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_pad_func(array: Array</span><span class="s3">, </span><span class="s1">pad_width: PadValue[int]</span><span class="s3">, </span><span class="s1">func: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Array:</span>
  <span class="s1">pad_width = _broadcast_to_pairs(pad_width</span><span class="s3">, </span><span class="s1">ndim(array)</span><span class="s3">, </span><span class="s4">&quot;pad_width&quot;</span><span class="s1">)</span>
  <span class="s1">padded = _pad_constant(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">asarray(</span><span class="s5">0</span><span class="s1">))</span>
  <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">range(ndim(padded)):</span>
    <span class="s1">padded = apply_along_axis(func</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">padded</span><span class="s3">, </span><span class="s1">pad_width[axis]</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">kwargs)</span>
  <span class="s3">return </span><span class="s1">padded</span>


<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_pad(array: ArrayLike</span><span class="s3">, </span><span class="s1">pad_width: PadValueLike[int]</span><span class="s3">,</span>
         <span class="s1">mode: Union[str</span><span class="s3">, </span><span class="s1">PadStatFunc]</span><span class="s3">,</span>
         <span class="s1">constant_values: ArrayLike</span><span class="s3">, </span><span class="s1">stat_length: PadValueLike[int]</span><span class="s3">,</span>
         <span class="s1">end_values: PadValueLike[ArrayLike]</span><span class="s3">, </span><span class="s1">reflect_type: str):</span>
  <span class="s1">array = asarray(array)</span>
  <span class="s1">nd = ndim(array)</span>

  <span class="s3">if </span><span class="s1">nd == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">array</span>

  <span class="s1">stat_funcs: Dict[str</span><span class="s3">, </span><span class="s1">PadStatFunc] = {</span>
    <span class="s4">&quot;maximum&quot;</span><span class="s1">: reductions.amax</span><span class="s3">, </span><span class="s4">&quot;minimum&quot;</span><span class="s1">: reductions.amin</span><span class="s3">, </span><span class="s4">&quot;mean&quot;</span><span class="s1">: reductions.mean</span><span class="s3">, </span><span class="s4">&quot;median&quot;</span><span class="s1">: reductions.median}</span>

  <span class="s1">pad_width = _broadcast_to_pairs(pad_width</span><span class="s3">, </span><span class="s1">nd</span><span class="s3">, </span><span class="s4">&quot;pad_width&quot;</span><span class="s1">)</span>
  <span class="s1">pad_width_arr = np.array(pad_width)</span>
  <span class="s3">if </span><span class="s1">pad_width_arr.shape != (nd</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Expected pad_width to have shape </span><span class="s3">{</span><span class="s1">(nd</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">}</span><span class="s4">; got </span><span class="s3">{</span><span class="s1">pad_width_arr.shape</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">np.any(pad_width_arr &lt; </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;index can't contain negative values&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">mode == </span><span class="s4">&quot;constant&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_pad_constant(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">asarray(constant_values))</span>

  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;wrap&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_pad_wrap(array</span><span class="s3">, </span><span class="s1">pad_width)</span>

  <span class="s3">elif </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;symmetric&quot;</span><span class="s3">, </span><span class="s4">&quot;reflect&quot;</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">_pad_symmetric_or_reflect(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">str(mode)</span><span class="s3">, </span><span class="s1">reflect_type)</span>

  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;edge&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_pad_edge(array</span><span class="s3">, </span><span class="s1">pad_width)</span>

  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;linear_ramp&quot;</span><span class="s1">:</span>
    <span class="s1">end_values = _broadcast_to_pairs(end_values</span><span class="s3">, </span><span class="s1">nd</span><span class="s3">, </span><span class="s4">&quot;end_values&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_pad_linear_ramp(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">end_values)</span>

  <span class="s3">elif </span><span class="s1">mode </span><span class="s3">in </span><span class="s1">stat_funcs:</span>
    <span class="s3">if </span><span class="s1">stat_length </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">stat_length = _broadcast_to_pairs(stat_length</span><span class="s3">, </span><span class="s1">nd</span><span class="s3">, </span><span class="s4">&quot;stat_length&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_pad_stats(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">stat_length</span><span class="s3">, </span><span class="s1">stat_funcs[str(mode)])</span>

  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;empty&quot;</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_pad_empty(array</span><span class="s3">, </span><span class="s1">pad_width)</span>

  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">assert False, </span><span class="s1">(</span><span class="s4">&quot;Should not be reached since pad already handled unsupported and&quot;</span>
                   <span class="s4">&quot;not implemented modes&quot;</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.pad</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Unlike numpy, JAX &quot;function&quot; mode's argument (which is another function) should return 
the modified array. This is because Jax arrays are immutable. 
(In numpy, &quot;function&quot; mode's argument should modify a rank 1 array in-place.) 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">pad(array: ArrayLike</span><span class="s3">, </span><span class="s1">pad_width: PadValueLike[int]</span><span class="s3">,</span>
        <span class="s1">mode: Union[str</span><span class="s3">, </span><span class="s1">Callable[...</span><span class="s3">, </span><span class="s1">Any]] = </span><span class="s4">&quot;constant&quot;</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;pad&quot;</span><span class="s3">, </span><span class="s1">array)</span>
  <span class="s1">pad_width = _broadcast_to_pairs(pad_width</span><span class="s3">, </span><span class="s1">ndim(array)</span><span class="s3">, </span><span class="s4">&quot;pad_width&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">pad_width </span><span class="s3">and not </span><span class="s1">_all(core.is_dim(p[</span><span class="s5">0</span><span class="s1">]) </span><span class="s3">and </span><span class="s1">core.is_dim(p[</span><span class="s5">1</span><span class="s1">])</span>
                            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">pad_width):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'`pad_width` must be of integral type.'</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">callable(mode):</span>
    <span class="s3">return </span><span class="s1">_pad_func(asarray(array)</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">**kwargs)</span>

  <span class="s1">allowed_kwargs = {</span>
      <span class="s4">'empty'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'edge'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'wrap'</span><span class="s1">: []</span><span class="s3">,</span>
      <span class="s4">'constant'</span><span class="s1">: [</span><span class="s4">'constant_values'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'linear_ramp'</span><span class="s1">: [</span><span class="s4">'end_values'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'maximum'</span><span class="s1">: [</span><span class="s4">'stat_length'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'mean'</span><span class="s1">: [</span><span class="s4">'stat_length'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'median'</span><span class="s1">: [</span><span class="s4">'stat_length'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'minimum'</span><span class="s1">: [</span><span class="s4">'stat_length'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'reflect'</span><span class="s1">: [</span><span class="s4">'reflect_type'</span><span class="s1">]</span><span class="s3">,</span>
      <span class="s4">'symmetric'</span><span class="s1">: [</span><span class="s4">'reflect_type'</span><span class="s1">]</span><span class="s3">,</span>
  <span class="s1">}</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">unsupported_kwargs = set(kwargs) - set(allowed_kwargs[mode])  </span><span class="s0"># type: ignore[call-overload]</span>
  <span class="s3">except </span><span class="s1">KeyError:</span>
    <span class="s1">msg = </span><span class="s4">&quot;Unimplemented padding mode '{}' for np.pad.&quot;</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(msg.format(mode))</span>
  <span class="s3">if </span><span class="s1">unsupported_kwargs:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unsupported keyword arguments for mode '{}': {}&quot;</span>
                     <span class="s1">.format(mode</span><span class="s3">, </span><span class="s1">unsupported_kwargs))</span>
  <span class="s0"># Set default value if not given.</span>
  <span class="s1">constant_values = kwargs.get(</span><span class="s4">'constant_values'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">stat_length = kwargs.get(</span><span class="s4">'stat_length'</span><span class="s3">, None</span><span class="s1">)</span>
  <span class="s1">end_values = kwargs.get(</span><span class="s4">'end_values'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">reflect_type = kwargs.get(</span><span class="s4">'reflect_type'</span><span class="s3">, </span><span class="s4">&quot;even&quot;</span><span class="s1">)</span>

  <span class="s3">return </span><span class="s1">_pad(array</span><span class="s3">, </span><span class="s1">pad_width</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">constant_values</span><span class="s3">, </span><span class="s1">stat_length</span><span class="s3">, </span><span class="s1">end_values</span><span class="s3">, </span><span class="s1">reflect_type)</span>

<span class="s0">### Array-creation functions</span>


<span class="s1">@util._wraps(np.stack</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">stack(arrays: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
          <span class="s1">axis: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if not </span><span class="s1">len(arrays):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Need at least one array to stack.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.stack is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">isinstance(arrays</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arrays.ndim)</span>
    <span class="s3">return </span><span class="s1">concatenate(expand_dims(arrays</span><span class="s3">, </span><span class="s1">axis + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">util._stackable(*arrays) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;stack&quot;</span><span class="s3">, </span><span class="s1">*arrays)</span>
    <span class="s1">shape0 = shape(arrays[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">len(shape0) + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">new_arrays = []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arrays:</span>
      <span class="s3">if </span><span class="s1">shape(a) != shape0:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All input arrays must have the same shape.&quot;</span><span class="s1">)</span>
      <span class="s1">new_arrays.append(expand_dims(a</span><span class="s3">, </span><span class="s1">axis))</span>
    <span class="s3">return </span><span class="s1">concatenate(new_arrays</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

<span class="s1">@util._wraps(np.tile)</span>
<span class="s3">def </span><span class="s1">tile(A: ArrayLike</span><span class="s3">, </span><span class="s1">reps: Union[DimSize</span><span class="s3">, </span><span class="s1">Sequence[DimSize]]) -&gt; Array:</span>
  <span class="s1">util._stackable(A) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;tile&quot;</span><span class="s3">, </span><span class="s1">A)</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">iter(reps)  </span><span class="s0"># type: ignore[arg-type]</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s1">reps_tup: Tuple[DimSize</span><span class="s3">, </span><span class="s1">...] = (reps</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">reps_tup = tuple(reps)  </span><span class="s0"># type: ignore[assignment,arg-type]</span>
  <span class="s1">reps_tup = tuple(operator.index(rep) </span><span class="s3">if </span><span class="s1">core.is_constant_dim(rep) </span><span class="s3">else </span><span class="s1">rep</span>
                   <span class="s3">for </span><span class="s1">rep </span><span class="s3">in </span><span class="s1">reps_tup)</span>
  <span class="s1">A_shape = (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) * (len(reps_tup) - ndim(A)) + shape(A)</span>
  <span class="s1">reps_tup = (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) * (len(A_shape) - len(reps_tup)) + reps_tup</span>
  <span class="s1">result = broadcast_to(reshape(A</span><span class="s3">, </span><span class="s1">[j </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">A_shape </span><span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s1">i]])</span><span class="s3">,</span>
                        <span class="s1">[k </span><span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">zip(reps_tup</span><span class="s3">, </span><span class="s1">A_shape) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">pair])</span>
  <span class="s3">return </span><span class="s1">reshape(result</span><span class="s3">, </span><span class="s1">tuple(np.multiply(A_shape</span><span class="s3">, </span><span class="s1">reps_tup)))</span>

<span class="s3">def </span><span class="s1">_concatenate_array(arr: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int]</span><span class="s3">,</span>
                       <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s0"># Fast path for concatenation when the input is an ndarray rather than a list.</span>
  <span class="s1">arr = asarray(arr</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s3">if </span><span class="s1">arr.ndim == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">arr.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Need at least one array to concatenate.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.reshape(arr</span><span class="s3">, </span><span class="s1">(arr.size</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s3">if </span><span class="s1">arr.ndim == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="s1">)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">shape = arr.shape[</span><span class="s5">1</span><span class="s1">:axis + </span><span class="s5">1</span><span class="s1">] + (arr.shape[</span><span class="s5">0</span><span class="s1">] * arr.shape[axis + </span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1">) + arr.shape[axis + </span><span class="s5">2</span><span class="s1">:]</span>
  <span class="s1">dimensions = [*range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis + </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">*range(axis + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">arr.ndim)]</span>
  <span class="s3">return </span><span class="s1">lax.reshape(arr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dimensions)</span>

<span class="s1">@util._wraps(np.concatenate)</span>
<span class="s3">def </span><span class="s1">concatenate(arrays: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
                <span class="s1">axis: Optional[int] = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(arrays</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s3">return </span><span class="s1">_concatenate_array(arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">util._stackable(*arrays) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;concatenate&quot;</span><span class="s3">, </span><span class="s1">*arrays)</span>
  <span class="s3">if not </span><span class="s1">len(arrays):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Need at least one array to concatenate.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ndim(arrays[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">concatenate([ravel(a) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arrays]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s3">if </span><span class="s1">hasattr(arrays[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;concatenate&quot;</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">arrays[</span><span class="s5">0</span><span class="s1">].concatenate(arrays[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype=dtype)  </span><span class="s0"># type: ignore[union-attr]</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">ndim(arrays[</span><span class="s5">0</span><span class="s1">]))</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">arrays_out = util.promote_dtypes(*arrays)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arrays_out = [asarray(arr</span><span class="s3">, </span><span class="s1">dtype=dtype) </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arrays]</span>
  <span class="s0"># lax.concatenate can be slow to compile for wide concatenations, so form a</span>
  <span class="s0"># tree of concatenations as a workaround especially for op-by-op mode.</span>
  <span class="s0"># (https://github.com/google/jax/issues/653).</span>
  <span class="s1">k = </span><span class="s5">16</span>
  <span class="s3">while </span><span class="s1">len(arrays_out) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">arrays_out = [lax.concatenate(arrays_out[i:i+k]</span><span class="s3">, </span><span class="s1">axis)</span>
                  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len(arrays_out)</span><span class="s3">, </span><span class="s1">k)]</span>
  <span class="s3">return </span><span class="s1">arrays_out[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s1">@util._wraps(np.vstack)</span>
<span class="s3">def </span><span class="s1">vstack(tup: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
           <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(tup</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s1">arrs = jax.vmap(atleast_2d)(tup)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arrs = [atleast_2d(m) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">tup]</span>
  <span class="s3">return </span><span class="s1">concatenate(arrs</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
<span class="s1">row_stack = vstack</span>


<span class="s1">@util._wraps(np.hstack)</span>
<span class="s3">def </span><span class="s1">hstack(tup: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
           <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(tup</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s1">arrs = jax.vmap(atleast_1d)(tup)</span>
    <span class="s1">arr0_ndim = arrs.ndim - </span><span class="s5">1</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arrs = [atleast_1d(m) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">tup]</span>
    <span class="s1">arr0_ndim = arrs[</span><span class="s5">0</span><span class="s1">].ndim</span>
  <span class="s3">return </span><span class="s1">concatenate(arrs</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0 </span><span class="s3">if </span><span class="s1">arr0_ndim == </span><span class="s5">1 </span><span class="s3">else </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@util._wraps(np.dstack)</span>
<span class="s3">def </span><span class="s1">dstack(tup: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
           <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(tup</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s1">arrs = jax.vmap(atleast_3d)(tup)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arrs = [atleast_3d(m) </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">tup]</span>
  <span class="s3">return </span><span class="s1">concatenate(arrs</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@util._wraps(np.column_stack)</span>
<span class="s3">def </span><span class="s1">column_stack(tup: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(tup</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)):</span>
    <span class="s1">arrs = jax.vmap(</span><span class="s3">lambda </span><span class="s1">x: atleast_2d(x).T)(tup) </span><span class="s3">if </span><span class="s1">tup.ndim &lt; </span><span class="s5">3 </span><span class="s3">else </span><span class="s1">tup</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arrs = [atleast_2d(arr).T </span><span class="s3">if </span><span class="s1">arr.ndim &lt; </span><span class="s5">2 </span><span class="s3">else </span><span class="s1">arr </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">map(asarray</span><span class="s3">, </span><span class="s1">tup)]</span>
  <span class="s3">return </span><span class="s1">concatenate(arrs</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.choose</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">choose(a: ArrayLike</span><span class="s3">, </span><span class="s1">choices: Sequence[ArrayLike]</span><span class="s3">,</span>
           <span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">mode: str = </span><span class="s4">'raise'</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.choose is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">'choose'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">*choices)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`a` array must be integer typed&quot;</span><span class="s1">)</span>
  <span class="s1">N = len(choices)</span>

  <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'raise'</span><span class="s1">:</span>
    <span class="s1">arr: Array = core.concrete_or_error(asarray</span><span class="s3">, </span><span class="s1">a</span><span class="s3">,</span>
      <span class="s4">&quot;The error occurred because jnp.choose was jit-compiled&quot;</span>
      <span class="s4">&quot; with mode='raise'. Use mode='wrap' or mode='clip' instead.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">reductions.any((arr &lt; </span><span class="s5">0</span><span class="s1">) | (arr &gt;= N)):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid entry in choice array&quot;</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'wrap'</span><span class="s1">:</span>
    <span class="s1">arr = asarray(a) % N</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">'clip'</span><span class="s1">:</span>
    <span class="s1">arr = clip(a</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">N - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;mode=</span><span class="s3">{</span><span class="s1">mode</span><span class="s3">!r} </span><span class="s4">not understood. Must be 'raise', 'wrap', or 'clip'&quot;</span><span class="s1">)</span>

  <span class="s1">arr</span><span class="s3">, </span><span class="s1">*choices = broadcast_arrays(arr</span><span class="s3">, </span><span class="s1">*choices)</span>
  <span class="s3">return </span><span class="s1">array(choices)[(arr</span><span class="s3">,</span><span class="s1">) + indices(arr.shape</span><span class="s3">, </span><span class="s1">sparse=</span><span class="s3">True</span><span class="s1">)]</span>


<span class="s3">def </span><span class="s1">_atleast_nd(x: ArrayLike</span><span class="s3">, </span><span class="s1">n: int) -&gt; Array:</span>
  <span class="s1">m = ndim(x)</span>
  <span class="s3">return </span><span class="s1">lax.broadcast(x</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">) * (n - m)) </span><span class="s3">if </span><span class="s1">m &lt; n </span><span class="s3">else </span><span class="s1">asarray(x)</span>

<span class="s3">def </span><span class="s1">_block(xs: Union[ArrayLike</span><span class="s3">, </span><span class="s1">List[ArrayLike]]) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">int]:</span>
  <span class="s3">if </span><span class="s1">isinstance(xs</span><span class="s3">, </span><span class="s1">tuple):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jax.numpy.block does not allow tuples, got {}&quot;</span>
                     <span class="s1">.format(xs))</span>
  <span class="s3">elif </span><span class="s1">isinstance(xs</span><span class="s3">, </span><span class="s1">list):</span>
    <span class="s3">if </span><span class="s1">len(xs) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jax.numpy.block does not allow empty list arguments&quot;</span><span class="s1">)</span>
    <span class="s1">xs_tup</span><span class="s3">, </span><span class="s1">depths = unzip2([_block(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs])</span>
    <span class="s3">if </span><span class="s1">_any(d != depths[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">depths[</span><span class="s5">1</span><span class="s1">:]):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Mismatched list depths in jax.numpy.block&quot;</span><span class="s1">)</span>
    <span class="s1">rank = _max(depths[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_max(ndim(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_tup))</span>
    <span class="s1">xs_tup = tuple(_atleast_nd(x</span><span class="s3">, </span><span class="s1">rank) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_tup)</span>
    <span class="s3">return </span><span class="s1">concatenate(xs_tup</span><span class="s3">, </span><span class="s1">axis=-depths[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">depths[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">asarray(xs)</span><span class="s3">, </span><span class="s5">1</span>

<span class="s1">@util._wraps(np.block)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">block(arrays: Union[ArrayLike</span><span class="s3">, </span><span class="s1">List[ArrayLike]]) -&gt; Array:</span>
  <span class="s1">out</span><span class="s3">, </span><span class="s1">_ = _block(arrays)</span>
  <span class="s3">return </span><span class="s1">out</span>

<span class="s1">@util._wraps(np.atleast_1d</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">atleast_1d(*arys: ArrayLike) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s3">if </span><span class="s1">len(arys) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">arr = asarray(arys[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">arr </span><span class="s3">if </span><span class="s1">ndim(arr) &gt;= </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">reshape(arr</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">[atleast_1d(arr) </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arys]</span>


<span class="s1">@util._wraps(np.atleast_2d</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">atleast_2d(*arys: ArrayLike) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s3">if </span><span class="s1">len(arys) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">arr = asarray(arys[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">ndim(arr) &gt;= </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">arr</span>
    <span class="s3">elif </span><span class="s1">ndim(arr) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">expand_dims(arr</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">expand_dims(arr</span><span class="s3">, </span><span class="s1">axis=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">[atleast_2d(arr) </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arys]</span>


<span class="s1">@util._wraps(np.atleast_3d</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">atleast_3d(*arys: ArrayLike) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">List[Array]]:</span>
  <span class="s3">if </span><span class="s1">len(arys) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">arr = asarray(arys[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">ndim(arr) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">arr = expand_dims(arr</span><span class="s3">, </span><span class="s1">axis=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">ndim(arr) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">arr = expand_dims(arr</span><span class="s3">, </span><span class="s1">axis=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">ndim(arr) == </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s1">arr = expand_dims(arr</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">arr</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">[atleast_3d(arr) </span><span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arys]</span>


<span class="s1">_ARRAY_DOC = </span><span class="s4">&quot;&quot;&quot; 
This function will create arrays on JAX's default device. For control of the 
device placement of data, see :func:`jax.device_put`. More information is 
available in the JAX FAQ at :ref:`faq-data-placement` (full FAQ at 
https://jax.readthedocs.io/en/latest/faq.html). 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.array</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_DOC)</span>
<span class="s3">def </span><span class="s1">array(object: Any</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">copy: bool = </span><span class="s3">True,</span>
          <span class="s1">order: Optional[str] = </span><span class="s4">&quot;K&quot;</span><span class="s3">, </span><span class="s1">ndmin: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">order </span><span class="s3">is not None and </span><span class="s1">order != </span><span class="s4">&quot;K&quot;</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Only implemented for order='K'&quot;</span><span class="s1">)</span>

  <span class="s0"># check if the given dtype is compatible with JAX</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;array&quot;</span><span class="s1">)</span>

  <span class="s0"># Here we make a judgment call: we only return a weakly-typed array when the</span>
  <span class="s0"># input object itself is weakly typed. That ensures asarray(x) is a no-op</span>
  <span class="s0"># whenever x is weak, but avoids introducing weak types with something like</span>
  <span class="s0"># array([1, 2, 3])</span>
  <span class="s1">weak_type = dtype </span><span class="s3">is None and </span><span class="s1">dtypes.is_weakly_typed(object)</span>

  <span class="s0"># For Python scalar literals, call coerce_to_array to catch any overflow</span>
  <span class="s0"># errors. We don't use dtypes.is_python_scalar because we don't want this</span>
  <span class="s0"># triggering for traced values. We do this here because it matters whether or</span>
  <span class="s0"># not dtype is None. We don't assign the result because we want the raw object</span>
  <span class="s0"># to be used for type inference below.</span>
  <span class="s3">if </span><span class="s1">isinstance(object</span><span class="s3">, </span><span class="s1">(bool</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">complex)):</span>
    <span class="s1">_ = dtypes.coerce_to_array(object</span><span class="s3">, </span><span class="s1">dtype)</span>

  <span class="s1">object = tree_map(</span><span class="s3">lambda </span><span class="s1">leaf: leaf.__jax_array__() </span><span class="s3">if </span><span class="s1">hasattr(leaf</span><span class="s3">, </span><span class="s4">&quot;__jax_array__&quot;</span><span class="s1">) </span><span class="s3">else </span><span class="s1">leaf</span><span class="s3">,</span>
                    <span class="s1">object)</span>
  <span class="s1">leaves = tree_leaves(object)</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s0"># Use lattice_result_type rather than result_type to avoid canonicalization.</span>
    <span class="s0"># Otherwise, weakly-typed inputs would have their dtypes canonicalized.</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">dtype = dtypes._lattice_result_type(*leaves)[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">leaves </span><span class="s3">else </span><span class="s1">dtypes.float_</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s0"># This happens if, e.g. one of the entries is a memoryview object.</span>
      <span class="s0"># This is rare, so we only handle it if the normal path fails.</span>
      <span class="s1">leaves = [_convert_to_array_if_dtype_fails(leaf) </span><span class="s3">for </span><span class="s1">leaf </span><span class="s3">in </span><span class="s1">leaves]</span>
      <span class="s1">dtype = dtypes._lattice_result_type(*leaves)[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s3">if not </span><span class="s1">weak_type:</span>
    <span class="s1">dtype = dtypes.canonicalize_dtype(dtype)</span>

  <span class="s0"># We can't use the ndarray class because we need to handle internal buffers</span>
  <span class="s0"># (See https://github.com/google/jax/issues/8950)</span>
  <span class="s1">ndarray_types = (device_array.DeviceArray</span><span class="s3">, </span><span class="s1">core.Tracer</span><span class="s3">, </span><span class="s1">ArrayImpl)</span>

  <span class="s1">out: ArrayLike</span>

  <span class="s3">if </span><span class="s1">_all(</span><span class="s3">not </span><span class="s1">isinstance(leaf</span><span class="s3">, </span><span class="s1">ndarray_types) </span><span class="s3">for </span><span class="s1">leaf </span><span class="s3">in </span><span class="s1">leaves):</span>
    <span class="s0"># TODO(jakevdp): falling back to numpy here fails to overflow for lists</span>
    <span class="s0"># containing large integers; see discussion in</span>
    <span class="s0"># https://github.com/google/jax/pull/6047. More correct would be to call</span>
    <span class="s0"># coerce_to_array on each leaf, but this may have performance implications.</span>
    <span class="s1">out = np.array(object</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">ndmin=ndmin</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">isinstance(object</span><span class="s3">, </span><span class="s1">ndarray_types):</span>
    <span class="s0"># TODO(phawkins): remove the type: ignore here after DeviceArray has been deleted.</span>
    <span class="s3">assert </span><span class="s1">object.aval </span><span class="s3">is not None  </span><span class="s0"># type: ignore</span>
    <span class="s1">out = _array_copy(object) </span><span class="s3">if </span><span class="s1">copy </span><span class="s3">else </span><span class="s1">object  </span><span class="s0"># type: ignore</span>
  <span class="s3">elif </span><span class="s1">isinstance(object</span><span class="s3">, </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple)):</span>
    <span class="s3">if </span><span class="s1">object:</span>
      <span class="s1">out = stack([asarray(elt</span><span class="s3">, </span><span class="s1">dtype=dtype) </span><span class="s3">for </span><span class="s1">elt </span><span class="s3">in </span><span class="s1">object])</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">out = np.array([]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">view = memoryview(object)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s3">pass  </span><span class="s0"># `object` does not support the buffer interface.</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">array(np.asarray(view)</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">, </span><span class="s1">ndmin=ndmin)</span>

    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Unexpected input type for array: </span><span class="s3">{</span><span class="s1">type(object)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s1">out_array: Array = lax_internal._convert_element_type(out</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">weak_type=weak_type)</span>
  <span class="s3">if </span><span class="s1">ndmin &gt; ndim(out_array):</span>
    <span class="s1">out_array = lax.expand_dims(out_array</span><span class="s3">, </span><span class="s1">range(ndmin - ndim(out_array)))</span>
  <span class="s3">return </span><span class="s1">out_array</span>


<span class="s3">def </span><span class="s1">_convert_to_array_if_dtype_fails(x: ArrayLike) -&gt; ArrayLike:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">dtypes.dtype(x)</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s3">return </span><span class="s1">np.asarray(x)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">x</span>


<span class="s1">@util._wraps(np.asarray</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_DOC)</span>
<span class="s3">def </span><span class="s1">asarray(a: Any</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">order: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;asarray&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(dtype) </span><span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None else </span><span class="s1">dtype</span>
  <span class="s3">return </span><span class="s1">array(a</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">order=order)  </span><span class="s0"># type: ignore</span>


<span class="s1">@util._wraps(np.copy</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_DOC)</span>
<span class="s3">def </span><span class="s1">copy(a: ArrayLike</span><span class="s3">, </span><span class="s1">order: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;copy&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">return </span><span class="s1">array(a</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True, </span><span class="s1">order=order)</span>


<span class="s1">@util._wraps(np.zeros_like)</span>
<span class="s3">def </span><span class="s1">zeros_like(a: ArrayLike</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
               <span class="s1">shape: Any = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;zeros_like&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;zeros_like&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">shape = canonicalize_shape(shape)</span>
  <span class="s3">return </span><span class="s1">lax.full_like(a</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape)</span>


<span class="s1">@util._wraps(np.ones_like)</span>
<span class="s3">def </span><span class="s1">ones_like(a: ArrayLike</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
              <span class="s1">shape: Any = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ones_like&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;ones_like&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">shape = canonicalize_shape(shape)</span>
  <span class="s3">return </span><span class="s1">lax.full_like(a</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape)</span>


<span class="s1">@util._wraps(np.empty_like</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Because XLA cannot create uninitialized arrays, the JAX version will 
return an array initialized with zeros.&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">empty_like(prototype: ArrayLike</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
               <span class="s1">shape: Any = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;empty_like&quot;</span><span class="s3">, </span><span class="s1">prototype)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;empty_like&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">zeros_like(prototype</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shape=shape)</span>


<span class="s1">@util._wraps(np.full)</span>
<span class="s3">def </span><span class="s1">full(shape: Any</span><span class="s3">, </span><span class="s1">fill_value: ArrayLike</span><span class="s3">,</span>
         <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;full&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;full&quot;</span><span class="s3">, </span><span class="s1">fill_value)</span>
  <span class="s3">if </span><span class="s1">ndim(fill_value) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">shape = canonicalize_shape(shape)</span>
    <span class="s3">return </span><span class="s1">lax.full(shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">broadcast_to(asarray(fill_value</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">shape)</span>


<span class="s1">@util._wraps(np.full_like)</span>
<span class="s3">def </span><span class="s1">full_like(a: ArrayLike</span><span class="s3">, </span><span class="s1">fill_value: ArrayLike</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
              <span class="s1">shape: Any = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;full_like&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;full_like&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">fill_value)</span>
  <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">shape = canonicalize_shape(shape)</span>
  <span class="s3">if </span><span class="s1">ndim(fill_value) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.full_like(a</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">shape)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">shape = np.shape(a) </span><span class="s3">if </span><span class="s1">shape </span><span class="s3">is None else </span><span class="s1">shape</span>
    <span class="s1">dtype = result_type(a) </span><span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None else </span><span class="s1">dtype</span>
    <span class="s3">return </span><span class="s1">broadcast_to(asarray(fill_value</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">shape)</span>


<span class="s1">@util._wraps(np.zeros)</span>
<span class="s3">def </span><span class="s1">zeros(shape: Any</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(shape</span><span class="s3">, </span><span class="s1">types.GeneratorType):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="s1">)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;zeros&quot;</span><span class="s1">)</span>
  <span class="s1">shape = canonicalize_shape(shape)</span>
  <span class="s3">return </span><span class="s1">lax.full(shape</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">_jnp_dtype(dtype))</span>

<span class="s1">@util._wraps(np.ones)</span>
<span class="s3">def </span><span class="s1">ones(shape: Any</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">isinstance(shape</span><span class="s3">, </span><span class="s1">types.GeneratorType):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="s1">)</span>
  <span class="s1">shape = canonicalize_shape(shape)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;ones&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">lax.full(shape</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">_jnp_dtype(dtype))</span>


<span class="s1">@util._wraps(np.empty</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Because XLA cannot create uninitialized arrays, the JAX version will 
return an array initialized with zeros.&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">empty(shape: Any</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;empty&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">zeros(shape</span><span class="s3">, </span><span class="s1">dtype)</span>


<span class="s1">@util._wraps(np.array_equal)</span>
<span class="s3">def </span><span class="s1">array_equal(a1: ArrayLike</span><span class="s3">, </span><span class="s1">a2: ArrayLike</span><span class="s3">, </span><span class="s1">equal_nan: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">a1</span><span class="s3">, </span><span class="s1">a2 = asarray(a1)</span><span class="s3">, </span><span class="s1">asarray(a2)</span>
  <span class="s3">except </span><span class="s1">Exception:</span>
    <span class="s3">return </span><span class="s1">bool_(</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">shape(a1) != shape(a2):</span>
    <span class="s3">return </span><span class="s1">bool_(</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s1">eq = asarray(a1 == a2)</span>
  <span class="s3">if </span><span class="s1">equal_nan:</span>
    <span class="s1">eq = ufuncs.logical_or(eq</span><span class="s3">, </span><span class="s1">ufuncs.logical_and(ufuncs.isnan(a1)</span><span class="s3">, </span><span class="s1">ufuncs.isnan(a2)))</span>
  <span class="s3">return </span><span class="s1">reductions.all(eq)</span>


<span class="s1">@util._wraps(np.array_equiv)</span>
<span class="s3">def </span><span class="s1">array_equiv(a1: ArrayLike</span><span class="s3">, </span><span class="s1">a2: ArrayLike) -&gt; Array:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">a1</span><span class="s3">, </span><span class="s1">a2 = asarray(a1)</span><span class="s3">, </span><span class="s1">asarray(a2)</span>
  <span class="s3">except </span><span class="s1">Exception:</span>
    <span class="s3">return </span><span class="s1">bool_(</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">eq = ufuncs.equal(a1</span><span class="s3">, </span><span class="s1">a2)</span>
  <span class="s3">except </span><span class="s1">ValueError:</span>
    <span class="s0"># shapes are not broadcastable</span>
    <span class="s3">return </span><span class="s1">bool_(</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">reductions.all(eq)</span>


<span class="s0"># General np.from* style functions mostly delegate to numpy.</span>

<span class="s1">@util._wraps(np.frombuffer)</span>
<span class="s3">def </span><span class="s1">frombuffer(buffer: Union[bytes</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = float</span><span class="s3">,</span>
               <span class="s1">count: int = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">offset: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">asarray(np.frombuffer(buffer=buffer</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">count=count</span><span class="s3">, </span><span class="s1">offset=offset))</span>


<span class="s3">def </span><span class="s1">fromfile(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromfile. 
 
  This function is left deliberately unimplemented because it may be non-pure and thus 
  unsafe for use with JIT and other JAX transformations. Consider using 
  ``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile`` 
  is used within jax transformations because of its potential side-effect of consuming the 
  file object; for more information see `Common Gotchas: Pure Functions 
  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_. 
  &quot;&quot;&quot;</span>
  <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
    <span class="s4">&quot;jnp.fromfile() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s4">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromfile(...)) &quot;</span>
    <span class="s4">&quot;instead, although care should be taken if np.fromfile is used within a jax transformations &quot;</span>
    <span class="s4">&quot;because of its potential side-effect of consuming the file object; for more information see &quot;</span>
    <span class="s4">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">fromiter(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromiter. 
 
  This function is left deliberately unimplemented because it may be non-pure and thus 
  unsafe for use with JIT and other JAX transformations. Consider using 
  ``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter`` 
  is used within jax transformations because of its potential side-effect of consuming the 
  iterable object; for more information see `Common Gotchas: Pure Functions 
  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_. 
  &quot;&quot;&quot;</span>
  <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
    <span class="s4">&quot;jnp.fromiter() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s4">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromiter(...)) &quot;</span>
    <span class="s4">&quot;instead, although care should be taken if np.fromiter is used within a jax transformations &quot;</span>
    <span class="s4">&quot;because of its potential side-effect of consuming the iterable object; for more information see &quot;</span>
    <span class="s4">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="s1">)</span>

<span class="s1">@util._wraps(getattr(np</span><span class="s3">, </span><span class="s4">&quot;from_dlpack&quot;</span><span class="s3">, None</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">from_dlpack(x: Any) -&gt; Array:</span>
  <span class="s3">from </span><span class="s1">jax.dlpack </span><span class="s3">import </span><span class="s1">from_dlpack  </span><span class="s0"># pylint: disable=g-import-not-at-top</span>
  <span class="s3">return </span><span class="s1">from_dlpack(x.__dlpack__())</span>

<span class="s1">@util._wraps(np.fromfunction)</span>
<span class="s3">def </span><span class="s1">fromfunction(function: Callable[...</span><span class="s3">, </span><span class="s1">Array]</span><span class="s3">, </span><span class="s1">shape: Any</span><span class="s3">,</span>
                 <span class="s1">*</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = float</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Array:</span>
  <span class="s1">shape = core.canonicalize_shape(shape</span><span class="s3">, </span><span class="s1">context=</span><span class="s4">&quot;shape argument of jnp.fromfunction()&quot;</span><span class="s1">)</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(shape)):</span>
    <span class="s1">in_axes = [</span><span class="s5">0 </span><span class="s3">if </span><span class="s1">i == j </span><span class="s3">else None for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range(len(shape))]</span>
    <span class="s1">function = jax.vmap(function</span><span class="s3">, </span><span class="s1">in_axes=tuple(in_axes[::-</span><span class="s5">1</span><span class="s1">]))</span>
  <span class="s3">return </span><span class="s1">function(*(arange(s</span><span class="s3">, </span><span class="s1">dtype=dtype) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">shape)</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s1">@util._wraps(np.fromstring)</span>
<span class="s3">def </span><span class="s1">fromstring(string: str</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = float</span><span class="s3">, </span><span class="s1">count: int = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">sep: str) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">asarray(np.fromstring(string=string</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">count=count</span><span class="s3">, </span><span class="s1">sep=sep))</span>


<span class="s1">@util._wraps(np.eye)</span>
<span class="s3">def </span><span class="s1">eye(N: DimSize</span><span class="s3">, </span><span class="s1">M: Optional[DimSize] = </span><span class="s3">None, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;eye&quot;</span><span class="s1">)</span>
  <span class="s1">N_int = core.canonicalize_dim(N</span><span class="s3">, </span><span class="s4">&quot;'N' argument of jnp.eye()&quot;</span><span class="s1">)</span>
  <span class="s1">M_int = N_int </span><span class="s3">if </span><span class="s1">M </span><span class="s3">is None else </span><span class="s1">core.canonicalize_dim(M</span><span class="s3">, </span><span class="s4">&quot;'M' argument of jnp.eye()&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">N_int &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">M_int &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;negative dimensions are not allowed, got </span><span class="s3">{</span><span class="s1">N</span><span class="s3">} </span><span class="s4">and </span><span class="s3">{</span><span class="s1">M</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">k = operator.index(k)</span>
  <span class="s3">return </span><span class="s1">lax_internal._eye(_jnp_dtype(dtype)</span><span class="s3">, </span><span class="s1">(N_int</span><span class="s3">, </span><span class="s1">M_int)</span><span class="s3">, </span><span class="s1">k)</span>


<span class="s1">@util._wraps(np.identity)</span>
<span class="s3">def </span><span class="s1">identity(n: DimSize</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;identity&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">eye(n</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@util._wraps(np.arange)</span>
<span class="s3">def </span><span class="s1">arange(start: DimSize</span><span class="s3">, </span><span class="s1">stop: Optional[DimSize] = </span><span class="s3">None,</span>
           <span class="s1">step: Optional[DimSize] = </span><span class="s3">None, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;arange&quot;</span><span class="s1">)</span>
  <span class="s3">if not </span><span class="s1">jax.config.jax_dynamic_shapes:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;arange&quot;</span><span class="s3">, </span><span class="s1">start)</span>
    <span class="s3">if </span><span class="s1">stop </span><span class="s3">is None and </span><span class="s1">step </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">start = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">start</span><span class="s3">, </span><span class="s4">&quot;It arose in the jnp.arange argument 'stop'&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">start = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">start</span><span class="s3">, </span><span class="s4">&quot;It arose in the jnp.arange argument 'start'&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike_or_none(</span><span class="s4">&quot;arange&quot;</span><span class="s3">, None, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)</span>
  <span class="s1">stop = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">stop</span><span class="s3">, </span><span class="s4">&quot;It arose in the jnp.arange argument 'stop'&quot;</span><span class="s1">)</span>
  <span class="s1">step = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">step</span><span class="s3">, </span><span class="s4">&quot;It arose in the jnp.arange argument 'step'&quot;</span><span class="s1">)</span>
  <span class="s1">start_name = </span><span class="s4">&quot;stop&quot; </span><span class="s3">if </span><span class="s1">stop </span><span class="s3">is None and </span><span class="s1">step </span><span class="s3">is None else </span><span class="s4">&quot;start&quot;</span>
  <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">[(start_name</span><span class="s3">, </span><span class="s1">start)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">&quot;stop&quot;</span><span class="s3">, </span><span class="s1">stop)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">&quot;step&quot;</span><span class="s3">, </span><span class="s1">step)]:</span>
    <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None and </span><span class="s1">np.ndim(val) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;jax.numpy.arange: arguments must be scalars; got </span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s4">=</span><span class="s3">{</span><span class="s1">val</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">_any(core.is_special_dim_size(d) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)):</span>
    <span class="s3">if </span><span class="s1">stop </span><span class="s3">is not None or </span><span class="s1">step </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s4">&quot;jax.numpy.arange supports non-constant arguments only in &quot;</span>
          <span class="s4">&quot;single-argument form. Found &quot;</span>
          <span class="s4">f&quot;jax.numpy.arange(</span><span class="s3">{</span><span class="s1">start=</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">stop=</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">step=</span><span class="s3">}</span><span class="s4">)&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">lax.iota(dtype </span><span class="s3">or </span><span class="s1">int_</span><span class="s3">, </span><span class="s1">start)</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dtype = result_type(start</span><span class="s3">, </span><span class="s1">*(x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">[stop</span><span class="s3">, </span><span class="s1">step] </span><span class="s3">if </span><span class="s1">x </span><span class="s3">is not None</span><span class="s1">))</span>
  <span class="s1">dtype = _jnp_dtype(dtype)</span>
  <span class="s3">if </span><span class="s1">stop </span><span class="s3">is None and </span><span class="s1">step </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">start_dtype = _dtype(start)</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">dtypes.issubdtype(start_dtype</span><span class="s3">, </span><span class="s1">np.integer) </span><span class="s3">and</span>
        <span class="s3">not </span><span class="s1">core.is_opaque_dtype(start_dtype)):</span>
      <span class="s1">ceil_ = ufuncs.ceil </span><span class="s3">if </span><span class="s1">isinstance(start</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">else </span><span class="s1">np.ceil</span>
      <span class="s1">start = ceil_(start).astype(int)  </span><span class="s0"># type: ignore</span>
    <span class="s3">return </span><span class="s1">lax.iota(dtype</span><span class="s3">, </span><span class="s1">start)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">step </span><span class="s3">is None and </span><span class="s1">start == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">stop </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">stop = np.ceil(stop).astype(int)</span>
      <span class="s3">return </span><span class="s1">lax.iota(dtype</span><span class="s3">, </span><span class="s1">stop)</span>
    <span class="s3">return </span><span class="s1">array(np.arange(start</span><span class="s3">, </span><span class="s1">stop=stop</span><span class="s3">, </span><span class="s1">step=step</span><span class="s3">, </span><span class="s1">dtype=dtype))</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
             <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">retstep: Literal[</span><span class="s3">False</span><span class="s1">] = </span><span class="s3">False,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
             <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int</span><span class="s3">,</span>
             <span class="s1">endpoint: bool</span><span class="s3">, </span><span class="s1">retstep: Literal[</span><span class="s3">True</span><span class="s1">]</span><span class="s3">,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
             <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
             <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">retstep: Literal[</span><span class="s3">True</span><span class="s1">]</span><span class="s3">,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
             <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
             <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">retstep: bool = </span><span class="s3">False,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
             <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">Array]]: ...</span>
<span class="s1">@util._wraps(np.linspace)</span>
<span class="s3">def </span><span class="s1">linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
             <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">retstep: bool = </span><span class="s3">False,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
             <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">Array]]:</span>
  <span class="s1">num = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s4">&quot;'num' argument of jnp.linspace&quot;</span><span class="s1">)</span>
  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;'axis' argument of jnp.linspace&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_linspace(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">retstep</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">axis)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'num'</span><span class="s3">, </span><span class="s4">'endpoint'</span><span class="s3">, </span><span class="s4">'retstep'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_linspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
              <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">retstep: bool = </span><span class="s3">False,</span>
              <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
              <span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">Array]]:</span>
  <span class="s2">&quot;&quot;&quot;Implementation of linspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;linspace&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">num &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Number of samples, </span><span class="s3">{</span><span class="s1">num</span><span class="s3">}</span><span class="s4">, must be non-negative.&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;linspace&quot;</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop)</span>

  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dtype = dtypes.to_inexact_dtype(result_type(start</span><span class="s3">, </span><span class="s1">stop))</span>
  <span class="s1">dtype = _jnp_dtype(dtype)</span>
  <span class="s1">computation_dtype = dtypes.to_inexact_dtype(dtype)</span>
  <span class="s1">start = asarray(start</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
  <span class="s1">stop = asarray(stop</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>

  <span class="s1">bounds_shape = list(lax.broadcast_shapes(shape(start)</span><span class="s3">, </span><span class="s1">shape(stop)))</span>
  <span class="s1">broadcast_start = broadcast_to(start</span><span class="s3">, </span><span class="s1">bounds_shape)</span>
  <span class="s1">broadcast_stop = broadcast_to(stop</span><span class="s3">, </span><span class="s1">bounds_shape)</span>
  <span class="s1">axis = len(bounds_shape) + axis + </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">axis &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">axis</span>
  <span class="s1">bounds_shape.insert(axis</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">div = (num - </span><span class="s5">1</span><span class="s1">) </span><span class="s3">if </span><span class="s1">endpoint </span><span class="s3">else </span><span class="s1">num</span>
  <span class="s3">if </span><span class="s1">num &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">delta: Array = lax.convert_element_type(stop - start</span><span class="s3">, </span><span class="s1">computation_dtype) / div</span>
    <span class="s1">iota_shape = [</span><span class="s5">1</span><span class="s3">,</span><span class="s1">] * len(bounds_shape)</span>
    <span class="s1">iota_shape[axis] = div</span>
    <span class="s0"># This approach recovers the endpoints with float32 arithmetic,</span>
    <span class="s0"># but can lead to rounding errors for integer outputs.</span>
    <span class="s1">real_dtype = finfo(computation_dtype).dtype</span>
    <span class="s1">step = reshape(lax.iota(real_dtype</span><span class="s3">, </span><span class="s1">div)</span><span class="s3">, </span><span class="s1">iota_shape) / div</span>
    <span class="s1">step = step.astype(computation_dtype)</span>
    <span class="s1">out = (reshape(broadcast_start</span><span class="s3">, </span><span class="s1">bounds_shape) * (</span><span class="s5">1 </span><span class="s1">- step) +</span>
      <span class="s1">reshape(broadcast_stop</span><span class="s3">, </span><span class="s1">bounds_shape) * step)</span>

    <span class="s3">if </span><span class="s1">endpoint:</span>
      <span class="s1">out = lax.concatenate([out</span><span class="s3">, </span><span class="s1">lax.expand_dims(broadcast_stop</span><span class="s3">, </span><span class="s1">(axis</span><span class="s3">,</span><span class="s1">))]</span><span class="s3">,</span>
                            <span class="s1">_canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">out.ndim))</span>

  <span class="s3">elif </span><span class="s1">num == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">delta = asarray(nan </span><span class="s3">if </span><span class="s1">endpoint </span><span class="s3">else </span><span class="s1">stop - start</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
    <span class="s1">out = reshape(broadcast_start</span><span class="s3">, </span><span class="s1">bounds_shape)</span>
  <span class="s3">else</span><span class="s1">: </span><span class="s0"># num == 0 degenerate case, match numpy behavior</span>
    <span class="s1">empty_shape = list(lax.broadcast_shapes(shape(start)</span><span class="s3">, </span><span class="s1">shape(stop)))</span>
    <span class="s1">empty_shape.insert(axis</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">delta = asarray(nan</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
    <span class="s1">out = reshape(array([]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">empty_shape)</span>

  <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">integer) </span><span class="s3">and not </span><span class="s1">issubdtype(out.dtype</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s1">out = lax.floor(out)</span>

  <span class="s3">if </span><span class="s1">retstep:</span>
    <span class="s3">return </span><span class="s1">lax.convert_element_type(out</span><span class="s3">, </span><span class="s1">dtype)</span><span class="s3">, </span><span class="s1">delta</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.convert_element_type(out</span><span class="s3">, </span><span class="s1">dtype)</span>


<span class="s1">@util._wraps(np.logspace)</span>
<span class="s3">def </span><span class="s1">logspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
             <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">base: ArrayLike = </span><span class="s5">10.0</span><span class="s3">,</span>
             <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">num = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s4">&quot;'num' argument of jnp.logspace&quot;</span><span class="s1">)</span>
  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;'axis' argument of jnp.logspace&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_logspace(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">axis)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'num'</span><span class="s3">, </span><span class="s4">'endpoint'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_logspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">,</span>
              <span class="s1">endpoint: bool = </span><span class="s3">True, </span><span class="s1">base: ArrayLike = </span><span class="s5">10.0</span><span class="s3">,</span>
              <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s2">&quot;&quot;&quot;Implementation of logspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;logspace&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dtype = dtypes.to_inexact_dtype(result_type(start</span><span class="s3">, </span><span class="s1">stop))</span>
  <span class="s1">dtype = _jnp_dtype(dtype)</span>
  <span class="s1">computation_dtype = dtypes.to_inexact_dtype(dtype)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;logspace&quot;</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop)</span>
  <span class="s1">start = asarray(start</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
  <span class="s1">stop = asarray(stop</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
  <span class="s1">lin = linspace(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">,</span>
                 <span class="s1">endpoint=endpoint</span><span class="s3">, </span><span class="s1">retstep=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">axis=axis)</span>
  <span class="s3">return </span><span class="s1">lax.convert_element_type(ufuncs.power(base</span><span class="s3">, </span><span class="s1">lin)</span><span class="s3">, </span><span class="s1">dtype)</span>


<span class="s1">@util._wraps(np.geomspace)</span>
<span class="s3">def </span><span class="s1">geomspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">, </span><span class="s1">endpoint: bool = </span><span class="s3">True,</span>
              <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">num = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s4">&quot;'num' argument of jnp.geomspace&quot;</span><span class="s1">)</span>
  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;'axis' argument of jnp.geomspace&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_geomspace(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">axis)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'num'</span><span class="s3">, </span><span class="s4">'endpoint'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_geomspace(start: ArrayLike</span><span class="s3">, </span><span class="s1">stop: ArrayLike</span><span class="s3">, </span><span class="s1">num: int = </span><span class="s5">50</span><span class="s3">, </span><span class="s1">endpoint: bool = </span><span class="s3">True,</span>
               <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">axis: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s2">&quot;&quot;&quot;Implementation of geomspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;geomspace&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dtype = dtypes.to_inexact_dtype(result_type(start</span><span class="s3">, </span><span class="s1">stop))</span>
  <span class="s1">dtype = _jnp_dtype(dtype)</span>
  <span class="s1">computation_dtype = dtypes.to_inexact_dtype(dtype)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;geomspace&quot;</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop)</span>
  <span class="s1">start = asarray(start</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
  <span class="s1">stop = asarray(stop</span><span class="s3">, </span><span class="s1">dtype=computation_dtype)</span>
  <span class="s0"># follow the numpy geomspace convention for negative and complex endpoints</span>
  <span class="s1">signflip = </span><span class="s5">1 </span><span class="s1">- (</span><span class="s5">1 </span><span class="s1">- ufuncs.sign(ufuncs.real(start))) * (</span><span class="s5">1 </span><span class="s1">- ufuncs.sign(ufuncs.real(stop))) // </span><span class="s5">2</span>
  <span class="s1">signflip = signflip.astype(computation_dtype)</span>
  <span class="s1">res = signflip * logspace(ufuncs.log10(signflip * start)</span><span class="s3">,</span>
                            <span class="s1">ufuncs.log10(signflip * stop)</span><span class="s3">, </span><span class="s1">num</span><span class="s3">,</span>
                            <span class="s1">endpoint=endpoint</span><span class="s3">, </span><span class="s1">base=</span><span class="s5">10.0</span><span class="s3">,</span>
                            <span class="s1">dtype=computation_dtype</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">axis != </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">res = moveaxis(res</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis)</span>
  <span class="s3">return </span><span class="s1">lax.convert_element_type(res</span><span class="s3">, </span><span class="s1">dtype)</span>


<span class="s1">@util._wraps(np.meshgrid</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">meshgrid(*xi: ArrayLike</span><span class="s3">, </span><span class="s1">copy: bool = </span><span class="s3">True, </span><span class="s1">sparse: bool = </span><span class="s3">False,</span>
             <span class="s1">indexing: str = </span><span class="s4">'xy'</span><span class="s1">) -&gt; List[Array]:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;meshgrid&quot;</span><span class="s3">, </span><span class="s1">*xi)</span>
  <span class="s1">args = [asarray(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xi]</span>
  <span class="s3">if not </span><span class="s1">copy:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jax.numpy.meshgrid only supports copy=True&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">indexing </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;xy&quot;</span><span class="s3">, </span><span class="s4">&quot;ij&quot;</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Valid values for indexing are 'xy' and 'ij', got </span><span class="s3">{</span><span class="s1">indexing</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">_any(a.ndim != </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Arguments to jax.numpy.meshgrid must be 1D, got shapes &quot;</span>
                     <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">[a.shape </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args]</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">indexing == </span><span class="s4">&quot;xy&quot; </span><span class="s3">and </span><span class="s1">len(args) &gt;= </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">] = args[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">shape = [</span><span class="s5">1 </span><span class="s3">if </span><span class="s1">sparse </span><span class="s3">else </span><span class="s1">a.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args]</span>
  <span class="s1">_a_shape = </span><span class="s3">lambda </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a: [*shape[:i]</span><span class="s3">, </span><span class="s1">a.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">*shape[i + </span><span class="s5">1</span><span class="s1">:]] </span><span class="s3">if </span><span class="s1">sparse </span><span class="s3">else </span><span class="s1">shape</span>
  <span class="s1">output = [lax.broadcast_in_dim(a</span><span class="s3">, </span><span class="s1">_a_shape(i</span><span class="s3">, </span><span class="s1">a)</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">,</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, in </span><span class="s1">enumerate(args)]</span>
  <span class="s3">if </span><span class="s1">indexing == </span><span class="s4">&quot;xy&quot; </span><span class="s3">and </span><span class="s1">len(args) &gt;= </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s1">output[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">output[</span><span class="s5">1</span><span class="s1">] = output[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">output[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s3">return </span><span class="s1">output</span>


<span class="s1">@util._wraps(np.i0)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">i0(x: ArrayLike) -&gt; Array:</span>
  <span class="s1">x_arr</span><span class="s3">, </span><span class="s1">= util.promote_args_inexact(</span><span class="s4">&quot;i0&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(x_arr.dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unsupported input type to jax.numpy.i0: </span><span class="s3">{</span><span class="s1">_dtype(x)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">x_arr = lax.abs(x_arr)</span>
  <span class="s3">return </span><span class="s1">lax.mul(lax.exp(x_arr)</span><span class="s3">, </span><span class="s1">lax.bessel_i0e(x_arr))</span>


<span class="s1">@util._wraps(np.ix_)</span>
<span class="s3">def </span><span class="s1">ix_(*args: ArrayLike) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">...]:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;ix&quot;</span><span class="s3">, </span><span class="s1">*args)</span>
  <span class="s1">n = len(args)</span>
  <span class="s1">output = []</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a </span><span class="s3">in </span><span class="s1">enumerate(args):</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s3">if </span><span class="s1">len(a.shape) != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">msg = </span><span class="s4">&quot;Arguments to jax.numpy.ix_ must be 1-dimensional, got shape {}&quot;</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(a.shape))</span>
    <span class="s3">if </span><span class="s1">_dtype(a) == bool_:</span>
      <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
        <span class="s4">&quot;Boolean arguments to jax.numpy.ix_ are not implemented&quot;</span><span class="s1">)</span>
    <span class="s1">shape = [</span><span class="s5">1</span><span class="s1">] * n</span>
    <span class="s1">shape[i] = a.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">a.size == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># Numpy uses an integer index type for empty arrays.</span>
      <span class="s1">output.append(lax.full(shape</span><span class="s3">, </span><span class="s1">np.zeros(()</span><span class="s3">, </span><span class="s1">np.intp)))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">output.append(lax.broadcast_in_dim(a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">,</span><span class="s1">)))</span>
  <span class="s3">return </span><span class="s1">tuple(output)</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">indices(dimensions: Sequence[int]</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = int32</span><span class="s3">,</span>
            <span class="s1">sparse: Literal[</span><span class="s3">False</span><span class="s1">] = </span><span class="s3">False</span><span class="s1">) -&gt; Array: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">indices(dimensions: Sequence[int]</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = int32</span><span class="s3">,</span>
            <span class="s1">*</span><span class="s3">, </span><span class="s1">sparse: Literal[</span><span class="s3">True</span><span class="s1">]) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">...]: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">indices(dimensions: Sequence[int]</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = int32</span><span class="s3">,</span>
            <span class="s1">sparse: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">...]]: ...</span>
<span class="s1">@util._wraps(np.indices)</span>
<span class="s3">def </span><span class="s1">indices(dimensions: Sequence[int]</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = int32</span><span class="s3">,</span>
            <span class="s1">sparse: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Union[Array</span><span class="s3">, </span><span class="s1">Tuple[Array</span><span class="s3">, </span><span class="s1">...]]:</span>
  <span class="s1">dimensions = tuple(</span>
      <span class="s1">core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s4">&quot;dimensions argument of jnp.indices&quot;</span><span class="s1">)</span>
      <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dimensions)</span>
  <span class="s1">N = len(dimensions)</span>
  <span class="s1">output = []</span>
  <span class="s1">s = dimensions</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">dim </span><span class="s3">in </span><span class="s1">enumerate(dimensions):</span>
    <span class="s1">idx = lax.iota(dtype</span><span class="s3">, </span><span class="s1">dim)</span>
    <span class="s3">if </span><span class="s1">sparse:</span>
      <span class="s1">s = (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)*i + (dim</span><span class="s3">,</span><span class="s1">) + (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)*(N - i - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">output.append(lax.broadcast_in_dim(idx</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">,</span><span class="s1">)))</span>
  <span class="s3">if </span><span class="s1">sparse:</span>
    <span class="s3">return </span><span class="s1">tuple(output)</span>
  <span class="s3">return </span><span class="s1">stack(output</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s3">if </span><span class="s1">output </span><span class="s3">else </span><span class="s1">array([]</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">_TOTAL_REPEAT_LENGTH_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">JAX adds the optional `total_repeat_length` parameter which specifies the total 
number of repeat, and defaults to sum(repeats). It must be specified for repeat 
to be compilable. If `sum(repeats)` is larger than the specified 
`total_repeat_length` the remaining values will be discarded. In the case of 
`sum(repeats)` being smaller than the specified target length, the final value 
will be repeated. 
&quot;&quot;&quot;</span>


<span class="s1">@util._wraps(np.repeat</span><span class="s3">, </span><span class="s1">lax_description=_TOTAL_REPEAT_LENGTH_DOC)</span>
<span class="s3">def </span><span class="s1">repeat(a: ArrayLike</span><span class="s3">, </span><span class="s1">repeats: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">*</span><span class="s3">,</span>
           <span class="s1">total_repeat_length: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;repeat&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">core.is_special_dim_size(repeats) </span><span class="s3">or </span><span class="s1">util.check_arraylike(</span><span class="s4">&quot;repeat&quot;</span><span class="s3">, </span><span class="s1">repeats)</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">a = asarray(a)</span>

  <span class="s1">axis = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;'axis' argument of jnp.repeat()&quot;</span><span class="s1">)</span>
  <span class="s3">assert </span><span class="s1">isinstance(axis</span><span class="s3">, </span><span class="s1">int)  </span><span class="s0"># to appease mypy</span>

  <span class="s3">if </span><span class="s1">core.is_special_dim_size(repeats):</span>
    <span class="s3">if </span><span class="s1">total_repeat_length </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.repeat with a non-constant `repeats` is supported only &quot;</span>
                       <span class="s4">&quot;when `total_repeat_length` is None&quot;</span><span class="s1">)</span>

  <span class="s0"># If total_repeat_length is not given, use a default.</span>
  <span class="s3">if </span><span class="s1">total_repeat_length </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">repeats = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">repeats</span><span class="s3">,</span>
      <span class="s4">&quot;When jit-compiling jnp.repeat, the total number of repeats must be static. &quot;</span>
      <span class="s4">&quot;To fix this, either specify a static value for `repeats`, or pass a static &quot;</span>
      <span class="s4">&quot;value to `total_repeat_length`.&quot;</span><span class="s1">)</span>

    <span class="s0"># Fast path for when repeats is a scalar.</span>
    <span class="s3">if </span><span class="s1">np.ndim(repeats) == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">ndim(a) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">input_shape = shape(a)</span>
      <span class="s1">aux_axis = axis </span><span class="s3">if </span><span class="s1">axis &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">axis + </span><span class="s5">1</span>
      <span class="s1">a = expand_dims(a</span><span class="s3">, </span><span class="s1">aux_axis)</span>
      <span class="s1">reps: List[DimSize] = [</span><span class="s5">1</span><span class="s1">] * len(shape(a))</span>
      <span class="s1">reps[aux_axis] = repeats</span>
      <span class="s1">a = tile(a</span><span class="s3">, </span><span class="s1">reps)</span>
      <span class="s1">result_shape: List[DimSize] = list(input_shape)</span>
      <span class="s1">result_shape[axis] *= repeats</span>
      <span class="s3">return </span><span class="s1">reshape(a</span><span class="s3">, </span><span class="s1">result_shape)</span>

    <span class="s1">repeats = np.ravel(repeats)</span>
    <span class="s3">if </span><span class="s1">ndim(a) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">repeats = np.broadcast_to(repeats</span><span class="s3">, </span><span class="s1">[shape(a)[axis]])</span>
    <span class="s1">total_repeat_length = np.sum(repeats)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">repeats = ravel(repeats)</span>
    <span class="s3">if </span><span class="s1">ndim(a) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">repeats = broadcast_to(repeats</span><span class="s3">, </span><span class="s1">[shape(a)[axis]])</span>

  <span class="s0"># Special case when a is a scalar.</span>
  <span class="s3">if </span><span class="s1">ndim(a) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">shape(repeats) == (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">):</span>
      <span class="s3">return </span><span class="s1">full([total_repeat_length]</span><span class="s3">, </span><span class="s1">a)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'`repeat` with a scalar parameter `a` is only '</span>
      <span class="s4">'implemented for scalar values of the parameter `repeats`.'</span><span class="s1">)</span>

  <span class="s0"># Special case if total_repeat_length is zero.</span>
  <span class="s3">if </span><span class="s1">total_repeat_length == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">result_shape = list(shape(a))</span>
    <span class="s1">result_shape[axis] = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">reshape(array([]</span><span class="s3">, </span><span class="s1">dtype=_dtype(a))</span><span class="s3">, </span><span class="s1">result_shape)</span>

  <span class="s0"># If repeats is on a zero sized axis, then return the array.</span>
  <span class="s3">if </span><span class="s1">shape(a)[axis] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">asarray(a)</span>

  <span class="s0"># This implementation of repeat avoid having to instantiate a large.</span>
  <span class="s0"># intermediate tensor.</span>

  <span class="s0"># Modify repeats from e.g. [1,2,0,5] -&gt; [0,1,2,0] for exclusive repeat.</span>
  <span class="s1">exclusive_repeats = roll(repeats</span><span class="s3">, </span><span class="s1">shift=</span><span class="s5">1</span><span class="s1">).at[</span><span class="s5">0</span><span class="s1">].set(</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s0"># Cumsum to get indices of new number in repeated tensor, e.g. [0, 1, 3, 3]</span>
  <span class="s1">scatter_indices = reductions.cumsum(exclusive_repeats)</span>
  <span class="s0"># Scatter these onto a zero buffer, e.g. [1,1,0,2,0,0,0,0]</span>
  <span class="s1">block_split_indicators = zeros([total_repeat_length]</span><span class="s3">, </span><span class="s1">dtype=int32)</span>
  <span class="s1">block_split_indicators = block_split_indicators.at[scatter_indices].add(</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s0"># Cumsum again to get scatter indices for repeat, e.g. [0,1,1,3,3,3,3,3]</span>
  <span class="s1">gather_indices = reductions.cumsum(block_split_indicators) - </span><span class="s5">1</span>
  <span class="s3">return </span><span class="s1">take(a</span><span class="s3">, </span><span class="s1">gather_indices</span><span class="s3">, </span><span class="s1">axis=axis)</span>


<span class="s1">@util._wraps(np.tri)</span>
<span class="s3">def </span><span class="s1">tri(N: int</span><span class="s3">, </span><span class="s1">M: Optional[int] = </span><span class="s3">None, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype: DTypeLike = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;tri&quot;</span><span class="s1">)</span>
  <span class="s1">M = M </span><span class="s3">if </span><span class="s1">M </span><span class="s3">is not None else </span><span class="s1">N</span>
  <span class="s1">dtype = dtype </span><span class="s3">or </span><span class="s1">float32</span>
  <span class="s3">return </span><span class="s1">lax_internal._tri(dtype</span><span class="s3">, </span><span class="s1">(N</span><span class="s3">, </span><span class="s1">M)</span><span class="s3">, </span><span class="s1">k)</span>


<span class="s1">@util._wraps(np.tril)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'k'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">tril(m: ArrayLike</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;tril&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s1">m_shape = shape(m)</span>
  <span class="s3">if </span><span class="s1">len(m_shape) &lt; </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Argument to jax.numpy.tril must be at least 2D&quot;</span><span class="s1">)</span>
  <span class="s1">N</span><span class="s3">, </span><span class="s1">M = m_shape[-</span><span class="s5">2</span><span class="s1">:]</span>
  <span class="s1">mask = tri(N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
  <span class="s3">return </span><span class="s1">lax.select(lax.broadcast(mask</span><span class="s3">, </span><span class="s1">m_shape[:-</span><span class="s5">2</span><span class="s1">])</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">zeros_like(m))</span>


<span class="s1">@util._wraps(np.triu</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'k'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">triu(m: ArrayLike</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;triu&quot;</span><span class="s3">, </span><span class="s1">m)</span>
  <span class="s1">m_shape = shape(m)</span>
  <span class="s3">if </span><span class="s1">len(m_shape) &lt; </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Argument to jax.numpy.triu must be at least 2D&quot;</span><span class="s1">)</span>
  <span class="s1">N</span><span class="s3">, </span><span class="s1">M = m_shape[-</span><span class="s5">2</span><span class="s1">:]</span>
  <span class="s1">mask = tri(N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">k=k - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
  <span class="s3">return </span><span class="s1">lax.select(lax.broadcast(mask</span><span class="s3">, </span><span class="s1">m_shape[:-</span><span class="s5">2</span><span class="s1">])</span><span class="s3">, </span><span class="s1">zeros_like(m)</span><span class="s3">, </span><span class="s1">m)</span>


<span class="s1">@util._wraps(np.trace</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'offset'</span><span class="s3">, </span><span class="s4">'axis1'</span><span class="s3">, </span><span class="s4">'axis2'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">trace(a: ArrayLike</span><span class="s3">, </span><span class="s1">offset: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis1: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis2: int = </span><span class="s5">1</span><span class="s3">,</span>
          <span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None, </span><span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;trace&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.trace is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">dtypes.check_user_dtype_supported(dtype</span><span class="s3">, </span><span class="s4">&quot;trace&quot;</span><span class="s1">)</span>

  <span class="s1">a_shape = shape(a)</span>
  <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dtype = _dtype(a)</span>
    <span class="s3">if </span><span class="s1">issubdtype(dtype</span><span class="s3">, </span><span class="s1">integer):</span>
      <span class="s1">default_int = dtypes.canonicalize_dtype(np.int_)</span>
      <span class="s3">if </span><span class="s1">iinfo(dtype).bits &lt; iinfo(default_int).bits:</span>
        <span class="s1">dtype = default_int</span>

  <span class="s1">a = moveaxis(a</span><span class="s3">, </span><span class="s1">(axis1</span><span class="s3">, </span><span class="s1">axis2)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>

  <span class="s0"># Mask out the diagonal and reduce.</span>
  <span class="s1">a = where(eye(a_shape[axis1]</span><span class="s3">, </span><span class="s1">a_shape[axis2]</span><span class="s3">, </span><span class="s1">k=offset</span><span class="s3">, </span><span class="s1">dtype=bool)</span><span class="s3">,</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">zeros_like(a))</span>
  <span class="s3">return </span><span class="s1">reductions.sum(a</span><span class="s3">, </span><span class="s1">axis=(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>


<span class="s3">def </span><span class="s1">_wrap_indices_function(f):</span>
  <span class="s1">@util._wraps(f</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">def </span><span class="s1">wrapper(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s1">args = [core.concrete_or_error(</span>
              <span class="s3">None, </span><span class="s1">arg</span><span class="s3">, </span><span class="s4">f&quot;argument </span><span class="s3">{</span><span class="s1">i</span><span class="s3">} </span><span class="s4">of jnp.</span><span class="s3">{</span><span class="s1">f.__name__</span><span class="s3">}</span><span class="s4">()&quot;</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">enumerate(args)]</span>
    <span class="s1">kwargs = {key: core.concrete_or_error(</span>
                <span class="s3">None, </span><span class="s1">val</span><span class="s3">, </span><span class="s4">f&quot;argument '</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s4">' of jnp.</span><span class="s3">{</span><span class="s1">f.__name__</span><span class="s3">}</span><span class="s4">()&quot;</span><span class="s1">)</span>
              <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">kwargs.items()}</span>
    <span class="s3">return </span><span class="s1">tuple(asarray(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">f(*args</span><span class="s3">, </span><span class="s1">**kwargs))</span>
  <span class="s3">return </span><span class="s1">wrapper</span>

<span class="s1">mask_indices = _wrap_indices_function(np.mask_indices)</span>


<span class="s3">def </span><span class="s1">_triu_size(n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">k):</span>
  <span class="s3">if </span><span class="s1">k &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">n * m - _triu_size(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- k))</span>
  <span class="s3">elif </span><span class="s1">k &gt;= m:</span>
    <span class="s3">return </span><span class="s5">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">mk = _min(n</span><span class="s3">, </span><span class="s1">m - k)</span>
    <span class="s3">return </span><span class="s1">mk * (mk + </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2 </span><span class="s1">+ mk * (m - k - mk)</span>


<span class="s1">@util._wraps(np.triu_indices)</span>
<span class="s3">def </span><span class="s1">triu_indices(n: int</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">m: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">n = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s4">&quot;n argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">k = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s4">&quot;k argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">m = n </span><span class="s3">if </span><span class="s1">m </span><span class="s3">is None else </span><span class="s1">core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s4">&quot;m argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">i</span><span class="s3">, </span><span class="s1">j = nonzero(triu(ones((n</span><span class="s3">, </span><span class="s1">m))</span><span class="s3">, </span><span class="s1">k=k)</span><span class="s3">, </span><span class="s1">size=_triu_size(n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">k))</span>
  <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span>


<span class="s1">@util._wraps(np.tril_indices)</span>
<span class="s3">def </span><span class="s1">tril_indices(n: int</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">m: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">n = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s4">&quot;n argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">k = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s4">&quot;k argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">m = n </span><span class="s3">if </span><span class="s1">m </span><span class="s3">is None else </span><span class="s1">core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s4">&quot;m argument of jnp.triu_indices&quot;</span><span class="s1">)</span>
  <span class="s1">i</span><span class="s3">, </span><span class="s1">j = nonzero(tril(ones((n</span><span class="s3">, </span><span class="s1">m))</span><span class="s3">, </span><span class="s1">k=k)</span><span class="s3">, </span><span class="s1">size=_triu_size(m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">-k))</span>
  <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span>


<span class="s1">@util._wraps(np.triu_indices_from)</span>
<span class="s3">def </span><span class="s1">triu_indices_from(arr: ArrayLike</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">arr_shape = shape(arr)</span>
  <span class="s3">return </span><span class="s1">triu_indices(arr_shape[-</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">m=arr_shape[-</span><span class="s5">1</span><span class="s1">])</span>


<span class="s1">@util._wraps(np.tril_indices_from)</span>
<span class="s3">def </span><span class="s1">tril_indices_from(arr: ArrayLike</span><span class="s3">, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">arr_shape = shape(arr)</span>
  <span class="s3">return </span><span class="s1">tril_indices(arr_shape[-</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">m=arr_shape[-</span><span class="s5">1</span><span class="s1">])</span>


<span class="s1">@util._wraps(np.diag_indices)</span>
<span class="s3">def </span><span class="s1">diag_indices(n</span><span class="s3">, </span><span class="s1">ndim=</span><span class="s5">2</span><span class="s1">):</span>
  <span class="s1">n = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s4">&quot;'n' argument of jnp.diag_indices()&quot;</span><span class="s1">)</span>
  <span class="s1">ndim = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s4">&quot;'ndim' argument of jnp.diag_indices()&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n argument to diag_indices must be nonnegative, got {}&quot;</span>
                     <span class="s1">.format(n))</span>
  <span class="s3">if </span><span class="s1">ndim &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ndim argument to diag_indices must be nonnegative, got {}&quot;</span>
                     <span class="s1">.format(ndim))</span>
  <span class="s3">return </span><span class="s1">(lax.iota(int_</span><span class="s3">, </span><span class="s1">n)</span><span class="s3">,</span><span class="s1">) * ndim</span>

<span class="s1">@util._wraps(np.diag_indices_from)</span>
<span class="s3">def </span><span class="s1">diag_indices_from(arr):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diag_indices_from&quot;</span><span class="s3">, </span><span class="s1">arr)</span>
  <span class="s3">if not </span><span class="s1">arr.ndim &gt;= </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;input array must be at least 2-d&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">len(set(arr.shape)) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All dimensions of input must be of equal length&quot;</span><span class="s1">)</span>

  <span class="s3">return </span><span class="s1">diag_indices(arr.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ndim=arr.ndim)</span>

<span class="s1">@util._wraps(np.diagonal</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'offset'</span><span class="s3">, </span><span class="s4">'axis1'</span><span class="s3">, </span><span class="s4">'axis2'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">diagonal(a</span><span class="s3">, </span><span class="s1">offset=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis1: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis2: int = </span><span class="s5">1</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diagonal&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">a_shape = shape(a)</span>
  <span class="s3">if </span><span class="s1">ndim(a) &lt; </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;diagonal requires an array of at least two dimensions.&quot;</span><span class="s1">)</span>
  <span class="s1">offset = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s4">&quot;'offset' argument of jnp.diagonal()&quot;</span><span class="s1">)</span>

  <span class="s1">a = moveaxis(a</span><span class="s3">, </span><span class="s1">(axis1</span><span class="s3">, </span><span class="s1">axis2)</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>

  <span class="s1">diag_size = _max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">_min(a_shape[axis1] + _min(offset</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">a_shape[axis2] - _max(offset</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)))</span>
  <span class="s1">i = arange(diag_size)</span>
  <span class="s1">j = arange(_abs(offset)</span><span class="s3">, </span><span class="s1">_abs(offset) + diag_size)</span>
  <span class="s3">return </span><span class="s1">a[...</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j] </span><span class="s3">if </span><span class="s1">offset &gt;= </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">a[...</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">i]</span>


<span class="s1">@util._wraps(np.diag</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s3">def </span><span class="s1">diag(v</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s3">return </span><span class="s1">_diag(v</span><span class="s3">, </span><span class="s1">operator.index(k))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'k'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_diag(v</span><span class="s3">, </span><span class="s1">k):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diag&quot;</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s1">v_shape = shape(v)</span>
  <span class="s3">if </span><span class="s1">len(v_shape) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">zero = </span><span class="s3">lambda </span><span class="s1">x: lax.full_like(x</span><span class="s3">, </span><span class="s1">shape=()</span><span class="s3">, </span><span class="s1">fill_value=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">n = v_shape[</span><span class="s5">0</span><span class="s1">] + _abs(k)</span>
    <span class="s1">v = lax.pad(v</span><span class="s3">, </span><span class="s1">zero(v)</span><span class="s3">, </span><span class="s1">((_max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s1">_max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">-k)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">where(eye(n</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">dtype=bool)</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">zeros_like(v))</span>
  <span class="s3">elif </span><span class="s1">len(v_shape) == </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">diagonal(v</span><span class="s3">, </span><span class="s1">offset=k)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;diag input must be 1d or 2d&quot;</span><span class="s1">)</span>

<span class="s1">_SCALAR_VALUE_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">This differs from np.diagflat for some scalar values of v, 
jax always returns a two-dimensional array, whereas numpy may 
return a scalar depending on the type of v. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.diagflat</span><span class="s3">, </span><span class="s1">lax_description=_SCALAR_VALUE_DOC)</span>
<span class="s3">def </span><span class="s1">diagflat(v</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;diagflat&quot;</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s1">v = ravel(v)</span>
  <span class="s1">v_length = len(v)</span>
  <span class="s1">adj_length = v_length + _abs(k)</span>
  <span class="s1">res = zeros(adj_length*adj_length</span><span class="s3">, </span><span class="s1">dtype=v.dtype)</span>
  <span class="s1">i = arange(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">adj_length-_abs(k))</span>
  <span class="s3">if </span><span class="s1">(k &gt;= </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s1">fi = i+k+i*adj_length</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">fi = i+(i-k)*adj_length</span>
  <span class="s1">res = res.at[fi].set(v)</span>
  <span class="s1">res = res.reshape(adj_length</span><span class="s3">, </span><span class="s1">adj_length)</span>
  <span class="s3">return </span><span class="s1">res</span>


<span class="s1">@util._wraps(np.trim_zeros)</span>
<span class="s3">def </span><span class="s1">trim_zeros(filt</span><span class="s3">, </span><span class="s1">trim=</span><span class="s4">'fb'</span><span class="s1">):</span>
  <span class="s1">filt = core.concrete_or_error(asarray</span><span class="s3">, </span><span class="s1">filt</span><span class="s3">,</span>
    <span class="s4">&quot;Error arose in the `filt` argument of trim_zeros()&quot;</span><span class="s1">)</span>
  <span class="s1">nz = (filt == </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">reductions.all(nz):</span>
    <span class="s3">return </span><span class="s1">empty(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">_dtype(filt))</span>
  <span class="s1">start = argmin(nz) </span><span class="s3">if </span><span class="s4">'f' </span><span class="s3">in </span><span class="s1">trim.lower() </span><span class="s3">else </span><span class="s5">0</span>
  <span class="s1">end = argmin(nz[::-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s4">'b' </span><span class="s3">in </span><span class="s1">trim.lower() </span><span class="s3">else </span><span class="s5">0</span>
  <span class="s3">return </span><span class="s1">filt[start:len(filt) - end]</span>


<span class="s3">def </span><span class="s1">trim_zeros_tol(filt</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">trim=</span><span class="s4">'fb'</span><span class="s1">):</span>
  <span class="s1">filt = core.concrete_or_error(asarray</span><span class="s3">, </span><span class="s1">filt</span><span class="s3">,</span>
    <span class="s4">&quot;Error arose in the `filt` argument of trim_zeros_tol()&quot;</span><span class="s1">)</span>
  <span class="s1">nz = (ufuncs.abs(filt) &lt; tol)</span>
  <span class="s3">if </span><span class="s1">reductions.all(nz):</span>
    <span class="s3">return </span><span class="s1">empty(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">_dtype(filt))</span>
  <span class="s1">start = argmin(nz) </span><span class="s3">if </span><span class="s4">'f' </span><span class="s3">in </span><span class="s1">trim.lower() </span><span class="s3">else </span><span class="s5">0</span>
  <span class="s1">end = argmin(nz[::-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s4">'b' </span><span class="s3">in </span><span class="s1">trim.lower() </span><span class="s3">else </span><span class="s5">0</span>
  <span class="s3">return </span><span class="s1">filt[start:len(filt) - end]</span>


<span class="s1">@util._wraps(np.append)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">append(arr</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">concatenate([ravel(arr)</span><span class="s3">, </span><span class="s1">ravel(values)]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">concatenate([arr</span><span class="s3">, </span><span class="s1">values]</span><span class="s3">, </span><span class="s1">axis=axis)</span>


<span class="s1">@util._wraps(np.delete)</span>
<span class="s3">def </span><span class="s1">delete(arr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;delete&quot;</span><span class="s3">, </span><span class="s1">arr)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">arr = ravel(arr)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim)</span>

  <span class="s0"># Case 1: obj is a static integer.</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">obj = operator.index(obj)</span>
    <span class="s1">obj = _canonicalize_axis(obj</span><span class="s3">, </span><span class="s1">arr.shape[axis])</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s3">pass</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">idx = tuple(slice(</span><span class="s3">None</span><span class="s1">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(axis))</span>
    <span class="s3">return </span><span class="s1">concatenate([arr[idx + (slice(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">obj)</span><span class="s3">,</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">arr[idx + (slice(obj + </span><span class="s5">1</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)]]</span><span class="s3">, </span><span class="s1">axis=axis)</span>

  <span class="s0"># Case 2: obj is a static slice.</span>
  <span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">slice):</span>
    <span class="s0"># TODO(jakevdp): we should be able to do this dynamically with care.</span>
    <span class="s1">indices = np.delete(np.arange(arr.shape[axis])</span><span class="s3">, </span><span class="s1">obj)</span>
    <span class="s3">return </span><span class="s1">take(arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis=axis)</span>

  <span class="s0"># Case 3: obj is an array</span>
  <span class="s0"># NB: pass both arrays to check for appropriate error message.</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;delete&quot;</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">obj)</span>
  <span class="s1">obj = core.concrete_or_error(np.asarray</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s4">&quot;'obj' array argument of jnp.delete()&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">issubdtype(obj.dtype</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s0"># TODO(jakevdp): in theory this could be done dynamically if obj has no duplicates,</span>
    <span class="s0"># but this would require the complement of lax.gather.</span>
    <span class="s1">mask = np.ones(arr.shape[axis]</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">mask[obj] = </span><span class="s3">False</span>
  <span class="s3">elif </span><span class="s1">obj.dtype == bool:</span>
    <span class="s3">if </span><span class="s1">obj.shape != (arr.shape[axis]</span><span class="s3">,</span><span class="s1">):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;np.delete(arr, obj): for boolean indices, obj must be one-dimensional &quot;</span>
                       <span class="s4">&quot;with length matching specified axis.&quot;</span><span class="s1">)</span>
    <span class="s1">mask = ~obj</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;np.delete(arr, obj): got obj.dtype=</span><span class="s3">{</span><span class="s1">obj.dtype</span><span class="s3">}</span><span class="s4">; must be integer or bool.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">arr[tuple(slice(</span><span class="s3">None</span><span class="s1">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(axis)) + (mask</span><span class="s3">,</span><span class="s1">)]</span>

<span class="s1">@util._wraps(np.insert)</span>
<span class="s3">def </span><span class="s1">insert(arr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;insert&quot;</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s5">0 </span><span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">slice) </span><span class="s3">else </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">values)</span>
  <span class="s1">arr = asarray(arr)</span>
  <span class="s1">values = asarray(values)</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">arr = ravel(arr)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s1">axis = core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">axis</span><span class="s3">, </span><span class="s4">&quot;axis argument of jnp.insert()&quot;</span><span class="s1">)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim)</span>
  <span class="s3">if </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">slice):</span>
    <span class="s1">indices = arange(*obj.indices(arr.shape[axis]))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">indices = asarray(obj)</span>

  <span class="s3">if </span><span class="s1">indices.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.insert(): obj must be a slice, a one-dimensional &quot;</span>
                     <span class="s4">f&quot;array, or a scalar; got </span><span class="s3">{</span><span class="s1">obj</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if not </span><span class="s1">np.issubdtype(indices.dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">if </span><span class="s1">indices.size == </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">Array):</span>
      <span class="s1">indices = indices.astype(int)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># Note: np.insert allows boolean inputs but the behavior is deprecated.</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;jnp.insert(): index array must be &quot;</span>
                       <span class="s4">f&quot;integer typed; got </span><span class="s3">{</span><span class="s1">obj</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">values = array(values</span><span class="s3">, </span><span class="s1">ndmin=arr.ndim</span><span class="s3">, </span><span class="s1">dtype=arr.dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">indices.size == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">index = ravel(indices)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">indices.ndim == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">values = moveaxis(values</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s1">indices = full(values.shape[axis]</span><span class="s3">, </span><span class="s1">index)</span>
  <span class="s1">n_input = arr.shape[axis]</span>
  <span class="s1">n_insert = broadcast_shapes(indices.shape</span><span class="s3">, </span><span class="s1">values.shape[axis])[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">out_shape = list(arr.shape)</span>
  <span class="s1">out_shape[axis] += n_insert</span>
  <span class="s1">out = zeros_like(arr</span><span class="s3">, </span><span class="s1">shape=tuple(out_shape))</span>

  <span class="s1">indices = where(indices &lt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">indices + n_input</span><span class="s3">, </span><span class="s1">indices)</span>
  <span class="s1">indices = clip(indices</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_input)</span>

  <span class="s1">values_ind = indices.at[argsort(indices)].add(arange(n_insert</span><span class="s3">, </span><span class="s1">dtype=indices.dtype))</span>
  <span class="s1">arr_mask = ones(n_input + n_insert</span><span class="s3">, </span><span class="s1">dtype=bool).at[values_ind].set(</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s1">arr_ind = where(arr_mask</span><span class="s3">, </span><span class="s1">size=n_input)[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s1">out = out.at[(slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) * axis + (values_ind</span><span class="s3">,</span><span class="s1">)].set(values)</span>
  <span class="s1">out = out.at[(slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) * axis + (arr_ind</span><span class="s3">,</span><span class="s1">)].set(arr)</span>

  <span class="s3">return </span><span class="s1">out</span>


<span class="s1">@util._wraps(np.apply_along_axis)</span>
<span class="s3">def </span><span class="s1">apply_along_axis(func1d</span><span class="s3">, </span><span class="s1">axis: int</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s1">num_dims = ndim(arr)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">num_dims)</span>
  <span class="s1">func = </span><span class="s3">lambda </span><span class="s1">arr: func1d(arr</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">num_dims - axis):</span>
    <span class="s1">func = jax.vmap(func</span><span class="s3">, </span><span class="s1">in_axes=i</span><span class="s3">, </span><span class="s1">out_axes=-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(axis):</span>
    <span class="s1">func = jax.vmap(func</span><span class="s3">, </span><span class="s1">in_axes=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">out_axes=</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">func(arr)</span>


<span class="s1">@util._wraps(np.apply_over_axes)</span>
<span class="s3">def </span><span class="s1">apply_over_axes(func</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axes):</span>
  <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">axes:</span>
    <span class="s1">b = func(a</span><span class="s3">, </span><span class="s1">axis=axis)</span>
    <span class="s3">if </span><span class="s1">b.ndim == a.ndim:</span>
      <span class="s1">a = b</span>
    <span class="s3">elif </span><span class="s1">b.ndim == a.ndim - </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">a = expand_dims(b</span><span class="s3">, </span><span class="s1">axis)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;function is not returning an array of the correct shape&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">a</span>


<span class="s0">### Tensor contraction operations</span>


<span class="s1">@util._wraps(np.dot</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'precision'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">dot(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None</span><span class="s1">):  </span><span class="s0"># pylint: disable=missing-docstring</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;dot&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s1">a_ndim</span><span class="s3">, </span><span class="s1">b_ndim = ndim(a)</span><span class="s3">, </span><span class="s1">ndim(b)</span>
  <span class="s3">if </span><span class="s1">a_ndim == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">b_ndim == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.mul(a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">if </span><span class="s1">_max(a_ndim</span><span class="s3">, </span><span class="s1">b_ndim) &lt;= </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.dot(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">precision=precision)</span>

  <span class="s3">if </span><span class="s1">b_ndim == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">contract_dims = ((a_ndim - </span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">contract_dims = ((a_ndim - </span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(b_ndim - </span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s1">batch_dims = (()</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s3">return </span><span class="s1">lax.dot_general(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">(contract_dims</span><span class="s3">, </span><span class="s1">batch_dims)</span><span class="s3">, </span><span class="s1">precision)</span>


<span class="s1">@util._wraps(np.matmul</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'precision'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">matmul(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None</span><span class="s1">):  </span><span class="s0"># pylint: disable=missing-docstring</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;matmul&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s3">in </span><span class="s1">enumerate((a</span><span class="s3">, </span><span class="s1">b)):</span>
    <span class="s3">if </span><span class="s1">ndim(x) &lt; </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">msg = (</span><span class="s4">f&quot;matmul input operand </span><span class="s3">{</span><span class="s1">i</span><span class="s3">} </span><span class="s4">must have ndim at least 1, &quot;</span>
             <span class="s4">f&quot;but it has ndim </span><span class="s3">{</span><span class="s1">ndim(x)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">b)</span>

  <span class="s1">a_is_mat</span><span class="s3">, </span><span class="s1">b_is_mat = (ndim(a) &gt; </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(ndim(b) &gt; </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">a_batch_dims = shape(a)[:-</span><span class="s5">2</span><span class="s1">] </span><span class="s3">if </span><span class="s1">a_is_mat </span><span class="s3">else </span><span class="s1">()</span>
  <span class="s1">b_batch_dims = shape(b)[:-</span><span class="s5">2</span><span class="s1">] </span><span class="s3">if </span><span class="s1">b_is_mat </span><span class="s3">else </span><span class="s1">()</span>
  <span class="s1">num_batch_dims = _max(len(a_batch_dims)</span><span class="s3">, </span><span class="s1">len(b_batch_dims))</span>
  <span class="s1">a_batch_dims = (</span><span class="s3">None,</span><span class="s1">) * (num_batch_dims - len(a_batch_dims)) + a_batch_dims</span>
  <span class="s1">b_batch_dims = (</span><span class="s3">None,</span><span class="s1">) * (num_batch_dims - len(b_batch_dims)) + b_batch_dims</span>

  <span class="s0"># Dimensions to squeeze from the inputs.</span>
  <span class="s1">a_squeeze = []</span>
  <span class="s1">b_squeeze = []</span>

  <span class="s0"># Positions of batch dimensions in squeezed inputs.</span>
  <span class="s1">a_batch = []</span>
  <span class="s1">b_batch = []</span>

  <span class="s0"># Desired index in final output of each kind of dimension, in the order that</span>
  <span class="s0"># lax.dot_general will emit them.</span>
  <span class="s1">idx_batch = []</span>
  <span class="s1">idx_a_other = []  </span><span class="s0"># other = non-batch, non-contracting.</span>
  <span class="s1">idx_b_other = []</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(ba</span><span class="s3">, </span><span class="s1">bb) </span><span class="s3">in </span><span class="s1">enumerate(zip(a_batch_dims</span><span class="s3">, </span><span class="s1">b_batch_dims)):</span>
    <span class="s3">if </span><span class="s1">ba </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">idx_b_other.append(i)</span>
    <span class="s3">elif </span><span class="s1">bb </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">idx_a_other.append(i)</span>
    <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(ba</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s1">idx_b_other.append(i)</span>
      <span class="s1">a_squeeze.append(len(idx_batch) + len(idx_a_other) + len(a_squeeze))</span>
    <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(bb</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s1">idx_a_other.append(i)</span>
      <span class="s1">b_squeeze.append(len(idx_batch) + len(idx_b_other) + len(b_squeeze))</span>
    <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(ba</span><span class="s3">, </span><span class="s1">bb):</span>
      <span class="s1">a_batch.append(len(idx_batch) + len(idx_a_other))</span>
      <span class="s1">b_batch.append(len(idx_batch) + len(idx_b_other))</span>
      <span class="s1">idx_batch.append(i)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Incompatible shapes for matmul arguments: {} and {}&quot;</span>
                       <span class="s1">.format(shape(a)</span><span class="s3">, </span><span class="s1">shape(b)))</span>

  <span class="s3">if </span><span class="s1">a_is_mat: idx_a_other.append(num_batch_dims)</span>
  <span class="s3">if </span><span class="s1">b_is_mat: idx_b_other.append(num_batch_dims + a_is_mat)</span>
  <span class="s1">perm = np.argsort(np.concatenate([idx_batch</span><span class="s3">, </span><span class="s1">idx_a_other</span><span class="s3">, </span><span class="s1">idx_b_other]))</span>

  <span class="s1">a = lax.squeeze(a</span><span class="s3">, </span><span class="s1">tuple(a_squeeze))</span>
  <span class="s1">b = lax.squeeze(b</span><span class="s3">, </span><span class="s1">tuple(b_squeeze))</span>
  <span class="s1">out = lax.dot_general(</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">(((ndim(a) - </span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(ndim(b) - </span><span class="s5">1 </span><span class="s1">- b_is_mat</span><span class="s3">,</span><span class="s1">))</span><span class="s3">, </span><span class="s1">(a_batch</span><span class="s3">, </span><span class="s1">b_batch))</span><span class="s3">,</span>
    <span class="s1">precision=precision)</span>
  <span class="s3">return </span><span class="s1">lax.transpose(out</span><span class="s3">, </span><span class="s1">perm)</span>


<span class="s1">@util._wraps(np.vdot</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'precision'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">vdot(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;vdot&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">if </span><span class="s1">issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">complexfloating):</span>
    <span class="s1">a = ufuncs.conj(a)</span>
  <span class="s3">return </span><span class="s1">dot(ravel(a)</span><span class="s3">, </span><span class="s1">ravel(b)</span><span class="s3">, </span><span class="s1">precision=precision)</span>


<span class="s1">@util._wraps(np.tensordot</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s3">def </span><span class="s1">tensordot(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axes=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;tensordot&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s1">a_ndim = ndim(a)</span>
  <span class="s1">b_ndim = ndim(b)</span>

  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">if </span><span class="s1">type(axes) </span><span class="s3">is </span><span class="s1">int:</span>
    <span class="s3">if </span><span class="s1">axes &gt; _min(a_ndim</span><span class="s3">, </span><span class="s1">b_ndim):</span>
      <span class="s1">msg = </span><span class="s4">&quot;Number of tensordot axes (axes {}) exceeds input ranks ({} and {})&quot;</span>
      <span class="s3">raise </span><span class="s1">TypeError(msg.format(axes</span><span class="s3">, </span><span class="s1">a.shape</span><span class="s3">, </span><span class="s1">b.shape))</span>
    <span class="s1">contracting_dims = tuple(range(a_ndim - axes</span><span class="s3">, </span><span class="s1">a_ndim))</span><span class="s3">, </span><span class="s1">tuple(range(axes))</span>
  <span class="s3">elif </span><span class="s1">type(axes) </span><span class="s3">in </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">len(axes) == </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s1">ax1</span><span class="s3">, </span><span class="s1">ax2 = axes</span>
    <span class="s3">if </span><span class="s1">type(ax1) == type(ax2) == int:</span>
      <span class="s1">contracting_dims = ((_canonicalize_axis(ax1</span><span class="s3">, </span><span class="s1">a_ndim)</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">(_canonicalize_axis(ax2</span><span class="s3">, </span><span class="s1">b_ndim)</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">type(ax1) </span><span class="s3">in </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">type(ax2) </span><span class="s3">in </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple):</span>
      <span class="s3">if </span><span class="s1">len(ax1) != len(ax2):</span>
        <span class="s1">msg = </span><span class="s4">&quot;tensordot requires axes lists to have equal length, got {} and {}.&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError(msg.format(ax1</span><span class="s3">, </span><span class="s1">ax2))</span>
      <span class="s1">contracting_dims = (tuple(_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">a_ndim) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">ax1)</span><span class="s3">,</span>
                          <span class="s1">tuple(_canonicalize_axis(i</span><span class="s3">, </span><span class="s1">b_ndim) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">ax2))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">msg = (</span><span class="s4">&quot;tensordot requires both axes lists to be either ints, tuples or &quot;</span>
             <span class="s4">&quot;lists, got {} and {}&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">TypeError(msg.format(ax1</span><span class="s3">, </span><span class="s1">ax2))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">msg = (</span><span class="s4">&quot;tensordot axes argument must be an int, a pair of ints, or a pair &quot;</span>
           <span class="s4">&quot;of lists/tuples of ints.&quot;</span><span class="s1">)</span>
    <span class="s3">raise </span><span class="s1">TypeError(msg)</span>
  <span class="s3">return </span><span class="s1">lax.dot_general(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">(contracting_dims</span><span class="s3">, </span><span class="s1">(()</span><span class="s3">, </span><span class="s1">()))</span><span class="s3">,</span>
                         <span class="s1">precision=precision)</span>


<span class="s1">_EINSUM_DOC = _PRECISION_DOC + </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">A tuple ``precision`` does not necessarily map to multiple arguments of ``einsum()``; 
rather, the specified ``precision`` is forwarded to each ``dot_general`` call used in 
the implementation. 
&quot;&quot;&quot;</span>


<span class="s1">@util._wraps(np.einsum</span><span class="s3">, </span><span class="s1">lax_description=_EINSUM_DOC</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">einsum(</span>
    <span class="s1">subscripts</span><span class="s3">,</span>
    <span class="s1">*operands</span><span class="s3">,</span>
    <span class="s1">out=</span><span class="s3">None,</span>
    <span class="s1">optimize=</span><span class="s4">&quot;optimal&quot;</span><span class="s3">,</span>
    <span class="s1">precision=</span><span class="s3">None,</span>
    <span class="s1">_use_xeinsum=</span><span class="s3">False,</span>
    <span class="s1">_dot_general=lax.dot_general</span><span class="s3">,</span>
<span class="s1">):</span>
  <span class="s1">operands = (subscripts</span><span class="s3">, </span><span class="s1">*operands)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.einsum is not supported.&quot;</span><span class="s1">)</span>

  <span class="s1">spec = operands[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">isinstance(operands[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else None</span>

  <span class="s3">if </span><span class="s1">(_use_xeinsum </span><span class="s3">or </span><span class="s1">spec </span><span class="s3">is not None and </span><span class="s4">'{' </span><span class="s3">in </span><span class="s1">spec):</span>
    <span class="s3">return </span><span class="s1">jax.named_call(lax.xeinsum</span><span class="s3">, </span><span class="s1">name=spec)(*operands)</span>

  <span class="s1">optimize = </span><span class="s4">'optimal' </span><span class="s3">if </span><span class="s1">optimize </span><span class="s3">is True else </span><span class="s1">optimize</span>
  <span class="s0"># using einsum_call=True here is an internal api for opt_einsum</span>

  <span class="s0"># Allow handling of shape polymorphism</span>
  <span class="s1">non_constant_dim_types = {</span>
      <span class="s1">type(d) </span><span class="s3">for </span><span class="s1">op </span><span class="s3">in </span><span class="s1">operands </span><span class="s3">if not </span><span class="s1">isinstance(op</span><span class="s3">, </span><span class="s1">str)</span>
      <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">np.shape(op) </span><span class="s3">if not </span><span class="s1">core.is_constant_dim(d)</span>
  <span class="s1">}</span>
  <span class="s3">if not </span><span class="s1">non_constant_dim_types:</span>
    <span class="s1">contract_path = opt_einsum.contract_path</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">ty = next(iter(non_constant_dim_types))</span>
    <span class="s1">contract_path = _poly_einsum_handlers.get(ty</span><span class="s3">, </span><span class="s1">_default_poly_einsum_handler)</span>
  <span class="s1">operands</span><span class="s3">, </span><span class="s1">contractions = contract_path(</span>
        <span class="s1">*operands</span><span class="s3">, </span><span class="s1">einsum_call=</span><span class="s3">True, </span><span class="s1">use_blas=</span><span class="s3">True, </span><span class="s1">optimize=optimize)</span>

  <span class="s1">contractions = tuple((a</span><span class="s3">, </span><span class="s1">frozenset(b)</span><span class="s3">, </span><span class="s1">c) </span><span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">*_ </span><span class="s3">in </span><span class="s1">contractions)</span>

  <span class="s1">_einsum_computation = jax.named_call(</span>
      <span class="s1">_einsum</span><span class="s3">, </span><span class="s1">name=spec) </span><span class="s3">if </span><span class="s1">spec </span><span class="s3">is not None else </span><span class="s1">_einsum</span>
  <span class="s3">return </span><span class="s1">_einsum_computation(operands</span><span class="s3">, </span><span class="s1">contractions</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">_dot_general)</span>


<span class="s0"># Enable other modules to override einsum_contact_path.</span>
<span class="s0"># Indexed by the type of the non constant dimension</span>
<span class="s1">_poly_einsum_handlers = {}  </span><span class="s0"># type: ignore</span>

<span class="s3">def </span><span class="s1">_default_poly_einsum_handler(*operands</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s1">dummy = collections.namedtuple(</span><span class="s4">'dummy'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'shape'</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">])</span>
  <span class="s1">dummies = [dummy(tuple(d </span><span class="s3">if </span><span class="s1">type(d) </span><span class="s3">is </span><span class="s1">int </span><span class="s3">else </span><span class="s5">8 </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">x.shape)</span><span class="s3">, </span><span class="s1">x.dtype)</span>
             <span class="s3">if </span><span class="s1">hasattr(x</span><span class="s3">, </span><span class="s4">'dtype'</span><span class="s1">) </span><span class="s3">else </span><span class="s1">x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">operands]</span>
  <span class="s1">mapping = {id(d): i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(dummies)}</span>
  <span class="s1">out_dummies</span><span class="s3">, </span><span class="s1">contractions = opt_einsum.contract_path(*dummies</span><span class="s3">, </span><span class="s1">**kwargs)</span>
  <span class="s1">contract_operands = [operands[mapping[id(d)]] </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">out_dummies]</span>
  <span class="s3">return </span><span class="s1">contract_operands</span><span class="s3">, </span><span class="s1">contractions</span>

<span class="s1">@util._wraps(np.einsum_path)</span>
<span class="s3">def </span><span class="s1">einsum_path(subscripts</span><span class="s3">, </span><span class="s1">*operands</span><span class="s3">, </span><span class="s1">optimize=</span><span class="s4">'greedy'</span><span class="s1">):</span>
  <span class="s0"># using einsum_call=True here is an internal api for opt_einsum</span>
  <span class="s3">return </span><span class="s1">opt_einsum.contract_path(subscripts</span><span class="s3">, </span><span class="s1">*operands</span><span class="s3">, </span><span class="s1">optimize=optimize)</span>

<span class="s3">def </span><span class="s1">_removechars(s</span><span class="s3">, </span><span class="s1">chars):</span>
  <span class="s3">return </span><span class="s1">s.translate(str.maketrans(dict.fromkeys(chars)))</span>


<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_einsum(</span>
    <span class="s1">operands: Sequence</span><span class="s3">,</span>
    <span class="s1">contractions: Sequence[Tuple[Tuple[int</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">FrozenSet[str]</span><span class="s3">, </span><span class="s1">str]]</span><span class="s3">,</span>
    <span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">_dot_general=lax.dot_general</span><span class="s3">,</span>
<span class="s1">):</span>
  <span class="s1">operands = list(util.promote_dtypes(*operands))</span>
  <span class="s3">def </span><span class="s1">sum(x</span><span class="s3">, </span><span class="s1">axes):</span>
    <span class="s3">return </span><span class="s1">lax.reduce(x</span><span class="s3">, </span><span class="s1">np.array(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">x.dtype)</span><span class="s3">,</span>
                      <span class="s1">lax.add </span><span class="s3">if </span><span class="s1">x.dtype != bool_ </span><span class="s3">else </span><span class="s1">lax.bitwise_or</span><span class="s3">, </span><span class="s1">axes)</span>

  <span class="s3">def </span><span class="s1">sum_uniques(operand</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">uniques):</span>
    <span class="s3">if </span><span class="s1">uniques:</span>
      <span class="s1">axes = [names.index(name) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">uniques]</span>
      <span class="s1">operand = sum(operand</span><span class="s3">, </span><span class="s1">axes)</span>
      <span class="s1">names = _removechars(names</span><span class="s3">, </span><span class="s1">uniques)</span>
    <span class="s3">return </span><span class="s1">operand</span><span class="s3">, </span><span class="s1">names</span>

  <span class="s3">def </span><span class="s1">sum_repeats(operand</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">, </span><span class="s1">keep_names):</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">count </span><span class="s3">in </span><span class="s1">counts.items():</span>
      <span class="s3">if </span><span class="s1">count &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">axes = [i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">n </span><span class="s3">in </span><span class="s1">enumerate(names) </span><span class="s3">if </span><span class="s1">n == name]</span>
        <span class="s1">eye = lax_internal._delta(operand.dtype</span><span class="s3">, </span><span class="s1">operand.shape</span><span class="s3">, </span><span class="s1">axes)</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">keep_names:</span>
          <span class="s1">operand = sum(operand * eye</span><span class="s3">, </span><span class="s1">axes)</span>
          <span class="s1">names = names.replace(name</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">operand = sum(operand * eye</span><span class="s3">, </span><span class="s1">axes[:-</span><span class="s5">1</span><span class="s1">])</span>
          <span class="s1">names = names.replace(name</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">count - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">operand</span><span class="s3">, </span><span class="s1">names</span>

  <span class="s3">def </span><span class="s1">filter_singleton_dims(operand</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">other_shape</span><span class="s3">, </span><span class="s1">other_names):</span>
    <span class="s1">eq = core.symbolic_equal_dim</span>
    <span class="s1">keep = [</span><span class="s3">not </span><span class="s1">eq(operand.shape[i]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">) </span><span class="s3">or </span><span class="s1">j == -</span><span class="s5">1 </span><span class="s3">or </span><span class="s1">eq(other_shape[j]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">enumerate(map(other_names.find</span><span class="s3">, </span><span class="s1">names))]</span>
    <span class="s1">sqez_axes</span><span class="s3">, </span><span class="s1">keep_axes = partition_list(keep</span><span class="s3">, </span><span class="s1">list(range(operand.ndim)))</span>
    <span class="s3">return </span><span class="s1">lax.squeeze(operand</span><span class="s3">, </span><span class="s1">sqez_axes)</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">.join(names[i] </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">keep_axes)</span>

  <span class="s3">for </span><span class="s1">operand_indices</span><span class="s3">, </span><span class="s1">contracted_names_set</span><span class="s3">, </span><span class="s1">einstr </span><span class="s3">in </span><span class="s1">contractions:</span>
    <span class="s1">contracted_names = sorted(contracted_names_set)</span>
    <span class="s1">input_str</span><span class="s3">, </span><span class="s1">result_names = einstr.split(</span><span class="s4">'-&gt;'</span><span class="s1">)</span>
    <span class="s1">input_names = input_str.split(</span><span class="s4">','</span><span class="s1">)</span>

    <span class="s0"># switch on the number of operands to be processed in this loop iteration.</span>
    <span class="s0"># every case here sets 'operand' and 'names'.</span>
    <span class="s3">if </span><span class="s1">len(operand_indices) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">operand = operands.pop(operand_indices[</span><span class="s5">0</span><span class="s1">])</span>
      <span class="s1">names</span><span class="s3">, </span><span class="s1">= input_names</span>
      <span class="s1">counts = collections.Counter(names)</span>

      <span class="s0"># sum out unique contracted indices with a single reduce-sum</span>
      <span class="s1">uniques = [name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">contracted_names </span><span class="s3">if </span><span class="s1">counts[name] == </span><span class="s5">1</span><span class="s1">]</span>
      <span class="s1">operand</span><span class="s3">, </span><span class="s1">names = sum_uniques(operand</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">uniques)</span>

      <span class="s0"># for every repeated index, do a contraction against an identity matrix</span>
      <span class="s1">operand</span><span class="s3">, </span><span class="s1">names = sum_repeats(operand</span><span class="s3">, </span><span class="s1">names</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">, </span><span class="s1">result_names)</span>

    <span class="s3">elif </span><span class="s1">len(operand_indices) == </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs = map(operands.pop</span><span class="s3">, </span><span class="s1">operand_indices)</span>
      <span class="s1">lhs_names</span><span class="s3">, </span><span class="s1">rhs_names = input_names</span>

      <span class="s0"># handle cases where one side of a contracting or batch dimension is 1</span>
      <span class="s0"># but its counterpart is not.</span>
      <span class="s1">lhs</span><span class="s3">, </span><span class="s1">lhs_names = filter_singleton_dims(lhs</span><span class="s3">, </span><span class="s1">lhs_names</span><span class="s3">, </span><span class="s1">shape(rhs)</span><span class="s3">,</span>
                                             <span class="s1">rhs_names)</span>
      <span class="s1">rhs</span><span class="s3">, </span><span class="s1">rhs_names = filter_singleton_dims(rhs</span><span class="s3">, </span><span class="s1">rhs_names</span><span class="s3">, </span><span class="s1">shape(lhs)</span><span class="s3">,</span>
                                             <span class="s1">lhs_names)</span>

      <span class="s1">lhs_counts = collections.Counter(lhs_names)</span>
      <span class="s1">rhs_counts = collections.Counter(rhs_names)</span>

      <span class="s0"># sum out unique contracted indices in lhs and rhs</span>
      <span class="s1">lhs_uniques = [name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">contracted_names</span>
                     <span class="s3">if </span><span class="s1">lhs_counts[name] == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">rhs_counts[name] == </span><span class="s5">0</span><span class="s1">]</span>
      <span class="s1">lhs</span><span class="s3">, </span><span class="s1">lhs_names = sum_uniques(lhs</span><span class="s3">, </span><span class="s1">lhs_names</span><span class="s3">, </span><span class="s1">lhs_uniques)</span>

      <span class="s1">rhs_uniques = [name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">contracted_names</span>
                     <span class="s3">if </span><span class="s1">rhs_counts[name] == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">lhs_counts[name] == </span><span class="s5">0</span><span class="s1">]</span>
      <span class="s1">rhs</span><span class="s3">, </span><span class="s1">rhs_names = sum_uniques(rhs</span><span class="s3">, </span><span class="s1">rhs_names</span><span class="s3">, </span><span class="s1">rhs_uniques)</span>

      <span class="s0"># for every repeated index, contract against an identity matrix</span>
      <span class="s1">lhs</span><span class="s3">, </span><span class="s1">lhs_names = sum_repeats(lhs</span><span class="s3">, </span><span class="s1">lhs_names</span><span class="s3">, </span><span class="s1">lhs_counts</span><span class="s3">,</span>
                                   <span class="s1">result_names + rhs_names)</span>
      <span class="s1">rhs</span><span class="s3">, </span><span class="s1">rhs_names = sum_repeats(rhs</span><span class="s3">, </span><span class="s1">rhs_names</span><span class="s3">, </span><span class="s1">rhs_counts</span><span class="s3">,</span>
                                   <span class="s1">result_names + lhs_names)</span>

      <span class="s1">lhs_or_rhs_names = set(lhs_names) | set(rhs_names)</span>
      <span class="s1">contracted_names = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">contracted_names </span><span class="s3">if </span><span class="s1">x </span><span class="s3">in </span><span class="s1">lhs_or_rhs_names]</span>
      <span class="s1">lhs_and_rhs_names = set(lhs_names) &amp; set(rhs_names)</span>
      <span class="s1">batch_names = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">result_names </span><span class="s3">if </span><span class="s1">x </span><span class="s3">in </span><span class="s1">lhs_and_rhs_names]</span>

      <span class="s1">lhs_batch</span><span class="s3">, </span><span class="s1">rhs_batch = unzip2((lhs_names.find(n)</span><span class="s3">, </span><span class="s1">rhs_names.find(n))</span>
                                    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">batch_names)</span>

      <span class="s0"># NOTE(mattjj): this can fail non-deterministically in python3, maybe</span>
      <span class="s0"># due to opt_einsum</span>
      <span class="s3">assert </span><span class="s1">jax.config.jax_dynamic_shapes </span><span class="s3">or </span><span class="s1">_all(</span>
        <span class="s1">name </span><span class="s3">in </span><span class="s1">lhs_names </span><span class="s3">and </span><span class="s1">name </span><span class="s3">in </span><span class="s1">rhs_names </span><span class="s3">and</span>
        <span class="s1">lhs.shape[lhs_names.index(name)] == rhs.shape[rhs_names.index(name)]</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">contracted_names)</span><span class="s3">, </span><span class="s1">(</span>
          <span class="s4">&quot;Incompatible reduction dimensions: &quot;</span>
          <span class="s4">f&quot;lhs.shape=</span><span class="s3">{</span><span class="s1">lhs.shape</span><span class="s3">} </span><span class="s4">lhs_names=</span><span class="s3">{</span><span class="s1">lhs_names</span><span class="s3">} </span><span class="s4">&quot;</span>
          <span class="s4">f&quot;rhs.shape=</span><span class="s3">{</span><span class="s1">rhs.shape</span><span class="s3">} </span><span class="s4">rhs_names=</span><span class="s3">{</span><span class="s1">rhs_names</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

      <span class="s0"># contract using dot_general</span>
      <span class="s1">batch_names_str = </span><span class="s4">''</span><span class="s1">.join(batch_names)</span>
      <span class="s1">lhs_cont</span><span class="s3">, </span><span class="s1">rhs_cont = unzip2((lhs_names.index(n)</span><span class="s3">, </span><span class="s1">rhs_names.index(n))</span>
                                  <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">contracted_names)</span>
      <span class="s1">deleted_names = batch_names_str + </span><span class="s4">''</span><span class="s1">.join(contracted_names)</span>
      <span class="s1">remaining_lhs_names = _removechars(lhs_names</span><span class="s3">, </span><span class="s1">deleted_names)</span>
      <span class="s1">remaining_rhs_names = _removechars(rhs_names</span><span class="s3">, </span><span class="s1">deleted_names)</span>
      <span class="s0"># Try both orders of lhs and rhs, in the hope that one of them means we</span>
      <span class="s0"># don't need an explicit transpose. opt_einsum likes to contract from</span>
      <span class="s0"># right to left, so we expect (rhs,lhs) to have the best chance of not</span>
      <span class="s0"># needing a transpose.</span>
      <span class="s1">names = batch_names_str + remaining_rhs_names + remaining_lhs_names</span>
      <span class="s3">if </span><span class="s1">names == result_names:</span>
        <span class="s1">dimension_numbers = ((rhs_cont</span><span class="s3">, </span><span class="s1">lhs_cont)</span><span class="s3">, </span><span class="s1">(rhs_batch</span><span class="s3">, </span><span class="s1">lhs_batch))</span>
        <span class="s1">operand = _dot_general(rhs</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">precision)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">names = batch_names_str + remaining_lhs_names + remaining_rhs_names</span>
        <span class="s1">dimension_numbers = ((lhs_cont</span><span class="s3">, </span><span class="s1">rhs_cont)</span><span class="s3">, </span><span class="s1">(lhs_batch</span><span class="s3">, </span><span class="s1">rhs_batch))</span>
        <span class="s1">operand = _dot_general(lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">, </span><span class="s1">dimension_numbers</span><span class="s3">, </span><span class="s1">precision)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">NotImplementedError  </span><span class="s0"># if this is actually reachable, open an issue!</span>

    <span class="s0"># the resulting 'operand' with axis labels 'names' should be a permutation</span>
    <span class="s0"># of the desired result</span>
    <span class="s3">assert </span><span class="s1">len(names) == len(result_names) == len(set(names))</span>
    <span class="s3">assert </span><span class="s1">set(names) == set(result_names)</span>
    <span class="s3">if </span><span class="s1">names != result_names:</span>
      <span class="s1">perm = tuple(names.index(name) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">result_names)</span>
      <span class="s1">operand = lax.transpose(operand</span><span class="s3">, </span><span class="s1">perm)</span>
    <span class="s1">operands.append(operand)  </span><span class="s0"># used in next iteration</span>

  <span class="s3">return </span><span class="s1">operands[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s1">@util._wraps(np.inner</span><span class="s3">, </span><span class="s1">lax_description=_PRECISION_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'precision'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">inner(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">precision=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">ndim(a) == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ndim(b) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">a * b</span>
  <span class="s3">return </span><span class="s1">tensordot(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">precision=precision)</span>


<span class="s1">@util._wraps(np.outer</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">outer(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.outer is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">return </span><span class="s1">ravel(a)[:</span><span class="s3">, None</span><span class="s1">] * ravel(b)[</span><span class="s3">None, </span><span class="s1">:]</span>

<span class="s1">@util._wraps(np.cross)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axisa'</span><span class="s3">, </span><span class="s4">'axisb'</span><span class="s3">, </span><span class="s4">'axisc'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">cross(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axisa: int = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axisb: int = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axisc: int = -</span><span class="s5">1</span><span class="s3">,</span>
          <span class="s1">axis: Optional[int] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">axisa = axis</span>
    <span class="s1">axisb = axis</span>
    <span class="s1">axisc = axis</span>
  <span class="s1">a = moveaxis(a</span><span class="s3">, </span><span class="s1">axisa</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">b = moveaxis(b</span><span class="s3">, </span><span class="s1">axisb</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">a.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">) </span><span class="s3">or </span><span class="s1">b.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Dimension must be either 2 or 3 for cross product&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">a.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">b.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">a[...</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] * b[...</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] - a[...</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] * b[...</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

  <span class="s1">a0 = a[...</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">a1 = a[...</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">a2 = a[...</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] </span><span class="s3">if </span><span class="s1">a.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">3 </span><span class="s3">else </span><span class="s1">zeros_like(a0)</span>
  <span class="s1">b0 = b[...</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">b1 = b[...</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">b2 = b[...</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] </span><span class="s3">if </span><span class="s1">b.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">3 </span><span class="s3">else </span><span class="s1">zeros_like(b0)</span>
  <span class="s1">c = array([a1 * b2 - a2 * b1</span><span class="s3">, </span><span class="s1">a2 * b0 - a0 * b2</span><span class="s3">, </span><span class="s1">a0 * b1 - a1 * b0])</span>
  <span class="s3">return </span><span class="s1">moveaxis(c</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axisc)</span>


<span class="s1">@util._wraps(np.kron)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">kron(a</span><span class="s3">, </span><span class="s1">b):</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">b = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">b)</span>
  <span class="s3">if </span><span class="s1">ndim(a) &lt; ndim(b):</span>
    <span class="s1">a = expand_dims(a</span><span class="s3">, </span><span class="s1">range(ndim(b) - ndim(a)))</span>
  <span class="s3">elif </span><span class="s1">ndim(b) &lt; ndim(a):</span>
    <span class="s1">b = expand_dims(b</span><span class="s3">, </span><span class="s1">range(ndim(a) - ndim(b)))</span>
  <span class="s1">a_reshaped = expand_dims(a</span><span class="s3">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* ndim(a)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
  <span class="s1">b_reshaped = expand_dims(b</span><span class="s3">, </span><span class="s1">range(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">* ndim(b)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>
  <span class="s1">out_shape = tuple(np.multiply(shape(a)</span><span class="s3">, </span><span class="s1">shape(b)))</span>
  <span class="s3">return </span><span class="s1">reshape(lax.mul(a_reshaped</span><span class="s3">, </span><span class="s1">b_reshaped)</span><span class="s3">, </span><span class="s1">out_shape)</span>


<span class="s1">@util._wraps(np.vander)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'N'</span><span class="s3">, </span><span class="s4">'increasing'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">vander(x</span><span class="s3">, </span><span class="s1">N=</span><span class="s3">None, </span><span class="s1">increasing=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;vander&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x = asarray(x)</span>
  <span class="s3">if </span><span class="s1">x.ndim != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x must be a one-dimensional array&quot;</span><span class="s1">)</span>
  <span class="s1">N = x.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">N </span><span class="s3">is None else </span><span class="s1">core.concrete_or_error(</span>
    <span class="s1">operator.index</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s4">&quot;'N' argument of jnp.vander()&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">N &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;N must be nonnegative&quot;</span><span class="s1">)</span>

  <span class="s1">iota = lax.iota(x.dtype</span><span class="s3">, </span><span class="s1">N)</span>
  <span class="s3">if not </span><span class="s1">increasing:</span>
    <span class="s1">iota = lax.sub(_lax_const(iota</span><span class="s3">, </span><span class="s1">N - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">iota)</span>

  <span class="s3">return </span><span class="s1">ufuncs.power(x[...</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">expand_dims(iota</span><span class="s3">, </span><span class="s1">tuple(range(x.ndim))))</span>


<span class="s0">### Misc</span>

<span class="s1">_ARGWHERE_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Because the size of the output of ``argwhere`` is data-dependent, the function is not 
typically compatible with JIT. The JAX version adds the optional ``size`` argument, which 
specifies the size of the leading dimension of the output - it must be specified statically 
for ``jnp.argwhere`` to be compiled with non-static operands. If ``size`` is specified, 
the indices of the first ``size`` True elements will be returned; if there are fewer 
nonzero elements than `size` indicates, the index arrays will be zero-padded. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.argwhere</span><span class="s3">,</span>
  <span class="s1">lax_description=_dedent(</span><span class="s4">&quot;&quot;&quot; 
    Because the size of the output of ``argwhere`` is data-dependent, the function is not 
    typically compatible with JIT. The JAX version adds the optional ``size`` argument which 
    must be specified statically for ``jnp.argwhere`` to be used within some of JAX's 
    transformations.&quot;&quot;&quot;</span><span class="s1">)</span><span class="s3">,</span>
  <span class="s1">extra_params=_dedent(</span><span class="s4">&quot;&quot;&quot; 
    size : int, optional 
        If specified, the indices of the first ``size`` True elements will be returned. If there 
        are fewer results than ``size`` indicates, the return value will be padded with ``fill_value``. 
    fill_value : array_like, optional 
        When ``size`` is specified and there are fewer than the indicated number of elements, the 
        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">argwhere(a</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">size=</span><span class="s3">None, </span><span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">result = transpose(vstack(nonzero(a</span><span class="s3">, </span><span class="s1">size=size</span><span class="s3">, </span><span class="s1">fill_value=fill_value)))</span>
  <span class="s3">if </span><span class="s1">ndim(a) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">result[:</span><span class="s5">0</span><span class="s1">].reshape(result.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">result.reshape(result.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ndim(a))</span>


<span class="s1">@util._wraps(np.argmax</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">argmax(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">keepdims=</span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;argmax&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.argmax is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_argmax(asarray(a)</span><span class="s3">, None if </span><span class="s1">axis </span><span class="s3">is None else </span><span class="s1">operator.index(axis)</span><span class="s3">,</span>
                 <span class="s1">keepdims=bool(keepdims))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'keepdims'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_argmax(a: Array</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">keepdims: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dims = list(range(ndim(a)))</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">dims = [axis]</span>
  <span class="s3">if </span><span class="s1">a.shape[axis] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="s1">)</span>
  <span class="s1">result = lax.argmax(a</span><span class="s3">, </span><span class="s1">_canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">a.ndim)</span><span class="s3">, </span><span class="s1">dtypes.canonicalize_dtype(int_))</span>
  <span class="s3">return </span><span class="s1">expand_dims(result</span><span class="s3">, </span><span class="s1">dims) </span><span class="s3">if </span><span class="s1">keepdims </span><span class="s3">else </span><span class="s1">result</span>

<span class="s1">@util._wraps(np.argmin</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">argmin(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">keepdims=</span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;argmin&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.argmin is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_argmin(asarray(a)</span><span class="s3">, None if </span><span class="s1">axis </span><span class="s3">is None else </span><span class="s1">operator.index(axis)</span><span class="s3">,</span>
                 <span class="s1">keepdims=bool(keepdims))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'keepdims'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_argmin(a: Array</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">keepdims: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">dims = list(range(ndim(a)))</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">dims = [axis]</span>
  <span class="s3">if </span><span class="s1">a.shape[axis] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="s1">)</span>
  <span class="s1">result = lax.argmin(a</span><span class="s3">, </span><span class="s1">_canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">a.ndim)</span><span class="s3">, </span><span class="s1">dtypes.canonicalize_dtype(int_))</span>
  <span class="s3">return </span><span class="s1">expand_dims(result</span><span class="s3">, </span><span class="s1">dims) </span><span class="s3">if </span><span class="s1">keepdims </span><span class="s3">else </span><span class="s1">result</span>


<span class="s1">_NANARG_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Warning: jax.numpy.arg{} returns -1 for all-NaN slices and does not raise 
an error. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.nanargmax</span><span class="s3">, </span><span class="s1">lax_description=_NANARG_DOC.format(</span><span class="s4">&quot;max&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">nanargmax(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out : Any = </span><span class="s3">None, </span><span class="s1">keepdims : Optional[bool] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.nanargmax is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_nanargmax(a</span><span class="s3">, None if </span><span class="s1">axis </span><span class="s3">is None else </span><span class="s1">operator.index(axis)</span><span class="s3">, </span><span class="s1">keepdims=bool(keepdims))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'keepdims'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_nanargmax(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">keepdims: bool = </span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;nanargmax&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">inexact):</span>
    <span class="s3">return </span><span class="s1">argmax(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span>
  <span class="s1">nan_mask = ufuncs.isnan(a)</span>
  <span class="s1">a = where(nan_mask</span><span class="s3">, </span><span class="s1">-inf</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">res = argmax(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span>
  <span class="s3">return </span><span class="s1">where(reductions.all(nan_mask</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">res)</span>

<span class="s1">@util._wraps(np.nanargmin</span><span class="s3">, </span><span class="s1">lax_description=_NANARG_DOC.format(</span><span class="s4">&quot;min&quot;</span><span class="s1">)</span><span class="s3">,  </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">nanargmin(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out : Any = </span><span class="s3">None, </span><span class="s1">keepdims : Optional[bool] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.nanargmin is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_nanargmin(a</span><span class="s3">, None if </span><span class="s1">axis </span><span class="s3">is None else </span><span class="s1">operator.index(axis)</span><span class="s3">, </span><span class="s1">keepdims=bool(keepdims))</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'keepdims'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_nanargmin(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">keepdims : bool = </span><span class="s3">False</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;nanargmin&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">inexact):</span>
    <span class="s3">return </span><span class="s1">argmin(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span>
  <span class="s1">nan_mask = ufuncs.isnan(a)</span>
  <span class="s1">a = where(nan_mask</span><span class="s3">, </span><span class="s1">inf</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">res = argmin(a</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span>
  <span class="s3">return </span><span class="s1">where(reductions.all(nan_mask</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">keepdims=keepdims)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">res)</span>


<span class="s1">@util._wraps(np.sort)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'kind'</span><span class="s3">, </span><span class="s4">'order'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">sort(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">'quicksort'</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;sort&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">kind != </span><span class="s4">'quicksort'</span><span class="s1">:</span>
    <span class="s1">warnings.warn(</span><span class="s4">&quot;'kind' argument to sort is ignored.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">order </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'order' argument to sort is not supported.&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.sort(ravel(a)</span><span class="s3">, </span><span class="s1">dimension=</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.sort(asarray(a)</span><span class="s3">, </span><span class="s1">dimension=_canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">ndim(a)))</span>

<span class="s1">@util._wraps(np.sort_complex)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">sort_complex(a):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;sort_complex&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">a = lax.sort(a</span><span class="s3">, </span><span class="s1">dimension=</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">lax.convert_element_type(a</span><span class="s3">, </span><span class="s1">dtypes.to_complex_dtype(a.dtype))</span>

<span class="s1">@util._wraps(np.lexsort)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">lexsort(keys</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">):</span>
  <span class="s1">keys = tuple(keys)</span>
  <span class="s3">if </span><span class="s1">len(keys) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;need sequence of keys with len &gt; 0 in lexsort&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">len({shape(key) </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys}) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;all keys need to be the same shape&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ndim(keys[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">array(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=dtypes.canonicalize_dtype(int_))</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">ndim(keys[</span><span class="s5">0</span><span class="s1">]))</span>
  <span class="s1">use_64bit_index = keys[</span><span class="s5">0</span><span class="s1">].shape[axis] &gt;= (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s1">)</span>
  <span class="s1">iota = lax.broadcasted_iota(int64 </span><span class="s3">if </span><span class="s1">use_64bit_index </span><span class="s3">else </span><span class="s1">int_</span><span class="s3">, </span><span class="s1">shape(keys[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">axis)</span>
  <span class="s3">return </span><span class="s1">lax.sort((*keys[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">iota)</span><span class="s3">, </span><span class="s1">dimension=axis</span><span class="s3">, </span><span class="s1">num_keys=len(keys))[-</span><span class="s5">1</span><span class="s1">]</span>


<span class="s1">_ARGSORT_DOC = </span><span class="s4">&quot;&quot;&quot; 
Only :code:`kind='stable'` is supported. Other :code:`kind` values will produce 
a warning and be treated as if they were :code:`'stable'`. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.argsort</span><span class="s3">, </span><span class="s1">lax_description=_ARGSORT_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'kind'</span><span class="s3">, </span><span class="s4">'order'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">argsort(a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int] = -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">kind: str = </span><span class="s4">'stable'</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;argsort&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">arr = asarray(a)</span>
  <span class="s3">if </span><span class="s1">kind != </span><span class="s4">'stable'</span><span class="s1">:</span>
    <span class="s1">warnings.warn(</span><span class="s4">&quot;'kind' argument to argsort is ignored; only 'stable' sorts &quot;</span>
                  <span class="s4">&quot;are supported.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">order </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'order' argument to argsort is not supported.&quot;</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">argsort(arr.ravel()</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">axis_num = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim)</span>
    <span class="s1">use_64bit_index = core.is_special_dim_size(arr.shape[axis_num]) </span><span class="s3">or </span><span class="s1">arr.shape[axis_num] &gt;= (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s1">)</span>
    <span class="s1">iota = lax.broadcasted_iota(int64 </span><span class="s3">if </span><span class="s1">use_64bit_index </span><span class="s3">else </span><span class="s1">int_</span><span class="s3">, </span><span class="s1">arr.shape</span><span class="s3">, </span><span class="s1">axis_num)</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">perm = lax.sort_key_val(arr</span><span class="s3">, </span><span class="s1">iota</span><span class="s3">, </span><span class="s1">dimension=axis_num)</span>
    <span class="s3">return </span><span class="s1">perm</span>


<span class="s1">@util._wraps(np.msort)</span>
<span class="s3">def </span><span class="s1">msort(a):</span>
  <span class="s0"># TODO(jakevdp): remove msort after Feb 2023</span>
  <span class="s1">warnings.warn(</span><span class="s4">&quot;jnp.msort is deprecated; use jnp.sort(a, axis=0) instead&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning)</span>
  <span class="s3">return </span><span class="s1">sort(a</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.partition</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot; 
The JAX version requires the ``kth`` argument to be a static integer rather than 
a general array. This is implemented via two calls to :func:`jax.lax.top_k`. If 
you're only accessing the top or bottom k values of the output, it may be more 
efficient to call :func:`jax.lax.top_k` directly. 
 
The JAX version differs from the NumPy version in the treatment of NaN entries; 
NaNs which have the negative bit set are sorted to the beginning of the array. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=[</span><span class="s4">'kth'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">partition(a: ArrayLike</span><span class="s3">, </span><span class="s1">kth: int</span><span class="s3">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s1">) -&gt; Array:</span>
  <span class="s0"># TODO(jakevdp): handle NaN values like numpy.</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;partition&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">arr = asarray(a)</span>
  <span class="s3">if </span><span class="s1">issubdtype(arr.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;jnp.partition for complex dtype is not implemented.&quot;</span><span class="s1">)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim)</span>
  <span class="s1">kth = _canonicalize_axis(kth</span><span class="s3">, </span><span class="s1">arr.shape[axis])</span>

  <span class="s1">arr = swapaxes(arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">bottom = -lax.top_k(-arr</span><span class="s3">, </span><span class="s1">kth + </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">top = lax.top_k(arr</span><span class="s3">, </span><span class="s1">arr.shape[-</span><span class="s5">1</span><span class="s1">] - kth - </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">out = lax.concatenate([bottom</span><span class="s3">, </span><span class="s1">top]</span><span class="s3">, </span><span class="s1">dimension=arr.ndim - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">swapaxes(out</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@util._wraps(np.argpartition</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot; 
The JAX version requires the ``kth`` argument to be a static integer rather than 
a general array. This is implemented via two calls to :func:`jax.lax.top_k`. If 
you're only accessing the top or bottom k values of the output, it may be more 
efficient to call :func:`jax.lax.top_k` directly. 
 
The JAX version differs from the NumPy version in the treatment of NaN entries; 
NaNs which have the negative bit set are sorted to the beginning of the array. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=[</span><span class="s4">'kth'</span><span class="s3">, </span><span class="s4">'axis'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">argpartition(a: ArrayLike</span><span class="s3">, </span><span class="s1">kth: int</span><span class="s3">, </span><span class="s1">axis: int = -</span><span class="s5">1</span><span class="s1">) -&gt; Array:</span>
  <span class="s0"># TODO(jakevdp): handle NaN values like numpy.</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;partition&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">arr = asarray(a)</span>
  <span class="s3">if </span><span class="s1">issubdtype(arr.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;jnp.argpartition for complex dtype is not implemented.&quot;</span><span class="s1">)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">arr.ndim)</span>
  <span class="s1">kth = _canonicalize_axis(kth</span><span class="s3">, </span><span class="s1">arr.shape[axis])</span>

  <span class="s1">arr = swapaxes(arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">bottom_ind = lax.top_k(-arr</span><span class="s3">, </span><span class="s1">kth + </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>

  <span class="s0"># To avoid issues with duplicate values, we compute the top indices via a proxy</span>
  <span class="s1">set_to_zero = </span><span class="s3">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">i: a.at[i].set(</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(arr.ndim - </span><span class="s5">1</span><span class="s1">):</span>
    <span class="s1">set_to_zero = jax.vmap(set_to_zero)</span>
  <span class="s1">proxy = set_to_zero(ones(arr.shape)</span><span class="s3">, </span><span class="s1">bottom_ind)</span>
  <span class="s1">top_ind = lax.top_k(proxy</span><span class="s3">, </span><span class="s1">arr.shape[-</span><span class="s5">1</span><span class="s1">] - kth - </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">out = lax.concatenate([bottom_ind</span><span class="s3">, </span><span class="s1">top_ind]</span><span class="s3">, </span><span class="s1">dimension=arr.ndim - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">swapaxes(out</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnums=(</span><span class="s5">2</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_roll(a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis):</span>
  <span class="s1">a_shape = shape(a)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.reshape(_roll(ravel(a)</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">a_shape)</span>
  <span class="s1">shift = asarray(shift)</span>
  <span class="s1">a_ndim = len(a_shape)</span>
  <span class="s1">axis = np.asarray(axis)</span>
  <span class="s1">b_shape = lax.broadcast_shapes(shift.shape</span><span class="s3">, </span><span class="s1">axis.shape</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s3">if </span><span class="s1">len(b_shape) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">msg = </span><span class="s4">&quot;'shift' and 'axis' arguments to roll must be scalars or 1D arrays&quot;</span>
    <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

  <span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">zip(broadcast_to(shift</span><span class="s3">, </span><span class="s1">b_shape)</span><span class="s3">,</span>
                  <span class="s1">np.broadcast_to(axis</span><span class="s3">, </span><span class="s1">b_shape)):</span>
    <span class="s1">i = _canonicalize_axis(i</span><span class="s3">, </span><span class="s1">a_ndim)</span>
    <span class="s1">a_shape_i = array(a_shape[i]</span><span class="s3">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">x = ufuncs.remainder(lax.convert_element_type(x</span><span class="s3">, </span><span class="s1">np.int32)</span><span class="s3">,</span>
                  <span class="s1">lax.max(a_shape_i</span><span class="s3">, </span><span class="s1">np.int32(</span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s1">a = lax.concatenate((a</span><span class="s3">, </span><span class="s1">a)</span><span class="s3">, </span><span class="s1">i)</span>
    <span class="s1">a = lax.dynamic_slice_in_dim(a</span><span class="s3">, </span><span class="s1">a_shape_i - x</span><span class="s3">, </span><span class="s1">a_shape[i]</span><span class="s3">, </span><span class="s1">axis=i)</span>
  <span class="s3">return </span><span class="s1">a</span>


<span class="s1">@util._wraps(np.roll)</span>
<span class="s3">def </span><span class="s1">roll(a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis: Optional[Union[int</span><span class="s3">, </span><span class="s1">Sequence[int]]] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;roll&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">isinstance(axis</span><span class="s3">, </span><span class="s1">list):</span>
    <span class="s1">axis = tuple(axis)</span>
  <span class="s3">return </span><span class="s1">_roll(a</span><span class="s3">, </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@util._wraps(np.rollaxis</span><span class="s3">, </span><span class="s1">lax_description=_ARRAY_VIEW_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'start'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">rollaxis(a</span><span class="s3">, </span><span class="s1">axis: int</span><span class="s3">, </span><span class="s1">start=</span><span class="s5">0</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;rollaxis&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">start = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s4">&quot;'start' argument of jnp.rollaxis()&quot;</span><span class="s1">)</span>
  <span class="s1">a_ndim = ndim(a)</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">a_ndim)</span>
  <span class="s3">if not </span><span class="s1">(-a_ndim &lt;= start &lt;= a_ndim):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">start=</span><span class="s3">} </span><span class="s4">must satisfy </span><span class="s3">{</span><span class="s1">-a_ndim</span><span class="s3">}</span><span class="s4">&lt;=start&lt;=</span><span class="s3">{</span><span class="s1">a_ndim</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">start &lt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">start += a_ndim</span>
  <span class="s3">if </span><span class="s1">start &gt; axis:</span>
    <span class="s1">start -= </span><span class="s5">1</span>
  <span class="s3">return </span><span class="s1">moveaxis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">start)</span>


<span class="s1">@util._wraps(np.packbits)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'bitorder'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">packbits(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">bitorder=</span><span class="s4">'big'</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;packbits&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if not </span><span class="s1">(issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">integer) </span><span class="s3">or </span><span class="s1">issubdtype(_dtype(a)</span><span class="s3">, </span><span class="s1">bool_)):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Expected an input array of integer or boolean data type'</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">bitorder </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'little'</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'order' must be either 'little' or 'big'&quot;</span><span class="s1">)</span>
  <span class="s1">a = lax.gt(a</span><span class="s3">, </span><span class="s1">_lax_const(a</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)).astype(</span><span class="s4">'uint8'</span><span class="s1">)</span>
  <span class="s1">bits = arange(</span><span class="s5">8</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'uint8'</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">bitorder == </span><span class="s4">'big'</span><span class="s1">:</span>
    <span class="s1">bits = bits[::-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s1">a = swapaxes(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

  <span class="s1">remainder = a.shape[-</span><span class="s5">1</span><span class="s1">] % </span><span class="s5">8</span>
  <span class="s3">if </span><span class="s1">remainder:</span>
    <span class="s1">a = lax.pad(a</span><span class="s3">, </span><span class="s1">np.uint8(</span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">(a.ndim - </span><span class="s5">1</span><span class="s1">) * [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)] + [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">8 </span><span class="s1">- remainder</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)])</span>

  <span class="s1">a = a.reshape(a.shape[:-</span><span class="s5">1</span><span class="s1">] + (a.shape[-</span><span class="s5">1</span><span class="s1">] // </span><span class="s5">8</span><span class="s3">, </span><span class="s5">8</span><span class="s1">))</span>
  <span class="s1">bits = expand_dims(bits</span><span class="s3">, </span><span class="s1">tuple(range(a.ndim - </span><span class="s5">1</span><span class="s1">)))</span>
  <span class="s1">packed = (a &lt;&lt; bits).sum(-</span><span class="s5">1</span><span class="s1">).astype(</span><span class="s4">'uint8'</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">swapaxes(packed</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.unpackbits)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'count'</span><span class="s3">, </span><span class="s4">'bitorder'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">unpackbits(a</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">count=</span><span class="s3">None, </span><span class="s1">bitorder=</span><span class="s4">'big'</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;unpackbits&quot;</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s3">if </span><span class="s1">_dtype(a) != uint8:</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Expected an input array of unsigned byte data type&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">bitorder </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'little'</span><span class="s3">, </span><span class="s4">'big'</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'order' must be either 'little' or 'big'&quot;</span><span class="s1">)</span>
  <span class="s1">bits = asarray(</span><span class="s5">1</span><span class="s1">) &lt;&lt; arange(</span><span class="s5">8</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'uint8'</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">bitorder == </span><span class="s4">'big'</span><span class="s1">:</span>
    <span class="s1">bits = bits[::-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis = </span><span class="s5">0</span>
  <span class="s1">a = swapaxes(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">unpacked = ((a[...</span><span class="s3">, None</span><span class="s1">] &amp; expand_dims(bits</span><span class="s3">, </span><span class="s1">tuple(range(a.ndim)))) &gt; </span><span class="s5">0</span><span class="s1">).astype(</span><span class="s4">'uint8'</span><span class="s1">)</span>
  <span class="s1">unpacked = unpacked.reshape(unpacked.shape[:-</span><span class="s5">2</span><span class="s1">] + (-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))[...</span><span class="s3">, </span><span class="s1">:count]</span>
  <span class="s3">return </span><span class="s1">swapaxes(unpacked</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.take</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot; 
By default, JAX assumes that all indices are in-bounds. Alternative out-of-bound 
index semantics can be specified via the ``mode`` parameter (see below). 
&quot;&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">extra_params=</span><span class="s4">&quot;&quot;&quot; 
mode : string, default=&quot;fill&quot; 
    Out-of-bounds indexing mode. The default mode=&quot;fill&quot; returns invalid values 
    (e.g. NaN) for out-of bounds indices (see also ``fill_value`` below). 
    For more discussion of mode options, see :attr:`jax.numpy.ndarray.at`. 
fill_value : optional 
    The fill value to return for out-of-bounds slices when mode is 'fill'. Ignored 
    otherwise. Defaults to NaN for inexact types, the largest negative value for 
    signed types, the largest positive value for unsigned types, and True for booleans. 
unique_indices : bool, default=False 
    If True, the implementation will assume that the indices are unique, 
    which can result in more efficient execution on some backends. 
indices_are_sorted : bool, default=False 
    If True, the implementation will assume that the indices are sorted in 
    ascending order, which can lead to more efficient execution on some backends. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">take(a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">mode=</span><span class="s3">None,</span>
         <span class="s1">unique_indices=</span><span class="s3">False, </span><span class="s1">indices_are_sorted=</span><span class="s3">False, </span><span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">return </span><span class="s1">_take(a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, None if </span><span class="s1">axis </span><span class="s3">is None else </span><span class="s1">operator.index(axis)</span><span class="s3">, </span><span class="s1">out</span><span class="s3">,</span>
               <span class="s1">mode</span><span class="s3">, </span><span class="s1">unique_indices=unique_indices</span><span class="s3">, </span><span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s3">,</span>
               <span class="s1">fill_value=fill_value)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'unique_indices'</span><span class="s3">, </span><span class="s4">'indices_are_sorted'</span><span class="s3">, </span><span class="s4">'fill_value'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_take(a</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None, </span><span class="s1">mode=</span><span class="s3">None,</span>
          <span class="s1">unique_indices=</span><span class="s3">False, </span><span class="s1">indices_are_sorted=</span><span class="s3">False, </span><span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.take is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;take&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">indices)</span>
  <span class="s1">a = asarray(a)</span>
  <span class="s1">indices = asarray(indices)</span>

  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">a = ravel(a)</span>
    <span class="s1">axis_idx = </span><span class="s5">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">axis_idx = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">ndim(a))</span>

  <span class="s3">if </span><span class="s1">mode </span><span class="s3">is None or </span><span class="s1">mode == </span><span class="s4">&quot;fill&quot;</span><span class="s1">:</span>
    <span class="s1">gather_mode = lax.GatherScatterMode.FILL_OR_DROP</span>
    <span class="s0"># lax.gather() does not support negative indices, so we wrap them here</span>
    <span class="s1">indices = where(indices &lt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">indices + a.shape[axis_idx]</span><span class="s3">, </span><span class="s1">indices)</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;raise&quot;</span><span class="s1">:</span>
    <span class="s0"># TODO(phawkins): we have no way to report out of bounds errors yet.</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'raise' mode to jnp.take is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;wrap&quot;</span><span class="s1">:</span>
    <span class="s1">indices = ufuncs.mod(indices</span><span class="s3">, </span><span class="s1">_lax_const(indices</span><span class="s3">, </span><span class="s1">a.shape[axis_idx]))</span>
    <span class="s1">gather_mode = lax.GatherScatterMode.PROMISE_IN_BOUNDS</span>
  <span class="s3">elif </span><span class="s1">mode == </span><span class="s4">&quot;clip&quot;</span><span class="s1">:</span>
    <span class="s1">gather_mode = lax.GatherScatterMode.CLIP</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid mode '</span><span class="s3">{</span><span class="s1">mode</span><span class="s3">}</span><span class="s4">' for np.take&quot;</span><span class="s1">)</span>

  <span class="s1">index_dims = len(shape(indices))</span>
  <span class="s1">slice_sizes = list(shape(a))</span>
  <span class="s3">if </span><span class="s1">slice_sizes[axis_idx] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">indices.size != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;Cannot do a non-empty jnp.take() from an empty axis.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">a</span>

  <span class="s3">if </span><span class="s1">indices.size == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">out_shape = (slice_sizes[:axis_idx] + list(indices.shape) +</span>
                 <span class="s1">slice_sizes[axis_idx + </span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s3">return </span><span class="s1">full_like(a</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">shape=out_shape)</span>

  <span class="s1">slice_sizes[axis_idx] = </span><span class="s5">1</span>
  <span class="s1">dnums = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=tuple(</span>
      <span class="s1">list(range(axis_idx)) +</span>
      <span class="s1">list(range(axis_idx + index_dims</span><span class="s3">, </span><span class="s1">len(a.shape) + index_dims - </span><span class="s5">1</span><span class="s1">)))</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims=(axis_idx</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">start_index_map=(axis_idx</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s3">return </span><span class="s1">lax.gather(a</span><span class="s3">, </span><span class="s1">indices[...</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dimension_numbers=dnums</span><span class="s3">,</span>
                    <span class="s1">slice_sizes=tuple(slice_sizes)</span><span class="s3">,</span>
                    <span class="s1">mode=gather_mode</span><span class="s3">, </span><span class="s1">unique_indices=unique_indices</span><span class="s3">,</span>
                    <span class="s1">indices_are_sorted=indices_are_sorted</span><span class="s3">, </span><span class="s1">fill_value=fill_value)</span>


<span class="s3">def </span><span class="s1">_normalize_index(index</span><span class="s3">, </span><span class="s1">axis_size):</span>
  <span class="s2">&quot;&quot;&quot;Normalizes an index value in the range [-N, N) to the range [0, N).&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">issubdtype(_dtype(index)</span><span class="s3">, </span><span class="s1">np.unsignedinteger):</span>
    <span class="s3">return </span><span class="s1">index</span>
  <span class="s3">if </span><span class="s1">core.is_constant_dim(axis_size):</span>
    <span class="s1">axis_size_val = _lax_const(index</span><span class="s3">, </span><span class="s1">axis_size)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">axis_size_val = lax.convert_element_type(core.dimension_as_value(axis_size)</span><span class="s3">,</span>
                                             <span class="s1">_dtype(index))</span>
  <span class="s3">if </span><span class="s1">isinstance(index</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">np.integer)):</span>
    <span class="s3">return </span><span class="s1">lax.add(index</span><span class="s3">, </span><span class="s1">axis_size_val) </span><span class="s3">if </span><span class="s1">index &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">index</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.select(index &lt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lax.add(index</span><span class="s3">, </span><span class="s1">axis_size_val)</span><span class="s3">, </span><span class="s1">index)</span>


<span class="s1">TAKE_ALONG_AXIS_DOC = </span><span class="s4">&quot;&quot;&quot; 
Unlike :func:`numpy.take_along_axis`, :func:`jax.numpy.take_along_axis` takes 
an optional ``mode`` parameter controlling how out-of-bounds indices should be 
handled. By default, out-of-bounds indices yield invalid values (e.g., ``NaN``). 
See :attr:`jax.numpy.ndarray.at` for further discussion of out-of-bounds 
indexing in JAX. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.take_along_axis</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False,</span>
        <span class="s1">lax_description=TAKE_ALONG_AXIS_DOC)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'axis'</span><span class="s3">, </span><span class="s4">'mode'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">take_along_axis(arr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">axis: Optional[int]</span><span class="s3">,</span>
                    <span class="s1">mode: Optional[Union[str</span><span class="s3">, </span><span class="s1">lax.GatherScatterMode]] = </span><span class="s3">None</span><span class="s1">):</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;take_along_axis&quot;</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">indices)</span>
  <span class="s1">index_dtype = dtypes.dtype(indices)</span>
  <span class="s3">if not </span><span class="s1">dtypes.issubdtype(index_dtype</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;take_along_axis indices must be of integer type, got &quot;</span>
                    <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">str(index_dtype)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">ndim(indices) != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">msg = </span><span class="s4">&quot;take_along_axis indices must be 1D if axis=None, got shape {}&quot;</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(indices.shape))</span>
    <span class="s3">return </span><span class="s1">take_along_axis(arr.ravel()</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">rank = ndim(arr)</span>
  <span class="s3">if </span><span class="s1">rank != ndim(indices):</span>
    <span class="s1">msg = </span><span class="s4">&quot;indices and arr must have the same number of dimensions; {} vs. {}&quot;</span>
    <span class="s3">raise </span><span class="s1">ValueError(msg.format(ndim(indices)</span><span class="s3">, </span><span class="s1">ndim(arr)))</span>
  <span class="s1">axis = _canonicalize_axis(axis</span><span class="s3">, </span><span class="s1">rank)</span>

  <span class="s3">def </span><span class="s1">replace(tup</span><span class="s3">, </span><span class="s1">val):</span>
    <span class="s1">lst = list(tup)</span>
    <span class="s1">lst[axis] = val</span>
    <span class="s3">return </span><span class="s1">tuple(lst)</span>

  <span class="s1">use_64bit_index = _any([</span><span class="s3">not </span><span class="s1">core.is_constant_dim(d) </span><span class="s3">or </span><span class="s1">d &gt;= (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s1">) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">arr.shape])</span>
  <span class="s1">index_dtype = dtype(int64 </span><span class="s3">if </span><span class="s1">use_64bit_index </span><span class="s3">else </span><span class="s1">int32)</span>
  <span class="s1">indices = lax.convert_element_type(indices</span><span class="s3">, </span><span class="s1">index_dtype)</span>

  <span class="s1">axis_size = arr.shape[axis]</span>
  <span class="s1">arr_shape = replace(arr.shape</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s1">idx_shape = indices.shape</span>
  <span class="s1">out_shape = lax.broadcast_shapes(idx_shape</span><span class="s3">, </span><span class="s1">arr_shape)</span>
  <span class="s3">if </span><span class="s1">axis_size == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">zeros(out_shape</span><span class="s3">, </span><span class="s1">arr.dtype)</span>
  <span class="s1">index_dims = [i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">enumerate(idx_shape) </span><span class="s3">if </span><span class="s1">i == axis </span><span class="s3">or not </span><span class="s1">core.symbolic_equal_dim(idx</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)]</span>

  <span class="s1">gather_index_shape = tuple(np.array(out_shape)[index_dims]) + (</span><span class="s5">1</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s1">gather_indices = []</span>
  <span class="s1">slice_sizes = []</span>
  <span class="s1">offset_dims = []</span>
  <span class="s1">start_index_map = []</span>
  <span class="s1">collapsed_slice_dims = []</span>
  <span class="s1">j = </span><span class="s5">0</span>
  <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(rank):</span>
    <span class="s3">if </span><span class="s1">i == axis:</span>
      <span class="s1">indices = _normalize_index(indices</span><span class="s3">, </span><span class="s1">axis_size)</span>
      <span class="s1">gather_indices.append(lax.reshape(indices</span><span class="s3">, </span><span class="s1">gather_index_shape))</span>
      <span class="s1">slice_sizes.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">start_index_map.append(i)</span>
      <span class="s1">collapsed_slice_dims.append(i)</span>
      <span class="s1">j += </span><span class="s5">1</span>
    <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(idx_shape[i]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s0"># If idx_shape[i] == 1, we can just take the entirety of the arr's axis</span>
      <span class="s0"># and avoid forming an iota index.</span>
      <span class="s1">offset_dims.append(i)</span>
      <span class="s1">slice_sizes.append(arr_shape[i])</span>
    <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(arr_shape[i]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s0"># If the array dimension is 1 but the index dimension is not, we</span>
      <span class="s0"># broadcast the array dimension to the index dimension by repeatedly</span>
      <span class="s0"># gathering the first element.</span>
      <span class="s1">gather_indices.append(zeros(gather_index_shape</span><span class="s3">, </span><span class="s1">dtype=index_dtype))</span>
      <span class="s1">slice_sizes.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">start_index_map.append(i)</span>
      <span class="s1">collapsed_slice_dims.append(i)</span>
      <span class="s1">j += </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># Otherwise, idx_shape[i] == arr_shape[i]. Use an iota index so</span>
      <span class="s0"># corresponding elements of array and index are gathered.</span>
      <span class="s0"># TODO(mattjj): next line needs updating for dynamic shapes</span>
      <span class="s1">iota = lax.broadcasted_iota(index_dtype</span><span class="s3">, </span><span class="s1">gather_index_shape</span><span class="s3">, </span><span class="s1">j)</span>
      <span class="s1">gather_indices.append(iota)</span>
      <span class="s1">slice_sizes.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">start_index_map.append(i)</span>
      <span class="s1">collapsed_slice_dims.append(i)</span>
      <span class="s1">j += </span><span class="s5">1</span>


  <span class="s1">gather_indices_arr = lax.concatenate(gather_indices</span><span class="s3">, </span><span class="s1">dimension=j)</span>
  <span class="s1">dnums = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims=tuple(offset_dims)</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims=tuple(collapsed_slice_dims)</span><span class="s3">,</span>
    <span class="s1">start_index_map=tuple(start_index_map))</span>
  <span class="s3">return </span><span class="s1">lax.gather(arr</span><span class="s3">, </span><span class="s1">gather_indices_arr</span><span class="s3">, </span><span class="s1">dnums</span><span class="s3">, </span><span class="s1">tuple(slice_sizes)</span><span class="s3">,</span>
                    <span class="s1">mode=</span><span class="s4">&quot;fill&quot; </span><span class="s3">if </span><span class="s1">mode </span><span class="s3">is None else </span><span class="s1">mode)</span>

<span class="s0">### Indexing</span>

<span class="s3">def </span><span class="s1">_rewriting_take(arr</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">indices_are_sorted=</span><span class="s3">False, </span><span class="s1">unique_indices=</span><span class="s3">False,</span>
                    <span class="s1">mode=</span><span class="s3">None, </span><span class="s1">fill_value=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s0"># Computes arr[idx].</span>
  <span class="s0"># All supported cases of indexing can be implemented as an XLA gather,</span>
  <span class="s0"># followed by an optional reverse and broadcast_in_dim.</span>

  <span class="s0"># Handle some special cases, falling back if error messages might differ.</span>
  <span class="s3">if </span><span class="s1">(arr.ndim &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">np.integer)) </span><span class="s3">and</span>
      <span class="s3">not </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">(bool</span><span class="s3">, </span><span class="s1">np.bool_)) </span><span class="s3">and </span><span class="s1">isinstance(arr.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int)):</span>
    <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= idx &lt; arr.shape[</span><span class="s5">0</span><span class="s1">]:</span>
      <span class="s0"># Use dynamic rather than static index here to avoid slow repeated execution:</span>
      <span class="s0"># See https://github.com/google/jax/issues/12198</span>
      <span class="s3">return </span><span class="s1">lax.dynamic_index_in_dim(arr</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">False</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">(arr.ndim &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">isinstance(arr.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and</span>
      <span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">slice) </span><span class="s3">and</span>
      <span class="s1">(type(idx.start) </span><span class="s3">is </span><span class="s1">int </span><span class="s3">or </span><span class="s1">idx.start </span><span class="s3">is None</span><span class="s1">) </span><span class="s3">and</span>
      <span class="s1">(type(idx.stop)  </span><span class="s3">is </span><span class="s1">int </span><span class="s3">or </span><span class="s1">idx.stop </span><span class="s3">is  None</span><span class="s1">) </span><span class="s3">and</span>
      <span class="s1">(type(idx.step)  </span><span class="s3">is </span><span class="s1">int </span><span class="s3">or </span><span class="s1">idx.step </span><span class="s3">is  None</span><span class="s1">)):</span>
    <span class="s1">n = arr.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">start = idx.start </span><span class="s3">if </span><span class="s1">idx.start </span><span class="s3">is not None else </span><span class="s5">0</span>
    <span class="s1">stop  = idx.stop  </span><span class="s3">if </span><span class="s1">idx.stop  </span><span class="s3">is not None else </span><span class="s1">n</span>
    <span class="s1">step  = idx.step  </span><span class="s3">if </span><span class="s1">idx.step  </span><span class="s3">is not None else </span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= start &lt; n </span><span class="s3">and </span><span class="s5">0 </span><span class="s1">&lt;= stop &lt;= n </span><span class="s3">and </span><span class="s5">0 </span><span class="s1">&lt; step </span><span class="s3">and</span>
        <span class="s1">(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step) != (</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)):</span>
      <span class="s3">if </span><span class="s1">_any(isinstance(d</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">arr.shape[</span><span class="s5">1</span><span class="s1">:]):</span>
        <span class="s3">if </span><span class="s1">step == </span><span class="s5">1</span><span class="s1">:  </span><span class="s0"># TODO(mattjj, sharadmv): handle step != 1</span>
          <span class="s3">return </span><span class="s1">lax.dynamic_slice_in_dim(arr</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">_max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">stop - start)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s3">elif </span><span class="s1">step == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s0"># Use dynamic rather than static slice here to avoid slow repeated execution:</span>
        <span class="s0"># See https://github.com/google/jax/issues/12198</span>
        <span class="s3">return </span><span class="s1">lax.dynamic_slice_in_dim(arr</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">_max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">stop - start)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">lax.slice_in_dim(arr</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)</span>

  <span class="s0"># TODO(mattjj,dougalm): expand dynamic shape indexing support</span>
  <span class="s3">if </span><span class="s1">jax.config.jax_dynamic_shapes </span><span class="s3">and </span><span class="s1">arr.ndim &gt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">try</span><span class="s1">: aval = core.get_aval(idx)</span>
    <span class="s3">except</span><span class="s1">: </span><span class="s3">pass</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(isinstance(aval</span><span class="s3">, </span><span class="s1">core.DShapedArray) </span><span class="s3">and </span><span class="s1">aval.shape == () </span><span class="s3">and</span>
          <span class="s1">dtypes.issubdtype(aval.dtype</span><span class="s3">, </span><span class="s1">np.integer) </span><span class="s3">and</span>
          <span class="s3">not </span><span class="s1">dtypes.issubdtype(aval.dtype</span><span class="s3">, </span><span class="s1">dtypes.bool_) </span><span class="s3">and</span>
          <span class="s1">isinstance(arr.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int)):</span>
        <span class="s3">return </span><span class="s1">lax.dynamic_index_in_dim(arr</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">False</span><span class="s1">)</span>

  <span class="s1">treedef</span><span class="s3">, </span><span class="s1">static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx = _split_index_for_jit(idx</span><span class="s3">, </span><span class="s1">arr.shape)</span>
  <span class="s3">return </span><span class="s1">_gather(arr</span><span class="s3">, </span><span class="s1">treedef</span><span class="s3">, </span><span class="s1">static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx</span><span class="s3">, </span><span class="s1">indices_are_sorted</span><span class="s3">,</span>
                 <span class="s1">unique_indices</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">fill_value)</span>

<span class="s0"># TODO(phawkins): re-enable jit after fixing excessive recompilation for</span>
<span class="s0"># slice indexes (e.g., slice(0, 5, None), slice(10, 15, None), etc.).</span>
<span class="s0"># @partial(jit, static_argnums=(1, 2))</span>
<span class="s3">def </span><span class="s1">_gather(arr</span><span class="s3">, </span><span class="s1">treedef</span><span class="s3">, </span><span class="s1">static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx</span><span class="s3">, </span><span class="s1">indices_are_sorted</span><span class="s3">,</span>
            <span class="s1">unique_indices</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">fill_value):</span>
  <span class="s1">idx = _merge_static_and_dynamic_indices(treedef</span><span class="s3">, </span><span class="s1">static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx)</span>
  <span class="s1">indexer = _index_to_gather(shape(arr)</span><span class="s3">, </span><span class="s1">idx)  </span><span class="s0"># shared with _scatter_update</span>
  <span class="s1">y = arr</span>

  <span class="s3">if </span><span class="s1">fill_value </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">core.concrete_or_error(</span><span class="s3">None, </span><span class="s1">fill_value</span><span class="s3">,</span>
                           <span class="s4">&quot;fill_value argument to indexed get()&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">np.ndim(fill_value) != </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;fill_value argument to indexed get() must be a scalar&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">isinstance(fill_value</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
      <span class="s1">fill_value = fill_value.item()</span>

  <span class="s0"># Avoid calling gather if the slice shape is empty, both as a fast path and to</span>
  <span class="s0"># handle cases like zeros(0)[array([], int32)].</span>
  <span class="s3">if </span><span class="s1">core.is_empty_shape(indexer.slice_shape):</span>
    <span class="s3">return </span><span class="s1">zeros_like(y</span><span class="s3">, </span><span class="s1">shape=indexer.slice_shape)</span>

  <span class="s0"># We avoid generating a gather when indexer.gather_indices.size is empty.</span>
  <span class="s3">if not </span><span class="s1">core.is_empty_shape(indexer.gather_indices.shape):</span>
    <span class="s1">y = lax.gather(</span>
      <span class="s1">y</span><span class="s3">, </span><span class="s1">indexer.gather_indices</span><span class="s3">, </span><span class="s1">indexer.dnums</span><span class="s3">, </span><span class="s1">indexer.gather_slice_shape</span><span class="s3">,</span>
      <span class="s1">unique_indices=unique_indices </span><span class="s3">or </span><span class="s1">indexer.unique_indices</span><span class="s3">,</span>
      <span class="s1">indices_are_sorted=indices_are_sorted </span><span class="s3">or </span><span class="s1">indexer.indices_are_sorted</span><span class="s3">,</span>
      <span class="s1">mode=mode</span><span class="s3">, </span><span class="s1">fill_value=fill_value)</span>

  <span class="s0"># Reverses axes with negative strides.</span>
  <span class="s3">if </span><span class="s1">indexer.reversed_y_dims:</span>
    <span class="s1">y = lax.rev(y</span><span class="s3">, </span><span class="s1">indexer.reversed_y_dims)</span>

  <span class="s0"># This adds np.newaxis/None dimensions.</span>
  <span class="s3">return </span><span class="s1">expand_dims(y</span><span class="s3">, </span><span class="s1">indexer.newaxis_dims)</span>

<span class="s3">class </span><span class="s1">_Indexer(NamedTuple):</span>
  <span class="s0"># The expected shape of the slice output.</span>
  <span class="s1">slice_shape: Sequence[int]</span>
  <span class="s0"># The slice shape to pass to lax.gather().</span>
  <span class="s1">gather_slice_shape: Sequence[int]</span>
  <span class="s0"># The gather indices to use.</span>
  <span class="s1">gather_indices: ArrayLike</span>
  <span class="s0"># A GatherDimensionNumbers object describing the gather to perform.</span>
  <span class="s1">dnums: lax.GatherDimensionNumbers</span>

  <span class="s0"># Are the gather_indices known to be non-overlapping and/or sorted?</span>
  <span class="s0"># (In practice, these translate to &quot;there no advanced indices&quot;, because</span>
  <span class="s0"># only advanced indices could lead to index repetition.)</span>
  <span class="s1">unique_indices: bool</span>
  <span class="s1">indices_are_sorted: bool</span>

  <span class="s0"># Slice dimensions that have negative strides, and so must be reversed after</span>
  <span class="s0"># the gather.</span>
  <span class="s1">reversed_y_dims: Sequence[int]</span>

  <span class="s0"># Keep track of any axes created by `newaxis`. These must be inserted for</span>
  <span class="s0"># gathers and eliminated for scatters.</span>
  <span class="s1">newaxis_dims: Sequence[int]</span>


<span class="s3">def </span><span class="s1">_split_index_for_jit(idx</span><span class="s3">, </span><span class="s1">shape):</span>
  <span class="s2">&quot;&quot;&quot;Splits indices into necessarily-static and dynamic parts. 
 
  Used to pass indices into `jit`-ted function. 
  &quot;&quot;&quot;</span>
  <span class="s0"># Convert list indices to tuples in cases (deprecated by NumPy.)</span>
  <span class="s1">idx = _eliminate_deprecated_list_indexing(idx)</span>
  <span class="s3">if </span><span class="s1">any(isinstance(i</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">idx):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;JAX does not support string indexing; got </span><span class="s3">{</span><span class="s1">idx=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

  <span class="s0"># Expand any (concrete) boolean indices. We can then use advanced integer</span>
  <span class="s0"># indexing logic to handle them.</span>
  <span class="s1">idx = _expand_bool_indices(idx</span><span class="s3">, </span><span class="s1">shape)</span>

  <span class="s1">leaves</span><span class="s3">, </span><span class="s1">treedef = tree_flatten(idx)</span>
  <span class="s1">dynamic = [</span><span class="s3">None</span><span class="s1">] * len(leaves)</span>
  <span class="s1">static = [</span><span class="s3">None</span><span class="s1">] * len(leaves)</span>
  <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s3">in </span><span class="s1">enumerate(leaves):</span>
    <span class="s3">if </span><span class="s1">x </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
      <span class="s1">static[i] = x</span>
    <span class="s3">elif </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">slice):</span>
      <span class="s0"># slice objects aren't hashable.</span>
      <span class="s1">static[i] = (x.start</span><span class="s3">, </span><span class="s1">x.stop</span><span class="s3">, </span><span class="s1">x.step)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">dynamic[i] = x</span>
  <span class="s3">return </span><span class="s1">treedef</span><span class="s3">, </span><span class="s1">tuple(static)</span><span class="s3">, </span><span class="s1">dynamic</span>

<span class="s3">def </span><span class="s1">_merge_static_and_dynamic_indices(treedef</span><span class="s3">, </span><span class="s1">static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx):</span>
  <span class="s2">&quot;&quot;&quot;Recombines indices that were split by _split_index_for_jit.&quot;&quot;&quot;</span>
  <span class="s1">idx = []</span>
  <span class="s3">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">zip(static_idx</span><span class="s3">, </span><span class="s1">dynamic_idx):</span>
    <span class="s3">if </span><span class="s1">d </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">idx.append(d)</span>
    <span class="s3">elif </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">tuple):</span>
      <span class="s1">idx.append(slice(s[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">s[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">s[</span><span class="s5">2</span><span class="s1">]))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">idx.append(s)</span>
  <span class="s3">return </span><span class="s1">treedef.unflatten(idx)</span>

<span class="s3">def </span><span class="s1">_int(aval):</span>
  <span class="s3">return not </span><span class="s1">aval.shape </span><span class="s3">and </span><span class="s1">issubdtype(aval.dtype</span><span class="s3">, </span><span class="s1">integer)</span>

<span class="s3">def </span><span class="s1">_index_to_gather(x_shape: Sequence[int]</span><span class="s3">, </span><span class="s1">idx: Sequence[Any]</span><span class="s3">,</span>
                     <span class="s1">normalize_indices: bool = </span><span class="s3">True</span><span class="s1">) -&gt; _Indexer:</span>
  <span class="s0"># Remove ellipses and add trailing slice(None)s.</span>
  <span class="s1">idx = _canonicalize_tuple_index(len(x_shape)</span><span class="s3">, </span><span class="s1">idx)</span>

  <span class="s0"># Check for advanced indexing:</span>
  <span class="s0"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>

  <span class="s0"># Do the advanced indexing axes appear contiguously? If not, NumPy semantics</span>
  <span class="s0"># move the advanced axes to the front.</span>
  <span class="s1">advanced_axes_are_contiguous = </span><span class="s3">False</span>

  <span class="s1">advanced_indexes: Optional[Sequence[Union[Array</span><span class="s3">, </span><span class="s1">np.ndarray]]] = </span><span class="s3">None</span>

  <span class="s0"># The positions of the advanced indexing axes in `idx`.</span>
  <span class="s1">idx_advanced_axes: Sequence[int] = []</span>

  <span class="s0"># The positions of the advanced indexes in x's shape.</span>
  <span class="s0"># collapsed, after None axes have been removed. See below.</span>
  <span class="s1">x_advanced_axes: Optional[Sequence[int]] = </span><span class="s3">None</span>

  <span class="s3">if </span><span class="s1">_is_advanced_int_indexer(idx):</span>
    <span class="s1">idx_no_nones = [(i</span><span class="s3">, </span><span class="s1">d) </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(idx) </span><span class="s3">if </span><span class="s1">d </span><span class="s3">is not None</span><span class="s1">]</span>
    <span class="s1">advanced_pairs = (</span>
      <span class="s1">(asarray(e)</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j) </span><span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">e) </span><span class="s3">in </span><span class="s1">enumerate(idx_no_nones)</span>
      <span class="s3">if </span><span class="s1">isscalar(e) </span><span class="s3">or </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">(Sequence</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">np.ndarray)))</span>
    <span class="s3">if </span><span class="s1">normalize_indices:</span>
      <span class="s1">advanced_pairs = ((_normalize_index(e</span><span class="s3">, </span><span class="s1">x_shape[j])</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j)</span>
                        <span class="s3">for </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">advanced_pairs)</span>
    <span class="s1">advanced_indexes</span><span class="s3">, </span><span class="s1">idx_advanced_axes</span><span class="s3">, </span><span class="s1">x_advanced_axes = zip(*advanced_pairs)</span>
    <span class="s1">advanced_axes_are_contiguous = bool(np.all(np.diff(idx_advanced_axes) == </span><span class="s5">1</span><span class="s1">))</span>

  <span class="s1">x_axis = </span><span class="s5">0  </span><span class="s0"># Current axis in x.</span>
  <span class="s1">y_axis = </span><span class="s5">0  </span><span class="s0"># Current axis in y, before collapsing. See below.</span>
  <span class="s1">collapsed_y_axis = </span><span class="s5">0  </span><span class="s0"># Current axis in y, after collapsing.</span>

  <span class="s0"># Scatter dimension numbers.</span>
  <span class="s1">offset_dims: Sequence[int] = []</span>
  <span class="s1">collapsed_slice_dims: Sequence[int] = []</span>
  <span class="s1">start_index_map: Sequence[int] = []</span>

  <span class="s1">use_64bit_index = _any([</span><span class="s3">not </span><span class="s1">core.is_constant_dim(d) </span><span class="s3">or </span><span class="s1">d &gt;= (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s1">) </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">x_shape])</span>
  <span class="s1">index_dtype = int64 </span><span class="s3">if </span><span class="s1">use_64bit_index </span><span class="s3">else </span><span class="s1">int32</span>

  <span class="s0"># Gather indices.</span>
  <span class="s0"># Pairs of (array, start_dim) values. These will be broadcast into</span>
  <span class="s0"># gather_indices_shape, with the array dimensions aligned to start_dim, and</span>
  <span class="s0"># then concatenated.</span>
  <span class="s1">gather_indices: List[Tuple[Array</span><span class="s3">, </span><span class="s1">int]] = []</span>
  <span class="s1">gather_indices_shape: List[int] = []</span>

  <span class="s0"># We perform three transformations to y before the scatter op, in order:</span>
  <span class="s0"># First, y is broadcast to slice_shape. In general `y` only need broadcast to</span>
  <span class="s0"># the right shape.</span>
  <span class="s1">slice_shape: Sequence[int] = []</span>

  <span class="s0"># Next, y is squeezed to remove newaxis_dims. This removes np.newaxis/`None`</span>
  <span class="s0"># indices, which the scatter cannot remove itself.</span>
  <span class="s1">newaxis_dims: Sequence[int] = []</span>

  <span class="s0"># Finally, we reverse reversed_y_dims to handle slices with negative strides.</span>
  <span class="s1">reversed_y_dims: Sequence[int] = []</span>

  <span class="s1">gather_slice_shape: Sequence[int] = []</span>

  <span class="s3">for </span><span class="s1">idx_pos</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">enumerate(idx):</span>
    <span class="s0"># Handle the advanced indices here if:</span>
    <span class="s0"># * the advanced indices were not contiguous and we are the start.</span>
    <span class="s0"># * we are at the position of the first advanced index.</span>
    <span class="s3">if </span><span class="s1">(advanced_indexes </span><span class="s3">is not None and</span>
        <span class="s1">(advanced_axes_are_contiguous </span><span class="s3">and </span><span class="s1">idx_pos == idx_advanced_axes[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">or</span>
         <span class="s3">not </span><span class="s1">advanced_axes_are_contiguous </span><span class="s3">and </span><span class="s1">idx_pos == </span><span class="s5">0</span><span class="s1">)):</span>
      <span class="s1">advanced_indexes = broadcast_arrays(*advanced_indexes)</span>
      <span class="s1">shape = advanced_indexes[</span><span class="s5">0</span><span class="s1">].shape</span>
      <span class="s1">ndim = len(shape)</span>

      <span class="s1">start_dim = len(gather_indices_shape)</span>
      <span class="s1">gather_indices += ((lax.convert_element_type(a</span><span class="s3">, </span><span class="s1">index_dtype)</span><span class="s3">, </span><span class="s1">start_dim)</span>
                         <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">advanced_indexes)</span>
      <span class="s1">gather_indices_shape += shape</span>

      <span class="s1">start_index_map.extend(x_advanced_axes)</span>
      <span class="s1">collapsed_slice_dims.extend(x_advanced_axes)</span>
      <span class="s1">slice_shape.extend(shape)</span>
      <span class="s1">y_axis += ndim</span>
      <span class="s1">collapsed_y_axis += ndim</span>

    <span class="s0"># Per-index bookkeeping for advanced indexes.</span>
    <span class="s3">if </span><span class="s1">idx_pos </span><span class="s3">in </span><span class="s1">idx_advanced_axes:</span>
      <span class="s1">x_axis += </span><span class="s5">1</span>
      <span class="s1">gather_slice_shape.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s3">continue</span>

    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">abstract_i = core.get_aval(i)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s1">abstract_i = </span><span class="s3">None</span>
    <span class="s0"># Handle basic int indexes.</span>
    <span class="s3">if </span><span class="s1">isinstance(abstract_i</span><span class="s3">, </span><span class="s1">(ConcreteArray</span><span class="s3">, </span><span class="s1">ShapedArray)) </span><span class="s3">and </span><span class="s1">_int(abstract_i):</span>
      <span class="s3">if </span><span class="s1">core.symbolic_equal_dim(x_shape[x_axis]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0"># XLA gives error when indexing into an axis of size 0</span>
        <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">f&quot;index is out of bounds for axis </span><span class="s3">{</span><span class="s1">x_axis</span><span class="s3">} </span><span class="s4">with size 0&quot;</span><span class="s1">)</span>
      <span class="s1">i = _normalize_index(i</span><span class="s3">, </span><span class="s1">x_shape[x_axis]) </span><span class="s3">if </span><span class="s1">normalize_indices </span><span class="s3">else </span><span class="s1">i</span>
      <span class="s1">i = lax.convert_element_type(i</span><span class="s3">, </span><span class="s1">index_dtype)</span>
      <span class="s1">gather_indices.append((i</span><span class="s3">, </span><span class="s1">len(gather_indices_shape)))</span>
      <span class="s1">collapsed_slice_dims.append(x_axis)</span>
      <span class="s1">gather_slice_shape.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">start_index_map.append(x_axis)</span>
      <span class="s1">x_axis += </span><span class="s5">1</span>
    <span class="s0"># Handle np.newaxis (None)</span>
    <span class="s3">elif </span><span class="s1">i </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">slice_shape.append(</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">newaxis_dims.append(y_axis)</span>
      <span class="s1">y_axis += </span><span class="s5">1</span>

    <span class="s3">elif </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">slice):</span>
      <span class="s0"># Normalize the slice to use None when possible</span>
      <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step = i.start</span><span class="s3">, </span><span class="s1">i.stop</span><span class="s3">, </span><span class="s1">i.step</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">step </span><span class="s3">is None or </span><span class="s1">core.symbolic_equal_dim(step</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
          <span class="s1">step = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">step </span><span class="s3">is None</span><span class="s1">:</span>
          <span class="s3">if </span><span class="s1">start </span><span class="s3">is None or </span><span class="s1">core.symbolic_equal_dim(start</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">start = </span><span class="s3">None</span>
          <span class="s3">if </span><span class="s1">stop </span><span class="s3">is None or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">isinstance(stop</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">and</span>
              <span class="s1">core.greater_equal_dim(stop</span><span class="s3">, </span><span class="s1">x_shape[x_axis])):</span>
            <span class="s1">stop = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">core.symbolic_equal_dim(step</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
          <span class="s1">step = -</span><span class="s5">1</span>
      <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">core.InconclusiveDimensionOperation):</span>
        <span class="s3">pass</span>

      <span class="s0"># Handle slice(None) and slice(None, None, -1)</span>
      <span class="s3">if </span><span class="s1">start </span><span class="s3">is None and </span><span class="s1">stop </span><span class="s3">is None and </span><span class="s1">(</span>
          <span class="s1">step </span><span class="s3">is None or </span><span class="s1">isinstance(step</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and </span><span class="s1">step == -</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">step == -</span><span class="s5">1</span><span class="s1">:</span>
          <span class="s1">reversed_y_dims.append(collapsed_y_axis)</span>
        <span class="s1">slice_shape.append(x_shape[x_axis])</span>
        <span class="s1">gather_slice_shape.append(x_shape[x_axis])</span>
        <span class="s1">offset_dims.append(collapsed_y_axis)</span>
        <span class="s1">collapsed_y_axis += </span><span class="s5">1</span>
        <span class="s1">y_axis += </span><span class="s5">1</span>
        <span class="s1">x_axis += </span><span class="s5">1</span>
      <span class="s0"># Handle slice index (only static, otherwise an error is raised)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">_all(_is_slice_element_none_or_constant(elt)</span>
                    <span class="s3">for </span><span class="s1">elt </span><span class="s3">in </span><span class="s1">(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)):</span>
          <span class="s1">msg = (</span><span class="s4">&quot;Array slice indices must have static start/stop/step to be used &quot;</span>
                 <span class="s4">&quot;with NumPy indexing syntax. &quot;</span>
                 <span class="s4">f&quot;Found slice(</span><span class="s3">{</span><span class="s1">start</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">stop</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">step</span><span class="s3">}</span><span class="s4">). &quot;</span>
                 <span class="s4">&quot;To index a statically sized &quot;</span>
                 <span class="s4">&quot;array at a dynamic position, try lax.dynamic_slice/&quot;</span>
                 <span class="s4">&quot;dynamic_update_slice (JAX does not support dynamically sized &quot;</span>
                 <span class="s4">&quot;arrays within JIT compiled functions).&quot;</span><span class="s1">)</span>
          <span class="s3">raise </span><span class="s1">IndexError(msg)</span>
        <span class="s3">if not </span><span class="s1">core.is_constant_dim(x_shape[x_axis]):</span>
          <span class="s1">msg = (</span><span class="s4">&quot;Cannot use NumPy slice indexing on an array dimension whose &quot;</span>
                 <span class="s4">f&quot;size is not statically known (</span><span class="s3">{</span><span class="s1">x_shape[x_axis]</span><span class="s3">}</span><span class="s4">). &quot;</span>
                 <span class="s4">&quot;Try using lax.dynamic_slice/dynamic_update_slice&quot;</span><span class="s1">)</span>
          <span class="s3">raise </span><span class="s1">IndexError(msg)</span>
        <span class="s1">start</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">, </span><span class="s1">needs_rev = _static_idx(slice(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)</span><span class="s3">,</span>
                                                      <span class="s1">x_shape[x_axis])</span>
        <span class="s3">if </span><span class="s1">needs_rev:</span>
          <span class="s1">reversed_y_dims.append(collapsed_y_axis)</span>
        <span class="s3">if </span><span class="s1">stride == </span><span class="s5">1</span><span class="s1">:</span>
          <span class="s1">i = lax.convert_element_type(start</span><span class="s3">, </span><span class="s1">index_dtype)</span>
          <span class="s1">gather_indices.append((i</span><span class="s3">, </span><span class="s1">len(gather_indices_shape)))</span>
          <span class="s1">slice_shape.append(limit - start)</span>
          <span class="s1">gather_slice_shape.append(limit - start)</span>
          <span class="s1">offset_dims.append(collapsed_y_axis)</span>
          <span class="s1">start_index_map.append(x_axis)</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">i = arange(start</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">stride</span><span class="s3">, </span><span class="s1">dtype=index_dtype)</span>
          <span class="s1">size = i.shape[</span><span class="s5">0</span><span class="s1">]</span>
          <span class="s1">slice_shape.append(size)</span>
          <span class="s1">gather_slice_shape.append(</span><span class="s5">1</span><span class="s1">)</span>
          <span class="s1">gather_indices.append((i</span><span class="s3">, </span><span class="s1">len(gather_indices_shape)))</span>
          <span class="s1">gather_indices_shape.append(size)</span>

          <span class="s1">start_index_map.append(x_axis)</span>
          <span class="s1">collapsed_slice_dims.append(x_axis)</span>

        <span class="s1">collapsed_y_axis += </span><span class="s5">1</span>
        <span class="s1">y_axis += </span><span class="s5">1</span>
        <span class="s1">x_axis += </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(abstract_i </span><span class="s3">is not None and</span>
          <span class="s3">not </span><span class="s1">(issubdtype(abstract_i.dtype</span><span class="s3">, </span><span class="s1">integer) </span><span class="s3">or </span><span class="s1">issubdtype(abstract_i.dtype</span><span class="s3">, </span><span class="s1">bool_))):</span>
        <span class="s1">msg = (</span><span class="s4">&quot;Indexer must have integer or boolean type, got indexer &quot;</span>
               <span class="s4">&quot;with type {} at position {}, indexer value {}&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">TypeError(msg.format(abstract_i.dtype.name</span><span class="s3">, </span><span class="s1">idx_pos</span><span class="s3">, </span><span class="s1">i))</span>

      <span class="s1">msg = </span><span class="s4">&quot;Indexing mode not yet supported. Open a feature request!</span><span class="s3">\n</span><span class="s4">{}&quot;</span>
      <span class="s3">raise </span><span class="s1">IndexError(msg.format(idx))</span>

  <span class="s3">if </span><span class="s1">len(gather_indices) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">gather_indices_array: ArrayLike = np.zeros((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=index_dtype)</span>
  <span class="s3">elif </span><span class="s1">len(gather_indices) == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">g</span><span class="s3">, </span><span class="s1">_ = gather_indices[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">gather_indices_array = lax.expand_dims(g</span><span class="s3">, </span><span class="s1">(g.ndim</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">last_dim = len(gather_indices_shape)</span>
    <span class="s1">gather_indices_shape.append(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">gather_indices_array = lax.concatenate([</span>
      <span class="s1">lax.broadcast_in_dim(g</span><span class="s3">, </span><span class="s1">gather_indices_shape</span><span class="s3">, </span><span class="s1">tuple(range(i</span><span class="s3">, </span><span class="s1">i + g.ndim)))</span>
      <span class="s3">for </span><span class="s1">g</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">gather_indices]</span><span class="s3">,</span>
      <span class="s1">last_dim)</span>

  <span class="s1">dnums = lax.GatherDimensionNumbers(</span>
    <span class="s1">offset_dims = tuple(offset_dims)</span><span class="s3">,</span>
    <span class="s1">collapsed_slice_dims = tuple(sorted(collapsed_slice_dims))</span><span class="s3">,</span>
    <span class="s1">start_index_map = tuple(start_index_map)</span>
  <span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_Indexer(</span>
    <span class="s1">slice_shape=slice_shape</span><span class="s3">,</span>
    <span class="s1">newaxis_dims=tuple(newaxis_dims)</span><span class="s3">,</span>
    <span class="s1">gather_slice_shape=gather_slice_shape</span><span class="s3">,</span>
    <span class="s1">reversed_y_dims=reversed_y_dims</span><span class="s3">,</span>
    <span class="s1">dnums=dnums</span><span class="s3">,</span>
    <span class="s1">gather_indices=gather_indices_array</span><span class="s3">,</span>
    <span class="s1">unique_indices=advanced_indexes </span><span class="s3">is None,</span>
    <span class="s1">indices_are_sorted=advanced_indexes </span><span class="s3">is None</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_should_unpack_list_index(x):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _eliminate_deprecated_list_indexing.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">(isinstance(x</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array)) </span><span class="s3">and </span><span class="s1">np.ndim(x) != </span><span class="s5">0</span>
          <span class="s3">or </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">(Sequence</span><span class="s3">, </span><span class="s1">slice))</span>
          <span class="s3">or </span><span class="s1">x </span><span class="s3">is </span><span class="s1">Ellipsis </span><span class="s3">or </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_eliminate_deprecated_list_indexing(idx):</span>
  <span class="s0"># &quot;Basic slicing is initiated if the selection object is a non-array,</span>
  <span class="s0"># non-tuple sequence containing slice objects, [Ellipses, or newaxis</span>
  <span class="s0"># objects]&quot;. Detects this and raises a TypeError.</span>
  <span class="s3">if not </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">tuple):</span>
    <span class="s3">if </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">Sequence) </span><span class="s3">and not </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">(Array</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">str)):</span>
      <span class="s0"># As of numpy 1.16, some non-tuple sequences of indices result in a warning, while</span>
      <span class="s0"># others are converted to arrays, based on a set of somewhat convoluted heuristics</span>
      <span class="s0"># (See https://github.com/numpy/numpy/blob/v1.19.2/numpy/core/src/multiarray/mapping.c#L179-L343)</span>
      <span class="s0"># In JAX, we raise an informative TypeError for *all* non-tuple sequences.</span>
      <span class="s3">if </span><span class="s1">_any(_should_unpack_list_index(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">idx):</span>
        <span class="s1">msg = (</span><span class="s4">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s4">&quot;use `arr[tuple(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s4">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">msg = (</span><span class="s4">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s4">&quot;use `arr[array(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s4">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">TypeError(msg)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">idx = (idx</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">idx</span>

<span class="s3">def </span><span class="s1">_is_boolean_index(i):</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">abstract_i = core.get_aval(i)</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s1">abstract_i = </span><span class="s3">None</span>
  <span class="s3">return </span><span class="s1">(isinstance(abstract_i</span><span class="s3">, </span><span class="s1">ShapedArray) </span><span class="s3">and </span><span class="s1">issubdtype(abstract_i.dtype</span><span class="s3">, </span><span class="s1">bool_)</span>
          <span class="s3">or </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">list) </span><span class="s3">and </span><span class="s1">i </span><span class="s3">and </span><span class="s1">_all(_is_scalar(e)</span>
          <span class="s3">and </span><span class="s1">issubdtype(_dtype(e)</span><span class="s3">, </span><span class="s1">np.bool_) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">i))</span>

<span class="s3">def </span><span class="s1">_expand_bool_indices(idx</span><span class="s3">, </span><span class="s1">shape):</span>
  <span class="s2">&quot;&quot;&quot;Converts concrete bool indexes into advanced integer indexes.&quot;&quot;&quot;</span>
  <span class="s1">out = []</span>
  <span class="s1">total_dims = len(shape)</span>
  <span class="s1">num_ellipsis = _sum(e </span><span class="s3">is </span><span class="s1">Ellipsis </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">idx)</span>
  <span class="s3">if </span><span class="s1">num_ellipsis &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;an index can only have a single ellipsis ('...')&quot;</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">num_ellipsis == </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">total_dims = _sum(_ndim(e) </span><span class="s3">if </span><span class="s1">_is_boolean_index(e) </span><span class="s3">else </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">idx</span>
                      <span class="s3">if </span><span class="s1">e </span><span class="s3">is not None and </span><span class="s1">e </span><span class="s3">is not </span><span class="s1">Ellipsis)</span>
  <span class="s1">ellipsis_offset = </span><span class="s5">0</span>
  <span class="s3">for </span><span class="s1">dim_number</span><span class="s3">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">enumerate(idx):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">abstract_i = core.get_aval(i)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s1">abstract_i = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">_is_boolean_index(i):</span>
      <span class="s3">if </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s1">i = array(i)</span>
        <span class="s1">abstract_i = core.get_aval(i)</span>

      <span class="s3">if not </span><span class="s1">type(abstract_i) </span><span class="s3">is </span><span class="s1">ConcreteArray:</span>
        <span class="s0"># TODO(mattjj): improve this error by tracking _why_ the indices are not concrete</span>
        <span class="s3">raise </span><span class="s1">errors.NonConcreteBooleanIndexError(abstract_i)</span>
      <span class="s3">elif </span><span class="s1">_ndim(i) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;JAX arrays do not support boolean scalar indices&quot;</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">i_shape = _shape(i)</span>
        <span class="s1">start = len(out) + ellipsis_offset</span>
        <span class="s1">expected_shape = shape[start: start + _ndim(i)]</span>
        <span class="s3">if </span><span class="s1">i_shape != expected_shape:</span>
          <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;boolean index did not match shape of indexed array in index &quot;</span>
                           <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">dim_number</span><span class="s3">}</span><span class="s4">: got </span><span class="s3">{</span><span class="s1">i_shape</span><span class="s3">}</span><span class="s4">, expected </span><span class="s3">{</span><span class="s1">expected_shape</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">out.extend(np.where(i))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">out.append(i)</span>
    <span class="s3">if </span><span class="s1">i </span><span class="s3">is </span><span class="s1">Ellipsis:</span>
      <span class="s1">ellipsis_offset = len(shape) - total_dims - </span><span class="s5">1</span>
  <span class="s3">return </span><span class="s1">tuple(out)</span>


<span class="s3">def </span><span class="s1">_is_slice_element_none_or_constant(elt):</span>
  <span class="s2">&quot;&quot;&quot;Return True if elt is a constant or None.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">elt </span><span class="s3">is None</span><span class="s1">: </span><span class="s3">return True</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">type(core.get_aval(elt)) </span><span class="s3">is </span><span class="s1">ConcreteArray</span>
  <span class="s3">except </span><span class="s1">TypeError:</span>
    <span class="s3">return False</span>

<span class="s0"># TODO(mattjj): clean up this logic</span>
<span class="s3">def </span><span class="s1">_is_advanced_int_indexer(idx):</span>
  <span class="s2">&quot;&quot;&quot;Returns True if idx should trigger int array indexing, False otherwise.&quot;&quot;&quot;</span>
  <span class="s0"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>
  <span class="s3">assert </span><span class="s1">isinstance(idx</span><span class="s3">, </span><span class="s1">tuple)</span>
  <span class="s3">if </span><span class="s1">_all(e </span><span class="s3">is None or </span><span class="s1">e </span><span class="s3">is </span><span class="s1">Ellipsis </span><span class="s3">or </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">slice)</span>
          <span class="s3">or </span><span class="s1">_is_scalar(e) </span><span class="s3">and </span><span class="s1">issubdtype(_dtype(e)</span><span class="s3">, </span><span class="s1">np.integer) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">idx):</span>
    <span class="s3">return False</span>
  <span class="s3">return </span><span class="s1">_all(e </span><span class="s3">is None or </span><span class="s1">e </span><span class="s3">is </span><span class="s1">Ellipsis </span><span class="s3">or </span><span class="s1">isinstance(e</span><span class="s3">, </span><span class="s1">slice)</span>
              <span class="s3">or </span><span class="s1">_is_int_arraylike(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">idx)</span>

<span class="s3">def </span><span class="s1">_is_int_arraylike(x):</span>
  <span class="s2">&quot;&quot;&quot;Returns True if x is array-like with integer dtype, False otherwise.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">(isinstance(x</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and not </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">bool)</span>
          <span class="s3">or </span><span class="s1">issubdtype(getattr(x</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.integer)</span>
          <span class="s3">or </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple)) </span><span class="s3">and </span><span class="s1">_all(_is_int_arraylike(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">x))</span>

<span class="s3">def </span><span class="s1">_is_scalar(x):</span>
  <span class="s2">&quot;&quot;&quot;Checks if a Python or NumPy scalar.&quot;&quot;&quot;</span>
  <span class="s3">return  </span><span class="s1">np.isscalar(x) </span><span class="s3">or </span><span class="s1">(isinstance(x</span><span class="s3">, </span><span class="s1">(np.ndarray</span><span class="s3">, </span><span class="s1">Array))</span>
                             <span class="s3">and </span><span class="s1">np.ndim(x) == </span><span class="s5">0</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_canonicalize_tuple_index(arr_ndim</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">array_name=</span><span class="s4">'array'</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Helper to remove Ellipsis and add in the implicit trailing slice(None).&quot;&quot;&quot;</span>
  <span class="s1">len_without_none = _sum(</span><span class="s5">1 </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">idx </span><span class="s3">if </span><span class="s1">e </span><span class="s3">is not None and </span><span class="s1">e </span><span class="s3">is not </span><span class="s1">Ellipsis)</span>
  <span class="s3">if </span><span class="s1">len_without_none &gt; arr_ndim:</span>
    <span class="s3">raise </span><span class="s1">IndexError(</span>
        <span class="s4">f&quot;Too many indices for </span><span class="s3">{</span><span class="s1">array_name</span><span class="s3">}</span><span class="s4">: </span><span class="s3">{</span><span class="s1">len_without_none</span><span class="s3">} </span><span class="s4">&quot;</span>
        <span class="s4">f&quot;non-None/Ellipsis indices for dim </span><span class="s3">{</span><span class="s1">arr_ndim</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>
  <span class="s1">ellipses = (i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">elt </span><span class="s3">in </span><span class="s1">enumerate(idx) </span><span class="s3">if </span><span class="s1">elt </span><span class="s3">is </span><span class="s1">Ellipsis)</span>
  <span class="s1">ellipsis_index = next(ellipses</span><span class="s3">, None</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ellipsis_index </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">next(ellipses</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">IndexError(</span>
          <span class="s4">f&quot;Multiple ellipses (...) not supported: </span><span class="s3">{</span><span class="s1">list(map(type</span><span class="s3">, </span><span class="s1">idx))</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>
    <span class="s1">colons = (slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) * (arr_ndim - len_without_none)</span>
    <span class="s1">idx = idx[:ellipsis_index] + colons + idx[ellipsis_index + </span><span class="s5">1</span><span class="s1">:]</span>
  <span class="s3">elif </span><span class="s1">len_without_none &lt; arr_ndim:</span>
    <span class="s1">colons = (slice(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">,</span><span class="s1">) * (arr_ndim - len_without_none)</span>
    <span class="s1">idx = tuple(idx) + colons</span>
  <span class="s3">return </span><span class="s1">idx</span>

<span class="s3">def </span><span class="s1">_static_idx(idx: slice</span><span class="s3">, </span><span class="s1">size: DimSize):</span>
  <span class="s2">&quot;&quot;&quot;Helper function to compute the static slice start/limit/stride values.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">isinstance(size</span><span class="s3">, </span><span class="s1">int):</span>
    <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step = idx.indices(size)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">TypeError(size)</span>

  <span class="s3">if </span><span class="s1">(step &lt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">stop &gt;= start) </span><span class="s3">or </span><span class="s1">(step &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">start &gt;= stop):</span>
    <span class="s3">return </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, False  </span><span class="s0"># sliced to size zero</span>

  <span class="s3">if </span><span class="s1">step &gt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">, False</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">k  = (start - stop - </span><span class="s5">1</span><span class="s1">) % (-step)</span>
    <span class="s3">return </span><span class="s1">stop + k + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">start + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">-step</span><span class="s3">, True</span>


<span class="s1">@util._wraps(np.blackman)</span>
<span class="s3">def </span><span class="s1">blackman(M: int) -&gt; Array:</span>
  <span class="s1">M = core.concrete_or_error(int</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s4">&quot;M argument of jnp.blackman&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
  <span class="s3">if </span><span class="s1">M &lt;= </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">ones(M</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">n = lax.iota(dtype</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s3">return </span><span class="s5">0.42 </span><span class="s1">- </span><span class="s5">0.5 </span><span class="s1">* ufuncs.cos(</span><span class="s5">2 </span><span class="s1">* pi * n / (M - </span><span class="s5">1</span><span class="s1">)) + </span><span class="s5">0.08 </span><span class="s1">* ufuncs.cos(</span><span class="s5">4 </span><span class="s1">* pi * n / (M - </span><span class="s5">1</span><span class="s1">))</span>


<span class="s1">@util._wraps(np.bartlett)</span>
<span class="s3">def </span><span class="s1">bartlett(M: int) -&gt; Array:</span>
  <span class="s1">M = core.concrete_or_error(int</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s4">&quot;M argument of jnp.bartlett&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
  <span class="s3">if </span><span class="s1">M &lt;= </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">ones(M</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">n = lax.iota(dtype</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s3">return </span><span class="s5">1 </span><span class="s1">- ufuncs.abs(</span><span class="s5">2 </span><span class="s1">* n + </span><span class="s5">1 </span><span class="s1">- M) / (M - </span><span class="s5">1</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.hamming)</span>
<span class="s3">def </span><span class="s1">hamming(M: int) -&gt; Array:</span>
  <span class="s1">M = core.concrete_or_error(int</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s4">&quot;M argument of jnp.hamming&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
  <span class="s3">if </span><span class="s1">M &lt;= </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">ones(M</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">n = lax.iota(dtype</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s3">return </span><span class="s5">0.54 </span><span class="s1">- </span><span class="s5">0.46 </span><span class="s1">* ufuncs.cos(</span><span class="s5">2 </span><span class="s1">* pi * n / (M - </span><span class="s5">1</span><span class="s1">))</span>


<span class="s1">@util._wraps(np.hanning)</span>
<span class="s3">def </span><span class="s1">hanning(M: int) -&gt; Array:</span>
  <span class="s1">M = core.concrete_or_error(int</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s4">&quot;M argument of jnp.hanning&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
  <span class="s3">if </span><span class="s1">M &lt;= </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">ones(M</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">n = lax.iota(dtype</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- ufuncs.cos(</span><span class="s5">2 </span><span class="s1">* pi * n / (M - </span><span class="s5">1</span><span class="s1">)))</span>


<span class="s1">@util._wraps(np.kaiser)</span>
<span class="s3">def </span><span class="s1">kaiser(M: int</span><span class="s3">, </span><span class="s1">beta: ArrayLike) -&gt; Array:</span>
  <span class="s1">M = core.concrete_or_error(int</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s4">&quot;M argument of jnp.kaiser&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.canonicalize_dtype(float_)</span>
  <span class="s3">if </span><span class="s1">M &lt;= </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">ones(M</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">n = lax.iota(dtype</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s1">alpha = </span><span class="s5">0.5 </span><span class="s1">* (M - </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">i0(beta * ufuncs.sqrt(</span><span class="s5">1 </span><span class="s1">- ((n - alpha) / alpha) ** </span><span class="s5">2</span><span class="s1">)) / i0(beta)</span>


<span class="s3">def </span><span class="s1">_gcd_cond_fn(xs: Tuple[Array</span><span class="s3">, </span><span class="s1">Array]) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = xs</span>
  <span class="s3">return </span><span class="s1">reductions.any(x2 != </span><span class="s5">0</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_gcd_body_fn(xs: Tuple[Array</span><span class="s3">, </span><span class="s1">Array]) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = xs</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = (where(x2 != </span><span class="s5">0</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">x1)</span><span class="s3">,</span>
            <span class="s1">where(x2 != </span><span class="s5">0</span><span class="s3">, </span><span class="s1">lax.rem(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">_lax_const(x2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)))</span>
  <span class="s3">return </span><span class="s1">(where(x1 &lt; x2</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">x1)</span><span class="s3">, </span><span class="s1">where(x1 &lt; x2</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2))</span>

<span class="s1">@util._wraps(np.gcd</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">gcd(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;gcd&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = util.promote_dtypes(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(x1)</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Arguments to jax.numpy.gcd must be integers.&quot;</span><span class="s1">)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = broadcast_arrays(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">gcd</span><span class="s3">, </span><span class="s1">_ = lax.while_loop(_gcd_cond_fn</span><span class="s3">, </span><span class="s1">_gcd_body_fn</span><span class="s3">, </span><span class="s1">(ufuncs.abs(x1)</span><span class="s3">, </span><span class="s1">ufuncs.abs(x2)))</span>
  <span class="s3">return </span><span class="s1">gcd</span>


<span class="s1">@util._wraps(np.lcm</span><span class="s3">, </span><span class="s1">module=</span><span class="s4">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">lcm(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;lcm&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = util.promote_dtypes(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = ufuncs.abs(x1)</span><span class="s3">, </span><span class="s1">ufuncs.abs(x2)</span>
  <span class="s3">if not </span><span class="s1">issubdtype(_dtype(x1)</span><span class="s3">, </span><span class="s1">integer):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Arguments to jax.numpy.lcm must be integers.&quot;</span><span class="s1">)</span>
  <span class="s1">d = gcd(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">where(d == </span><span class="s5">0</span><span class="s3">, </span><span class="s1">_lax_const(d</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
               <span class="s1">ufuncs.multiply(x1</span><span class="s3">, </span><span class="s1">ufuncs.floor_divide(x2</span><span class="s3">, </span><span class="s1">d)))</span>


<span class="s1">@util._wraps(np.extract)</span>
<span class="s3">def </span><span class="s1">extract(condition: ArrayLike</span><span class="s3">, </span><span class="s1">arr: ArrayLike) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">compress(ravel(condition)</span><span class="s3">, </span><span class="s1">ravel(arr))</span>


<span class="s1">@util._wraps(np.compress</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'out'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">compress(condition: ArrayLike</span><span class="s3">, </span><span class="s1">a: ArrayLike</span><span class="s3">, </span><span class="s1">axis: Optional[int] = </span><span class="s3">None,</span>
             <span class="s1">out: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;compress&quot;</span><span class="s3">, </span><span class="s1">condition</span><span class="s3">, </span><span class="s1">a)</span>
  <span class="s1">condition_arr = asarray(condition).astype(bool)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;The 'out' argument to jnp.compress is not supported.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">condition_arr.ndim != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;condition must be a 1D array&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">axis = </span><span class="s5">0</span>
    <span class="s1">arr = ravel(a)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">arr = moveaxis(a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">condition_arr</span><span class="s3">, </span><span class="s1">extra = condition_arr[:arr.shape[</span><span class="s5">0</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">condition_arr[arr.shape[</span><span class="s5">0</span><span class="s1">]:]</span>
  <span class="s3">if </span><span class="s1">reductions.any(extra):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;condition contains entries that are out of bounds&quot;</span><span class="s1">)</span>
  <span class="s1">arr = arr[:condition_arr.shape[</span><span class="s5">0</span><span class="s1">]]</span>
  <span class="s3">return </span><span class="s1">moveaxis(arr[condition_arr]</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis)</span>


<span class="s1">@util._wraps(np.cov)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'rowvar'</span><span class="s3">, </span><span class="s4">'bias'</span><span class="s3">, </span><span class="s4">'ddof'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">cov(m: ArrayLike</span><span class="s3">, </span><span class="s1">y: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">rowvar: bool = </span><span class="s3">True,</span>
        <span class="s1">bias: bool = </span><span class="s3">False, </span><span class="s1">ddof: Optional[int] = </span><span class="s3">None,</span>
        <span class="s1">fweights: Optional[ArrayLike] = </span><span class="s3">None,</span>
        <span class="s1">aweights: Optional[ArrayLike] = </span><span class="s3">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">y </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">y = util.promote_args_inexact(</span><span class="s4">&quot;cov&quot;</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s3">if </span><span class="s1">y.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;y has more than 2 dimensions&quot;</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">= util.promote_args_inexact(</span><span class="s4">&quot;cov&quot;</span><span class="s3">, </span><span class="s1">m)</span>

  <span class="s3">if </span><span class="s1">m.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;m has more than 2 dimensions&quot;</span><span class="s1">)  </span><span class="s0"># same as numpy error</span>

  <span class="s1">X = atleast_2d(m)</span>
  <span class="s3">if not </span><span class="s1">rowvar </span><span class="s3">and </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">X = X.T</span>
  <span class="s3">if </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">array([]).reshape(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

  <span class="s3">if </span><span class="s1">y </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">y_arr = atleast_2d(y)</span>
    <span class="s3">if not </span><span class="s1">rowvar </span><span class="s3">and </span><span class="s1">y_arr.shape[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">y_arr = y_arr.T</span>
    <span class="s1">X = concatenate((X</span><span class="s3">, </span><span class="s1">y_arr)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ddof </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">ddof = </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">bias == </span><span class="s5">0 </span><span class="s3">else </span><span class="s5">0</span>

  <span class="s1">w: Optional[Array] = </span><span class="s3">None</span>
  <span class="s3">if </span><span class="s1">fweights </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;cov&quot;</span><span class="s3">, </span><span class="s1">fweights)</span>
    <span class="s3">if </span><span class="s1">ndim(fweights) &gt; </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;cannot handle multidimensional fweights&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">shape(fweights)[</span><span class="s5">0</span><span class="s1">] != X.shape[</span><span class="s5">1</span><span class="s1">]:</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;incompatible numbers of samples and fweights&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">issubdtype(_dtype(fweights)</span><span class="s3">, </span><span class="s1">integer):</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;fweights must be integer.&quot;</span><span class="s1">)</span>
    <span class="s0"># Ensure positive fweights; note that numpy raises an error on negative fweights.</span>
    <span class="s1">w = asarray(ufuncs.abs(fweights))</span>
  <span class="s3">if </span><span class="s1">aweights </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">util.check_arraylike(</span><span class="s4">&quot;cov&quot;</span><span class="s3">, </span><span class="s1">aweights)</span>
    <span class="s3">if </span><span class="s1">ndim(aweights) &gt; </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;cannot handle multidimensional aweights&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">shape(aweights)[</span><span class="s5">0</span><span class="s1">] != X.shape[</span><span class="s5">1</span><span class="s1">]:</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;incompatible numbers of samples and aweights&quot;</span><span class="s1">)</span>
    <span class="s0"># Ensure positive aweights: note that numpy raises an error for negative aweights.</span>
    <span class="s1">aweights = ufuncs.abs(aweights)</span>
    <span class="s1">w = asarray(aweights) </span><span class="s3">if </span><span class="s1">w </span><span class="s3">is None else </span><span class="s1">w * asarray(aweights)</span>

  <span class="s1">avg</span><span class="s3">, </span><span class="s1">w_sum = reductions.average(X</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">weights=w</span><span class="s3">, </span><span class="s1">returned=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s1">w_sum = w_sum[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">f = X.shape[</span><span class="s5">1</span><span class="s1">] - ddof</span>
  <span class="s3">elif </span><span class="s1">ddof == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s1">f = w_sum</span>
  <span class="s3">elif </span><span class="s1">aweights </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">f = w_sum - ddof</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">f = w_sum - ddof * reductions.sum(w * aweights) / w_sum</span>

  <span class="s1">X = X - avg[:</span><span class="s3">, None</span><span class="s1">]</span>
  <span class="s1">X_T = X.T </span><span class="s3">if </span><span class="s1">w </span><span class="s3">is None else </span><span class="s1">(X * lax.broadcast_to_rank(w</span><span class="s3">, </span><span class="s1">X.ndim)).T</span>
  <span class="s3">return </span><span class="s1">ufuncs.true_divide(dot(X</span><span class="s3">, </span><span class="s1">X_T.conj())</span><span class="s3">, </span><span class="s1">f).squeeze()</span>


<span class="s1">@util._wraps(np.corrcoef)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'rowvar'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">corrcoef(x: ArrayLike</span><span class="s3">, </span><span class="s1">y: Optional[ArrayLike] = </span><span class="s3">None, </span><span class="s1">rowvar: bool = </span><span class="s3">True</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;corrcoef&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">c = cov(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">rowvar)</span>
  <span class="s3">if </span><span class="s1">len(shape(c)) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s0"># scalar - this should yield nan for values (nan/nan, inf/inf, 0/0), 1 otherwise</span>
    <span class="s3">return </span><span class="s1">ufuncs.divide(c</span><span class="s3">, </span><span class="s1">c)</span>
  <span class="s1">d = diag(c)</span>
  <span class="s1">stddev = ufuncs.sqrt(ufuncs.real(d)).astype(c.dtype)</span>
  <span class="s1">c = c / stddev[:</span><span class="s3">, None</span><span class="s1">] / stddev[</span><span class="s3">None, </span><span class="s1">:]</span>

  <span class="s1">real_part = clip(ufuncs.real(c)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">iscomplexobj(c):</span>
    <span class="s1">complex_part = clip(ufuncs.imag(c)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">c = lax.complex(real_part</span><span class="s3">, </span><span class="s1">complex_part)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">c = real_part</span>
  <span class="s3">return </span><span class="s1">c</span>


<span class="s1">@partial(vectorize</span><span class="s3">, </span><span class="s1">excluded={</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s1">})</span>
<span class="s3">def </span><span class="s1">_searchsorted_via_scan(sorted_arr: Array</span><span class="s3">, </span><span class="s1">query: Array</span><span class="s3">, </span><span class="s1">side: str</span><span class="s3">, </span><span class="s1">dtype: type) -&gt; Array:</span>
  <span class="s1">op = _sort_le_comparator </span><span class="s3">if </span><span class="s1">side == </span><span class="s4">'left' </span><span class="s3">else </span><span class="s1">_sort_lt_comparator</span>
  <span class="s3">def </span><span class="s1">body_fun(_</span><span class="s3">, </span><span class="s1">state):</span>
    <span class="s1">low</span><span class="s3">, </span><span class="s1">high = state</span>
    <span class="s1">mid = (low + high) // </span><span class="s5">2</span>
    <span class="s1">go_left = op(query</span><span class="s3">, </span><span class="s1">sorted_arr[mid])</span>
    <span class="s3">return </span><span class="s1">(where(go_left</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">mid)</span><span class="s3">, </span><span class="s1">where(go_left</span><span class="s3">, </span><span class="s1">mid</span><span class="s3">, </span><span class="s1">high))</span>
  <span class="s1">n_levels = int(np.ceil(np.log2(len(sorted_arr) + </span><span class="s5">1</span><span class="s1">)))</span>
  <span class="s1">init = (dtype(</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype(len(sorted_arr)))</span>
  <span class="s3">return </span><span class="s1">lax.fori_loop(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_levels</span><span class="s3">, </span><span class="s1">body_fun</span><span class="s3">, </span><span class="s1">init)[</span><span class="s5">1</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_searchsorted_via_sort(sorted_arr: Array</span><span class="s3">, </span><span class="s1">query: Array</span><span class="s3">, </span><span class="s1">side: str</span><span class="s3">, </span><span class="s1">dtype: type) -&gt; Array:</span>
  <span class="s1">working_dtype = int32 </span><span class="s3">if </span><span class="s1">sorted_arr.size + query.size &lt; np.iinfo(np.int32).max </span><span class="s3">else </span><span class="s1">int64</span>
  <span class="s3">def </span><span class="s1">_rank(x):</span>
    <span class="s1">idx = lax.iota(working_dtype</span><span class="s3">, </span><span class="s1">len(x))</span>
    <span class="s3">return </span><span class="s1">zeros_like(idx).at[argsort(x)].set(idx)</span>
  <span class="s1">query_flat = query.ravel()</span>
  <span class="s3">if </span><span class="s1">side == </span><span class="s4">'left'</span><span class="s1">:</span>
    <span class="s1">index = _rank(lax.concatenate([query_flat</span><span class="s3">, </span><span class="s1">sorted_arr]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))[:query.size]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">index = _rank(lax.concatenate([sorted_arr</span><span class="s3">, </span><span class="s1">query_flat]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))[sorted_arr.size:]</span>
  <span class="s3">return </span><span class="s1">lax.reshape(lax.sub(index</span><span class="s3">, </span><span class="s1">_rank(query_flat))</span><span class="s3">, </span><span class="s1">np.shape(query)).astype(dtype)</span>


<span class="s3">def </span><span class="s1">_searchsorted_via_compare_all(sorted_arr: Array</span><span class="s3">, </span><span class="s1">query: Array</span><span class="s3">, </span><span class="s1">side: str</span><span class="s3">, </span><span class="s1">dtype: type) -&gt; Array:</span>
  <span class="s1">op = _sort_lt_comparator </span><span class="s3">if </span><span class="s1">side == </span><span class="s4">'left' </span><span class="s3">else </span><span class="s1">_sort_le_comparator</span>
  <span class="s1">comparisons = jax.vmap(op</span><span class="s3">, </span><span class="s1">in_axes=(</span><span class="s5">0</span><span class="s3">, None</span><span class="s1">))(sorted_arr</span><span class="s3">, </span><span class="s1">query)</span>
  <span class="s3">return </span><span class="s1">comparisons.sum(dtype=dtype</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.searchsorted</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s4">'sorter'</span><span class="s1">]</span><span class="s3">,</span>
  <span class="s1">extra_params=_dedent(</span><span class="s4">&quot;&quot;&quot; 
    method : str 
        One of 'scan' (default), 'sort' or 'compare_all'. Controls the method used by the 
        implementation: 'scan' tends to be more performant on CPU (particularly when ``a`` is 
        very large), 'sort' is often more performant on accelerator backends like GPU and TPU 
        (particularly when ``v`` is very large), and 'compare_all' can be most performant 
        when ``a`` is very small.&quot;&quot;&quot;</span><span class="s1">))</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'side'</span><span class="s3">, </span><span class="s4">'sorter'</span><span class="s3">, </span><span class="s4">'method'</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">searchsorted(a: ArrayLike</span><span class="s3">, </span><span class="s1">v: ArrayLike</span><span class="s3">, </span><span class="s1">side: str = </span><span class="s4">'left'</span><span class="s3">,</span>
                 <span class="s1">sorter: </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">method: str = </span><span class="s4">'scan'</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;searchsorted&quot;</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s3">if </span><span class="s1">side </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'right'</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">side</span><span class="s3">!r} </span><span class="s4">is an invalid value for keyword 'side'. &quot;</span>
                     <span class="s4">&quot;Expected one of ['left', 'right'].&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'scan'</span><span class="s3">, </span><span class="s4">'sort'</span><span class="s3">, </span><span class="s4">'compare_all'</span><span class="s1">]:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">method</span><span class="s3">!r} </span><span class="s4">is an invalid value for keyword 'method'. &quot;</span>
                     <span class="s4">&quot;Expected one of ['sort', 'scan', 'compare_all'].&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">sorter </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;sorter is not implemented&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">ndim(a) != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;a should be 1-dimensional&quot;</span><span class="s1">)</span>
  <span class="s1">a</span><span class="s3">, </span><span class="s1">v = util.promote_dtypes(a</span><span class="s3">, </span><span class="s1">v)</span>
  <span class="s1">dtype = int32 </span><span class="s3">if </span><span class="s1">len(a) &lt;= np.iinfo(np.int32).max </span><span class="s3">else </span><span class="s1">int64</span>
  <span class="s3">if </span><span class="s1">len(a) == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">zeros_like(v</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">impl = {</span>
      <span class="s4">'scan'</span><span class="s1">: _searchsorted_via_scan</span><span class="s3">,</span>
      <span class="s4">'sort'</span><span class="s1">: _searchsorted_via_sort</span><span class="s3">,</span>
      <span class="s4">'compare_all'</span><span class="s1">: _searchsorted_via_compare_all</span><span class="s3">,</span>
  <span class="s1">}[method]</span>
  <span class="s3">return </span><span class="s1">impl(asarray(a)</span><span class="s3">, </span><span class="s1">asarray(v)</span><span class="s3">, </span><span class="s1">side</span><span class="s3">, </span><span class="s1">dtype)</span>

<span class="s1">@util._wraps(np.digitize)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=(</span><span class="s4">'right'</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">digitize(x: ArrayLike</span><span class="s3">, </span><span class="s1">bins: ArrayLike</span><span class="s3">, </span><span class="s1">right: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;digitize&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">bins)</span>
  <span class="s1">right = core.concrete_or_error(bool</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s4">&quot;right argument of jnp.digitize()&quot;</span><span class="s1">)</span>
  <span class="s1">bins_arr = asarray(bins)</span>
  <span class="s3">if </span><span class="s1">bins_arr.ndim != </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;digitize: bins must be a 1-dimensional array; got </span><span class="s3">{</span><span class="s1">bins=</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">bins_arr.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">zeros(x</span><span class="s3">, </span><span class="s1">dtype=dtypes.canonicalize_dtype(int_))</span>
  <span class="s1">side = </span><span class="s4">'right' </span><span class="s3">if not </span><span class="s1">right </span><span class="s3">else </span><span class="s4">'left'</span>
  <span class="s3">return </span><span class="s1">where(</span>
    <span class="s1">bins_arr[-</span><span class="s5">1</span><span class="s1">] &gt;= bins_arr[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">searchsorted(bins_arr</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side=side)</span><span class="s3">,</span>
    <span class="s1">len(bins_arr) - searchsorted(bins_arr[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">side=side)</span>
  <span class="s1">)</span>

<span class="s1">_PIECEWISE_DOC = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">Unlike `np.piecewise`, :py:func:`jax.numpy.piecewise` requires functions in 
`funclist` to be traceable by JAX, as it is implemented via :func:`jax.lax.switch`. 
See the :func:`jax.lax.switch` documentation for more information. 
&quot;&quot;&quot;</span>

<span class="s1">@util._wraps(np.piecewise</span><span class="s3">, </span><span class="s1">lax_description=_PIECEWISE_DOC)</span>
<span class="s3">def </span><span class="s1">piecewise(x: ArrayLike</span><span class="s3">, </span><span class="s1">condlist: Union[Array</span><span class="s3">, </span><span class="s1">Sequence[ArrayLike]]</span><span class="s3">,</span>
              <span class="s1">funclist: List[Union[ArrayLike</span><span class="s3">, </span><span class="s1">Callable[...</span><span class="s3">, </span><span class="s1">Array]]]</span><span class="s3">,</span>
              <span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw) -&gt; Array:</span>
  <span class="s1">util.check_arraylike(</span><span class="s4">&quot;piecewise&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">nc</span><span class="s3">, </span><span class="s1">nf = len(condlist)</span><span class="s3">, </span><span class="s1">len(funclist)</span>
  <span class="s3">if </span><span class="s1">nf == nc + </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">funclist = funclist[-</span><span class="s5">1</span><span class="s1">:] + funclist[:-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s3">elif </span><span class="s1">nf == nc:</span>
    <span class="s1">funclist = [</span><span class="s5">0</span><span class="s1">] + list(funclist)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;with </span><span class="s3">{</span><span class="s1">nc</span><span class="s3">} </span><span class="s4">condition(s), either </span><span class="s3">{</span><span class="s1">nc</span><span class="s3">} </span><span class="s4">or </span><span class="s3">{</span><span class="s1">nc+</span><span class="s5">1</span><span class="s3">} </span><span class="s4">functions are expected; got </span><span class="s3">{</span><span class="s1">nf</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">consts = {i: c </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">enumerate(funclist) </span><span class="s3">if not </span><span class="s1">callable(c)}</span>
  <span class="s1">funcs = {i: f </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">f </span><span class="s3">in </span><span class="s1">enumerate(funclist) </span><span class="s3">if </span><span class="s1">callable(f)}</span>
  <span class="s3">return </span><span class="s1">_piecewise(asarray(x)</span><span class="s3">, </span><span class="s1">asarray(condlist</span><span class="s3">, </span><span class="s1">dtype=bool_)</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">,</span>
                    <span class="s1">frozenset(funcs.items())</span><span class="s3">,  </span><span class="s0"># dict is not hashable.</span>
                    <span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw)</span>

<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">static_argnames=[</span><span class="s4">'funcs'</span><span class="s1">])</span>
<span class="s3">def </span><span class="s1">_piecewise(x: Array</span><span class="s3">, </span><span class="s1">condlist: Array</span><span class="s3">, </span><span class="s1">consts: Dict[int</span><span class="s3">, </span><span class="s1">ArrayLike]</span><span class="s3">,</span>
               <span class="s1">funcs: FrozenSet[Tuple[int</span><span class="s3">, </span><span class="s1">Callable[...</span><span class="s3">, </span><span class="s1">Array]]]</span><span class="s3">,</span>
               <span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw) -&gt; Array:</span>
  <span class="s1">funcdict = dict(funcs)</span>
  <span class="s1">funclist = [consts.get(i</span><span class="s3">, </span><span class="s1">funcdict.get(i)) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(condlist) + </span><span class="s5">1</span><span class="s1">)]</span>
  <span class="s1">indices = argmax(reductions.cumsum(concatenate([zeros_like(condlist[:</span><span class="s5">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">condlist]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">dtype = _dtype(x)</span>
  <span class="s3">def </span><span class="s1">_call(f):</span>
    <span class="s3">return lambda </span><span class="s1">x: f(x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw).astype(dtype)</span>
  <span class="s3">def </span><span class="s1">_const(v):</span>
    <span class="s3">return lambda </span><span class="s1">x: array(v</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">funclist = [_call(f) </span><span class="s3">if </span><span class="s1">callable(f) </span><span class="s3">else </span><span class="s1">_const(f) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">funclist]</span>
  <span class="s3">return </span><span class="s1">vectorize(lax.switch</span><span class="s3">, </span><span class="s1">excluded=(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">))(indices</span><span class="s3">, </span><span class="s1">funclist</span><span class="s3">, </span><span class="s1">x)</span>



<span class="s1">@util._wraps(np.place</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot; 
Numpy function :func:`numpy.place` is not available in JAX and will raise a 
:class:`NotImplementedError`, because ``np.place`` modifies its arguments in-place, 
and in JAX arrays are immutable. A JAX-compatible approach to array updates 
can be found in :attr:`jax.numpy.ndarray.at`. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">place(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
    <span class="s4">&quot;jax.numpy.place is not implemented because JAX arrays cannot be modified in-place. &quot;</span>
    <span class="s4">&quot;For functional approaches to updating array values, see jax.numpy.ndarray.at: &quot;</span>
    <span class="s4">&quot;https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html.&quot;</span><span class="s1">)</span>


<span class="s1">@util._wraps(np.put</span><span class="s3">, </span><span class="s1">lax_description=</span><span class="s4">&quot;&quot;&quot; 
Numpy function :func:`numpy.put` is not available in JAX and will raise a 
:class:`NotImplementedError`, because ``np.put`` modifies its arguments in-place, 
and in JAX arrays are immutable. A JAX-compatible approach to array updates 
can be found in :attr:`jax.numpy.ndarray.at`. 
&quot;&quot;&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">put(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
    <span class="s4">&quot;jax.numpy.put is not implemented because JAX arrays cannot be modified in-place. &quot;</span>
    <span class="s4">&quot;For functional approaches to updating array values, see jax.numpy.ndarray.at: &quot;</span>
    <span class="s4">&quot;https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html.&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>