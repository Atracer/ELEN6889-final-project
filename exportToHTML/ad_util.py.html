<html>
<head>
<title>ad_util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ad_util.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">TypeVar</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">cast</span>

<span class="s2">from </span><span class="s1">jax.tree_util </span><span class="s2">import </span><span class="s1">register_pytree_node</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src.core </span><span class="s2">import </span><span class="s1">(lattice_join</span><span class="s2">, </span><span class="s1">Primitive</span><span class="s2">, </span><span class="s1">valid_jaxtype</span><span class="s2">,</span>
                           <span class="s1">raise_to_shaped</span><span class="s2">, </span><span class="s1">get_aval)</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">safe_map</span>
<span class="s2">from </span><span class="s1">jax._src.typing </span><span class="s2">import </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">ArrayLike</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">T = TypeVar(</span><span class="s3">'T'</span><span class="s1">)</span>

<span class="s1">map = safe_map</span>

<span class="s1">jaxval_adders: Dict[type</span><span class="s2">, </span><span class="s1">Callable[[ArrayLike</span><span class="s2">, </span><span class="s1">ArrayLike]</span><span class="s2">, </span><span class="s1">Array]] = {}</span>

<span class="s2">def </span><span class="s1">add_jaxvals(x: ArrayLike</span><span class="s2">, </span><span class="s1">y: ArrayLike) -&gt; Array:</span>
  <span class="s2">return </span><span class="s1">add_jaxvals_p.bind(x</span><span class="s2">, </span><span class="s1">y)</span>

<span class="s1">add_jaxvals_p: Primitive = Primitive(</span><span class="s3">'add_any'</span><span class="s1">)</span>
<span class="s1">add_any_p = add_jaxvals_p</span>

<span class="s1">@add_jaxvals_p.def_impl</span>
<span class="s2">def </span><span class="s1">add_impl(xs</span><span class="s2">, </span><span class="s1">ys):</span>
  <span class="s2">return </span><span class="s1">jaxval_adders[type(xs)](xs</span><span class="s2">, </span><span class="s1">ys)</span>

<span class="s1">@add_jaxvals_p.def_abstract_eval</span>
<span class="s2">def </span><span class="s1">add_abstract(xs</span><span class="s2">, </span><span class="s1">ys):</span>
  <span class="s2">return </span><span class="s1">lattice_join(xs</span><span class="s2">, </span><span class="s1">ys)</span>

<span class="s1">jaxval_zeros_likers: Dict[type</span><span class="s2">, </span><span class="s1">Callable[[Any]</span><span class="s2">, </span><span class="s1">Array]] = {}</span>

<span class="s2">def </span><span class="s1">instantiate(z: Union[Zero</span><span class="s2">, </span><span class="s1">Array]) -&gt; Array:</span>
  <span class="s2">if </span><span class="s1">type(z) </span><span class="s2">is </span><span class="s1">Zero:</span>
    <span class="s2">return </span><span class="s1">zeros_like_aval(z.aval)</span>
  <span class="s2">return </span><span class="s1">cast(Array</span><span class="s2">, </span><span class="s1">z)</span>

<span class="s2">def </span><span class="s1">zeros_like_aval(aval: core.AbstractValue) -&gt; Array:</span>
  <span class="s2">return </span><span class="s1">aval_zeros_likers[type(aval)](aval)</span>

<span class="s1">aval_zeros_likers: Dict[type</span><span class="s2">, </span><span class="s1">Callable[[Any]</span><span class="s2">, </span><span class="s1">Array]] = {}</span>

<span class="s2">def </span><span class="s1">zeros_like_jaxval(val: ArrayLike) -&gt; Array:</span>
  <span class="s2">return </span><span class="s1">zeros_like_p.bind(val)</span>

<span class="s1">zeros_like_p: Primitive = Primitive(</span><span class="s3">'zeros_like'</span><span class="s1">)</span>

<span class="s1">@zeros_like_p.def_impl</span>
<span class="s2">def </span><span class="s1">zeros_like_impl(example):</span>
  <span class="s2">return </span><span class="s1">jaxval_zeros_likers[type(example)](example)</span>

<span class="s1">zeros_like_p.def_abstract_eval(</span><span class="s2">lambda </span><span class="s1">x: x)</span>

<span class="s2">class </span><span class="s1">Zero:</span>
  <span class="s1">__slots__ = [</span><span class="s3">'aval'</span><span class="s1">]</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">aval: core.AbstractValue):</span>
    <span class="s1">self.aval = aval</span>
  <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s3">f'Zero(</span><span class="s2">{</span><span class="s1">self.aval</span><span class="s2">}</span><span class="s3">)'</span>
  <span class="s1">@staticmethod</span>
  <span class="s2">def </span><span class="s1">from_value(val: Any) -&gt; Zero:</span>
    <span class="s2">return </span><span class="s1">Zero(raise_to_shaped(get_aval(val)))</span>

<span class="s1">register_pytree_node(Zero</span><span class="s2">, lambda </span><span class="s1">z: (()</span><span class="s2">, </span><span class="s1">z.aval)</span><span class="s2">, lambda </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">_: Zero(aval))</span>


<span class="s2">def </span><span class="s1">_stop_gradient_impl(x: T) -&gt; T:</span>
  <span class="s2">if not </span><span class="s1">valid_jaxtype(x):</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;stop_gradient only works on valid JAX arrays, but &quot;</span>
                    <span class="s3">f&quot;input argument is: </span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">x</span>

<span class="s1">stop_gradient_p : Primitive = Primitive(</span><span class="s3">'stop_gradient'</span><span class="s1">)</span>
<span class="s1">stop_gradient_p.def_impl(_stop_gradient_impl)</span>
<span class="s1">stop_gradient_p.def_abstract_eval(</span><span class="s2">lambda </span><span class="s1">x: x)</span>


<span class="s2">class </span><span class="s1">SymbolicZero:</span>
  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">aval: core.AbstractValue) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">self.aval = aval</span>

  <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s2">return </span><span class="s1">self.__class__.__name__</span>

  <span class="s0"># TODO(mattjj,frostig): this forwards attr lookup to self.aval delegate;</span>
  <span class="s0"># should dedup with core.Tracer.__getattr__ which does the same thing</span>
  <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s0"># if the aval property raises an AttributeError, gets caught here</span>
    <span class="s2">try</span><span class="s1">:</span>
      <span class="s1">attr = getattr(self.aval</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
      <span class="s2">raise </span><span class="s1">AttributeError(</span>
          <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.__class__.__name__</span><span class="s2">} </span><span class="s3">has no attribute </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span>
      <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">t = type(attr)</span>
      <span class="s2">if </span><span class="s1">t </span><span class="s2">is </span><span class="s1">core.aval_property:</span>
        <span class="s2">return </span><span class="s1">attr.fget(self)</span>
      <span class="s2">elif </span><span class="s1">t </span><span class="s2">is </span><span class="s1">core.aval_method:</span>
        <span class="s2">return </span><span class="s1">types.MethodType(attr.fun</span><span class="s2">, </span><span class="s1">self)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">attr</span>

<span class="s1">JaxTypeOrTracer = Any</span>

<span class="s2">def </span><span class="s1">replace_internal_symbolic_zeros(</span>
    <span class="s1">x: Union[JaxTypeOrTracer</span><span class="s2">, </span><span class="s1">Zero]) -&gt; Union[JaxTypeOrTracer</span><span class="s2">, </span><span class="s1">SymbolicZero]:</span>
  <span class="s2">return </span><span class="s1">SymbolicZero(x.aval) </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">Zero </span><span class="s2">else </span><span class="s1">x</span>

<span class="s2">def </span><span class="s1">replace_rule_output_symbolic_zeros(</span>
    <span class="s1">x: Union[JaxTypeOrTracer</span><span class="s2">, </span><span class="s1">SymbolicZero]) -&gt; Union[JaxTypeOrTracer</span><span class="s2">, </span><span class="s1">Zero]:</span>
  <span class="s2">return </span><span class="s1">Zero(x.aval) </span><span class="s2">if </span><span class="s1">type(x) </span><span class="s2">is </span><span class="s1">SymbolicZero </span><span class="s2">else </span><span class="s1">x</span>
</pre>
</body>
</html>