<html>
<head>
<title>ufuncs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ufuncs.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">&quot;&quot;&quot; 
Implements ufuncs for jax.numpy. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">from </span><span class="s1">textwrap </span><span class="s3">import </span><span class="s1">dedent</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">, </span><span class="s1">overload</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax._src.api </span><span class="s3">import </span><span class="s1">jit</span><span class="s3">, </span><span class="s1">custom_jvp</span>
<span class="s3">from </span><span class="s1">jax._src.lax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax._src.typing </span><span class="s3">import </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">ArrayLike</span>
<span class="s3">from </span><span class="s1">jax._src.numpy.util </span><span class="s3">import </span><span class="s1">(</span>
   <span class="s1">_asarray</span><span class="s3">, </span><span class="s1">check_arraylike</span><span class="s3">, </span><span class="s1">promote_args</span><span class="s3">, </span><span class="s1">promote_args_inexact</span><span class="s3">,</span>
   <span class="s1">promote_args_numeric</span><span class="s3">, </span><span class="s1">promote_dtypes_inexact</span><span class="s3">, </span><span class="s1">promote_dtypes_numeric</span><span class="s3">,</span>
   <span class="s1">promote_shapes</span><span class="s3">, </span><span class="s1">_where</span><span class="s3">, </span><span class="s1">_wraps)</span>

<span class="s1">_lax_const = lax._const</span>

<span class="s1">_INT_DTYPES = {</span>
  <span class="s4">16</span><span class="s1">: np.int16</span><span class="s3">,</span>
  <span class="s4">32</span><span class="s1">: np.int32</span><span class="s3">,</span>
  <span class="s4">64</span><span class="s1">: np.int64</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">UnOp = Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">Array]</span>
<span class="s1">BinOp = Callable[[ArrayLike</span><span class="s3">, </span><span class="s1">ArrayLike]</span><span class="s3">, </span><span class="s1">Array]</span>


<span class="s3">def </span><span class="s1">_constant_like(x</span><span class="s3">, </span><span class="s1">const):</span>
  <span class="s3">return </span><span class="s1">np.array(const</span><span class="s3">, </span><span class="s1">dtype=dtypes.dtype(x))</span>


<span class="s3">def </span><span class="s1">_replace_inf(x: ArrayLike) -&gt; Array:</span>
  <span class="s3">return </span><span class="s1">lax.select(isposinf(real(x))</span><span class="s3">, </span><span class="s1">lax._zeros(x)</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s3">def </span><span class="s1">_one_to_one_unop(</span>
    <span class="s1">numpy_fn: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">lax_fn: UnOp</span><span class="s3">,</span>
    <span class="s1">promote_to_inexact: bool = </span><span class="s3">False, </span><span class="s1">lax_doc: bool = </span><span class="s3">False</span><span class="s1">) -&gt; UnOp:</span>
  <span class="s3">if </span><span class="s1">promote_to_inexact:</span>
    <span class="s1">fn = </span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">/: lax_fn(*promote_args_inexact(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">fn = </span><span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">/: lax_fn(*promote_args(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x))</span>
  <span class="s1">fn.__qualname__ = </span><span class="s5">f&quot;jax.numpy.</span><span class="s3">{</span><span class="s1">numpy_fn.__name__</span><span class="s3">}</span><span class="s5">&quot;</span>
  <span class="s1">fn = jit(fn</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">lax_doc:</span>
    <span class="s1">doc = dedent(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">.join(lax_fn.__doc__.split(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:])).strip()  </span><span class="s0"># type: ignore[union-attr]</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">lax_description=doc</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>


<span class="s3">def </span><span class="s1">_one_to_one_binop(</span>
    <span class="s1">numpy_fn: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">lax_fn: BinOp</span><span class="s3">,</span>
    <span class="s1">promote_to_inexact: bool = </span><span class="s3">False, </span><span class="s1">lax_doc: bool = </span><span class="s3">False,</span>
    <span class="s1">promote_to_numeric: bool = </span><span class="s3">False</span><span class="s1">) -&gt; BinOp:</span>
  <span class="s3">if </span><span class="s1">promote_to_inexact:</span>
    <span class="s1">fn = </span><span class="s3">lambda </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">/: lax_fn(*promote_args_inexact(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2))</span>
  <span class="s3">elif </span><span class="s1">promote_to_numeric:</span>
    <span class="s1">fn = </span><span class="s3">lambda </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">/: lax_fn(*promote_args_numeric(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">fn = </span><span class="s3">lambda </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">/: lax_fn(*promote_args(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2))</span>
  <span class="s1">fn.__qualname__ = </span><span class="s5">f&quot;jax.numpy.</span><span class="s3">{</span><span class="s1">numpy_fn.__name__</span><span class="s3">}</span><span class="s5">&quot;</span>
  <span class="s1">fn = jit(fn</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">lax_doc:</span>
    <span class="s1">doc = dedent(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">.join(lax_fn.__doc__.split(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:])).strip()  </span><span class="s0"># type: ignore[union-attr]</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">lax_description=doc</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>


<span class="s3">def </span><span class="s1">_maybe_bool_binop(</span>
    <span class="s1">numpy_fn: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">lax_fn: BinOp</span><span class="s3">, </span><span class="s1">bool_lax_fn: BinOp</span><span class="s3">,</span>
    <span class="s1">lax_doc: bool = </span><span class="s3">False</span><span class="s1">) -&gt; BinOp:</span>
  <span class="s3">def </span><span class="s1">fn(x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">/):</span>
    <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
    <span class="s3">return </span><span class="s1">lax_fn(x1</span><span class="s3">, </span><span class="s1">x2) </span><span class="s3">if </span><span class="s1">x1.dtype != np.bool_ </span><span class="s3">else </span><span class="s1">bool_lax_fn(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">fn.__qualname__ = </span><span class="s5">f&quot;jax.numpy.</span><span class="s3">{</span><span class="s1">numpy_fn.__name__</span><span class="s3">}</span><span class="s5">&quot;</span>
  <span class="s1">fn = jit(fn</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">lax_doc:</span>
    <span class="s1">doc = dedent(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">.join(lax_fn.__doc__.split(</span><span class="s5">'</span><span class="s3">\n\n</span><span class="s5">'</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:])).strip()  </span><span class="s0"># type: ignore[union-attr]</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">lax_description=doc</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>


<span class="s3">def </span><span class="s1">_comparison_op(numpy_fn: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">lax_fn: BinOp) -&gt; BinOp:</span>
  <span class="s3">def </span><span class="s1">fn(x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">/):</span>
    <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 =  promote_args(numpy_fn.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
    <span class="s0"># Comparison on complex types are defined as a lexicographic ordering on</span>
    <span class="s0"># the (real, imag) pair.</span>
    <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtypes.dtype(x1)</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
      <span class="s1">rx = lax.real(x1)</span>
      <span class="s1">ry = lax.real(x2)</span>
      <span class="s3">return </span><span class="s1">lax.select(lax.eq(rx</span><span class="s3">, </span><span class="s1">ry)</span><span class="s3">, </span><span class="s1">lax_fn(lax.imag(x1)</span><span class="s3">, </span><span class="s1">lax.imag(x2))</span><span class="s3">,</span>
                        <span class="s1">lax_fn(rx</span><span class="s3">, </span><span class="s1">ry))</span>
    <span class="s3">return </span><span class="s1">lax_fn(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">fn.__qualname__ = </span><span class="s5">f&quot;jax.numpy.</span><span class="s3">{</span><span class="s1">numpy_fn.__name__</span><span class="s3">}</span><span class="s5">&quot;</span>
  <span class="s1">fn = jit(fn</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_wraps(numpy_fn</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(fn)</span>

<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">_logical_op(np_op: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">bitwise_op: UnOp) -&gt; UnOp: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">_logical_op(np_op: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">bitwise_op: BinOp) -&gt; BinOp: ...</span>
<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">_logical_op(np_op: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">bitwise_op: Union[UnOp</span><span class="s3">, </span><span class="s1">BinOp]) -&gt; Union[UnOp</span><span class="s3">, </span><span class="s1">BinOp]: ...</span>

<span class="s3">def </span><span class="s1">_logical_op(np_op: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">bitwise_op: Union[UnOp</span><span class="s3">, </span><span class="s1">BinOp]) -&gt; Union[UnOp</span><span class="s3">, </span><span class="s1">BinOp]:</span>
  <span class="s1">@_wraps(np_op</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
  <span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
  <span class="s3">def </span><span class="s1">op(*args):</span>
    <span class="s1">zero = </span><span class="s3">lambda </span><span class="s1">x: lax.full_like(x</span><span class="s3">, </span><span class="s1">shape=()</span><span class="s3">, </span><span class="s1">fill_value=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">args = (x </span><span class="s3">if </span><span class="s1">dtypes.issubdtype(dtypes.dtype(x)</span><span class="s3">, </span><span class="s1">np.bool_) </span><span class="s3">else </span><span class="s1">lax.ne(x</span><span class="s3">, </span><span class="s1">zero(x))</span>
            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args)</span>
    <span class="s3">return </span><span class="s1">bitwise_op(*promote_args(np_op.__name__</span><span class="s3">, </span><span class="s1">*args))</span>
  <span class="s3">return </span><span class="s1">op</span>


<span class="s1">fabs = _one_to_one_unop(np.fabs</span><span class="s3">, </span><span class="s1">lax.abs</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">bitwise_not = _one_to_one_unop(np.bitwise_not</span><span class="s3">, </span><span class="s1">lax.bitwise_not)</span>
<span class="s1">invert = _one_to_one_unop(np.invert</span><span class="s3">, </span><span class="s1">lax.bitwise_not)</span>
<span class="s1">negative = _one_to_one_unop(np.negative</span><span class="s3">, </span><span class="s1">lax.neg)</span>
<span class="s1">positive = _one_to_one_unop(np.positive</span><span class="s3">, lambda </span><span class="s1">x: _asarray(x))</span>
<span class="s1">floor = _one_to_one_unop(np.floor</span><span class="s3">, </span><span class="s1">lax.floor</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">ceil = _one_to_one_unop(np.ceil</span><span class="s3">, </span><span class="s1">lax.ceil</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">exp = _one_to_one_unop(np.exp</span><span class="s3">, </span><span class="s1">lax.exp</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">log = _one_to_one_unop(np.log</span><span class="s3">, </span><span class="s1">lax.log</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">expm1 = _one_to_one_unop(np.expm1</span><span class="s3">, </span><span class="s1">lax.expm1</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">log1p = _one_to_one_unop(np.log1p</span><span class="s3">, </span><span class="s1">lax.log1p</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">sin = _one_to_one_unop(np.sin</span><span class="s3">, </span><span class="s1">lax.sin</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">cos = _one_to_one_unop(np.cos</span><span class="s3">, </span><span class="s1">lax.cos</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">tan = _one_to_one_unop(np.tan</span><span class="s3">, </span><span class="s1">lax.tan</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">arcsin = _one_to_one_unop(np.arcsin</span><span class="s3">, </span><span class="s1">lax.asin</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">arccos = _one_to_one_unop(np.arccos</span><span class="s3">, </span><span class="s1">lax.acos</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">arctan = _one_to_one_unop(np.arctan</span><span class="s3">, </span><span class="s1">lax.atan</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">sinh = _one_to_one_unop(np.sinh</span><span class="s3">, </span><span class="s1">lax.sinh</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">cosh = _one_to_one_unop(np.cosh</span><span class="s3">, </span><span class="s1">lax.cosh</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">arcsinh = _one_to_one_unop(np.arcsinh</span><span class="s3">, </span><span class="s1">lax.asinh</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">tanh = _one_to_one_unop(np.tanh</span><span class="s3">, </span><span class="s1">lax.tanh</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">arctanh = _one_to_one_unop(np.arctanh</span><span class="s3">, </span><span class="s1">lax.atanh</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">sqrt = _one_to_one_unop(np.sqrt</span><span class="s3">, </span><span class="s1">lax.sqrt</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">cbrt = _one_to_one_unop(np.cbrt</span><span class="s3">, </span><span class="s1">lax.cbrt</span><span class="s3">, True</span><span class="s1">)</span>

<span class="s1">add = _maybe_bool_binop(np.add</span><span class="s3">, </span><span class="s1">lax.add</span><span class="s3">, </span><span class="s1">lax.bitwise_or)</span>
<span class="s1">bitwise_and = _one_to_one_binop(np.bitwise_and</span><span class="s3">, </span><span class="s1">lax.bitwise_and)</span>
<span class="s1">bitwise_or = _one_to_one_binop(np.bitwise_or</span><span class="s3">, </span><span class="s1">lax.bitwise_or)</span>
<span class="s1">bitwise_xor = _one_to_one_binop(np.bitwise_xor</span><span class="s3">, </span><span class="s1">lax.bitwise_xor)</span>
<span class="s1">left_shift = _one_to_one_binop(np.left_shift</span><span class="s3">, </span><span class="s1">lax.shift_left</span><span class="s3">, </span><span class="s1">promote_to_numeric=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s1">equal = _one_to_one_binop(np.equal</span><span class="s3">, </span><span class="s1">lax.eq)</span>
<span class="s1">multiply = _maybe_bool_binop(np.multiply</span><span class="s3">, </span><span class="s1">lax.mul</span><span class="s3">, </span><span class="s1">lax.bitwise_and)</span>
<span class="s1">not_equal = _one_to_one_binop(np.not_equal</span><span class="s3">, </span><span class="s1">lax.ne)</span>
<span class="s1">subtract = _one_to_one_binop(np.subtract</span><span class="s3">, </span><span class="s1">lax.sub)</span>
<span class="s1">arctan2 = _one_to_one_binop(np.arctan2</span><span class="s3">, </span><span class="s1">lax.atan2</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">minimum = _one_to_one_binop(np.minimum</span><span class="s3">, </span><span class="s1">lax.min)</span>
<span class="s1">maximum = _one_to_one_binop(np.maximum</span><span class="s3">, </span><span class="s1">lax.max)</span>
<span class="s1">float_power = _one_to_one_binop(np.float_power</span><span class="s3">, </span><span class="s1">lax.pow</span><span class="s3">, True</span><span class="s1">)</span>
<span class="s1">nextafter = _one_to_one_binop(np.nextafter</span><span class="s3">, </span><span class="s1">lax.nextafter</span><span class="s3">, True, True</span><span class="s1">)</span>

<span class="s1">greater_equal = _comparison_op(np.greater_equal</span><span class="s3">, </span><span class="s1">lax.ge)</span>
<span class="s1">greater = _comparison_op(np.greater</span><span class="s3">, </span><span class="s1">lax.gt)</span>
<span class="s1">less_equal = _comparison_op(np.less_equal</span><span class="s3">, </span><span class="s1">lax.le)</span>
<span class="s1">less = _comparison_op(np.less</span><span class="s3">, </span><span class="s1">lax.lt)</span>

<span class="s1">logical_and: BinOp = _logical_op(np.logical_and</span><span class="s3">, </span><span class="s1">lax.bitwise_and)</span>
<span class="s1">logical_not: UnOp = _logical_op(np.logical_not</span><span class="s3">, </span><span class="s1">lax.bitwise_not)</span>
<span class="s1">logical_or: BinOp = _logical_op(np.logical_or</span><span class="s3">, </span><span class="s1">lax.bitwise_or)</span>
<span class="s1">logical_xor: BinOp = _logical_op(np.logical_xor</span><span class="s3">, </span><span class="s1">lax.bitwise_xor)</span>

<span class="s1">@_wraps(np.arccosh</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">arccosh(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s0"># Note: arccosh is multi-valued for complex input, and lax.acosh uses a different</span>
  <span class="s0"># convention than np.arccosh.</span>
  <span class="s1">out = lax.acosh(*promote_args_inexact(</span><span class="s5">&quot;arccosh&quot;</span><span class="s3">, </span><span class="s1">x))</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(out.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s1">out = _where(real(out) &lt; </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lax.neg(out)</span><span class="s3">, </span><span class="s1">out)</span>
  <span class="s3">return </span><span class="s1">out</span>


<span class="s1">@_wraps(np.right_shift</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">right_shift(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_numeric(np.right_shift.__name__</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">lax_fn = lax.shift_right_logical </span><span class="s3">if </span><span class="s1">\</span>
    <span class="s1">np.issubdtype(x1.dtype</span><span class="s3">, </span><span class="s1">np.unsignedinteger) </span><span class="s3">else </span><span class="s1">lax.shift_right_arithmetic</span>
  <span class="s3">return </span><span class="s1">lax_fn(x1</span><span class="s3">, </span><span class="s1">x2)</span>


<span class="s1">@_wraps(np.absolute</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">absolute(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">'absolute'</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dt = dtypes.dtype(x)</span>
  <span class="s3">return </span><span class="s1">_asarray(x) </span><span class="s3">if </span><span class="s1">dt == np.bool_ </span><span class="s3">or </span><span class="s1">dtypes.issubdtype(dt</span><span class="s3">, </span><span class="s1">np.unsignedinteger) </span><span class="s3">else </span><span class="s1">lax.abs(x)</span>
<span class="s1">abs = _wraps(np.abs</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(absolute)</span>


<span class="s1">@_wraps(np.rint</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">rint(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">'rint'</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtype == bool </span><span class="s3">or </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">lax.convert_element_type(x</span><span class="s3">, </span><span class="s1">dtypes.float_)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">return </span><span class="s1">lax.complex(rint(lax.real(x))</span><span class="s3">, </span><span class="s1">rint(lax.imag(x)))</span>
  <span class="s3">return </span><span class="s1">lax.round(x</span><span class="s3">, </span><span class="s1">lax.RoundingMethod.TO_NEAREST_EVEN)</span>


<span class="s1">@_wraps(np.sign</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">sign(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">'sign'</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s1">re = lax.real(x)</span>
    <span class="s3">return </span><span class="s1">lax.complex(</span>
      <span class="s1">lax.sign(_where(re != </span><span class="s4">0</span><span class="s3">, </span><span class="s1">re</span><span class="s3">, </span><span class="s1">lax.imag(x)))</span><span class="s3">, </span><span class="s1">_constant_like(re</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
  <span class="s3">return </span><span class="s1">lax.sign(x)</span>


<span class="s1">@_wraps(np.copysign</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">copysign(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_inexact(</span><span class="s5">&quot;copysign&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtypes.dtype(x1)</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;copysign does not support complex-valued inputs&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_where(signbit(x2).astype(bool)</span><span class="s3">, </span><span class="s1">-lax.abs(x1)</span><span class="s3">, </span><span class="s1">lax.abs(x1))</span>


<span class="s1">@_wraps(np.true_divide</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">true_divide(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_inexact(</span><span class="s5">&quot;true_divide&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">lax.div(x1</span><span class="s3">, </span><span class="s1">x2)</span>

<span class="s1">divide = true_divide</span>


<span class="s1">@_wraps(np.floor_divide</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">floor_divide(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_numeric(</span><span class="s5">&quot;floor_divide&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">dtype = dtypes.dtype(x1)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s1">quotient = lax.div(x1</span><span class="s3">, </span><span class="s1">x2)</span>
    <span class="s1">select = logical_and(lax.sign(x1) != lax.sign(x2)</span><span class="s3">, </span><span class="s1">lax.rem(x1</span><span class="s3">, </span><span class="s1">x2) != </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0"># TODO(mattjj): investigate why subtracting a scalar was causing promotion</span>
    <span class="s3">return </span><span class="s1">_where(select</span><span class="s3">, </span><span class="s1">quotient - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">quotient)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s1">x1r = lax.real(x1)</span>
    <span class="s1">x1i = lax.imag(x1)</span>
    <span class="s1">x2r = lax.real(x2)</span>
    <span class="s1">x2i = lax.imag(x2)</span>
    <span class="s1">which = lax.ge(lax.abs(x2r)</span><span class="s3">, </span><span class="s1">lax.abs(x2i))</span>
    <span class="s1">rat1 = _where(which</span><span class="s3">, </span><span class="s1">lax.full_like(x2i</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">lax.div(x2r</span><span class="s3">, </span><span class="s1">x2i))</span>
    <span class="s1">rat2 = _where(which</span><span class="s3">, </span><span class="s1">lax.div(x2i</span><span class="s3">, </span><span class="s1">x2r)</span><span class="s3">, </span><span class="s1">_lax_const(x2i</span><span class="s3">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">out = lax.floor(lax.div(lax.add(lax.mul(x1r</span><span class="s3">, </span><span class="s1">rat1)</span><span class="s3">, </span><span class="s1">lax.mul(x1i</span><span class="s3">, </span><span class="s1">rat2))</span><span class="s3">,</span>
                            <span class="s1">lax.add(lax.mul(x2r</span><span class="s3">, </span><span class="s1">rat1)</span><span class="s3">, </span><span class="s1">lax.mul(x2i</span><span class="s3">, </span><span class="s1">rat2))))</span>
    <span class="s3">return </span><span class="s1">lax.convert_element_type(out</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_float_divmod(x1</span><span class="s3">, </span><span class="s1">x2)[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">@_wraps(np.divmod</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">divmod(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_numeric(</span><span class="s5">&quot;divmod&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtypes.dtype(x1)</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">floor_divide(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">remainder(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_float_divmod(x1</span><span class="s3">, </span><span class="s1">x2)</span>


<span class="s3">def </span><span class="s1">_float_divmod(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s0"># see float_divmod in floatobject.c of CPython</span>
  <span class="s1">mod = lax.rem(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">div = lax.div(lax.sub(x1</span><span class="s3">, </span><span class="s1">mod)</span><span class="s3">, </span><span class="s1">x2)</span>

  <span class="s1">ind = lax.bitwise_and(mod != </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lax.sign(x2) != lax.sign(mod))</span>
  <span class="s1">mod = lax.select(ind</span><span class="s3">, </span><span class="s1">mod + x2</span><span class="s3">, </span><span class="s1">mod)</span>
  <span class="s1">div = lax.select(ind</span><span class="s3">, </span><span class="s1">div - _constant_like(div</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">div)</span>

  <span class="s3">return </span><span class="s1">lax.round(div)</span><span class="s3">, </span><span class="s1">mod</span>


<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_power(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_numeric(</span><span class="s5">&quot;power&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">dtype = dtypes.dtype(x1)</span>
  <span class="s3">if not </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">lax.pow(x1</span><span class="s3">, </span><span class="s1">x2)</span>

  <span class="s0"># Integer power =&gt; use binary exponentiation.</span>

  <span class="s0"># TODO(phawkins): add integer pow support to XLA.</span>
  <span class="s1">bits = </span><span class="s4">6  </span><span class="s0"># Anything more would overflow for any x1 &gt; 1</span>
  <span class="s1">zero = _constant_like(x2</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
  <span class="s1">one = _constant_like(x2</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
  <span class="s0"># Initialize acc carefully such that pow(0, x2) is zero for x2 != 0</span>
  <span class="s1">acc = _where(lax.bitwise_and(lax.eq(x1</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">lax.ne(x2</span><span class="s3">, </span><span class="s1">zero))</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">one)</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(bits):</span>
    <span class="s1">acc = _where(lax.bitwise_and(x2</span><span class="s3">, </span><span class="s1">one)</span><span class="s3">, </span><span class="s1">lax.mul(acc</span><span class="s3">, </span><span class="s1">x1)</span><span class="s3">, </span><span class="s1">acc)</span>
    <span class="s1">x1 = lax.mul(x1</span><span class="s3">, </span><span class="s1">x1)</span>
    <span class="s1">x2 = lax.shift_right_logical(x2</span><span class="s3">, </span><span class="s1">one)</span>
  <span class="s3">return </span><span class="s1">acc</span>


<span class="s1">@_wraps(np.power</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">power(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;power&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s0"># Special case for concrete integer scalars: use binary exponentiation.</span>
  <span class="s0"># Using lax.pow may be imprecise for floating-point values; the goal of this</span>
  <span class="s0"># code path is to make sure we end up with a precise output for the common</span>
  <span class="s0"># pattern ``x ** 2`` or similar.</span>
  <span class="s3">if </span><span class="s1">isinstance(core.get_aval(x2)</span><span class="s3">, </span><span class="s1">core.ConcreteArray):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">x2 = operator.index(x2)  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s3">pass</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">x1</span><span class="s3">, </span><span class="s1">= promote_dtypes_numeric(x1)</span>
      <span class="s3">return </span><span class="s1">lax.integer_pow(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">_power(x1</span><span class="s3">, </span><span class="s1">x2)</span>


<span class="s1">@custom_jvp</span>
<span class="s1">@_wraps(np.logaddexp</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">logaddexp(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_inexact(</span><span class="s5">&quot;logaddexp&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">amax = lax.max(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(x1.dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s1">delta = lax.sub(x1</span><span class="s3">, </span><span class="s1">x2)</span>
    <span class="s3">return </span><span class="s1">lax.select(lax._isnan(delta)</span><span class="s3">,</span>
                      <span class="s1">lax.add(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">,  </span><span class="s0"># NaNs or infinities of the same sign.</span>
                      <span class="s1">lax.add(amax</span><span class="s3">, </span><span class="s1">lax.log1p(lax.exp(lax.neg(lax.abs(delta))))))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">delta = lax.sub(lax.add(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">lax.mul(amax</span><span class="s3">, </span><span class="s1">_constant_like(amax</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">out = lax.add(amax</span><span class="s3">, </span><span class="s1">lax.log1p(lax.exp(delta)))</span>
    <span class="s3">return </span><span class="s1">lax.complex(lax.real(out)</span><span class="s3">, </span><span class="s1">_wrap_between(lax.imag(out)</span><span class="s3">, </span><span class="s1">np.pi))</span>


<span class="s3">def </span><span class="s1">_wrap_between(x</span><span class="s3">, </span><span class="s1">_a):</span>
  <span class="s2">&quot;&quot;&quot;Wraps `x` between `[-a, a]`.&quot;&quot;&quot;</span>
  <span class="s1">a = _constant_like(x</span><span class="s3">, </span><span class="s1">_a)</span>
  <span class="s1">two_a = _constant_like(x</span><span class="s3">, </span><span class="s4">2 </span><span class="s1">* _a)</span>
  <span class="s1">zero = _constant_like(x</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
  <span class="s1">rem = lax.rem(lax.add(x</span><span class="s3">, </span><span class="s1">a)</span><span class="s3">, </span><span class="s1">two_a)</span>
  <span class="s1">rem = lax.select(lax.lt(rem</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">lax.add(rem</span><span class="s3">, </span><span class="s1">two_a)</span><span class="s3">, </span><span class="s1">rem)</span>
  <span class="s3">return </span><span class="s1">lax.sub(rem</span><span class="s3">, </span><span class="s1">a)</span>


<span class="s1">@logaddexp.defjvp</span>
<span class="s3">def </span><span class="s1">_logaddexp_jvp(primals</span><span class="s3">, </span><span class="s1">tangents):</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = primals</span>
  <span class="s1">t1</span><span class="s3">, </span><span class="s1">t2 = tangents</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">, </span><span class="s1">t2 = promote_args_inexact(</span><span class="s5">&quot;logaddexp_jvp&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">, </span><span class="s1">t2)</span>
  <span class="s1">primal_out = logaddexp(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">tangent_out = lax.add(lax.mul(t1</span><span class="s3">, </span><span class="s1">exp(lax.sub(_replace_inf(x1)</span><span class="s3">, </span><span class="s1">_replace_inf(primal_out))))</span><span class="s3">,</span>
                        <span class="s1">lax.mul(t2</span><span class="s3">, </span><span class="s1">exp(lax.sub(_replace_inf(x2)</span><span class="s3">, </span><span class="s1">_replace_inf(primal_out)))))</span>
  <span class="s3">return </span><span class="s1">primal_out</span><span class="s3">, </span><span class="s1">tangent_out</span>


<span class="s1">@custom_jvp</span>
<span class="s1">@_wraps(np.logaddexp2</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">logaddexp2(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_inexact(</span><span class="s5">&quot;logaddexp2&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">amax = lax.max(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(x1.dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s1">delta = lax.sub(x1</span><span class="s3">, </span><span class="s1">x2)</span>
    <span class="s3">return </span><span class="s1">lax.select(lax._isnan(delta)</span><span class="s3">,</span>
                      <span class="s1">lax.add(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">,  </span><span class="s0"># NaNs or infinities of the same sign.</span>
                      <span class="s1">lax.add(amax</span><span class="s3">, </span><span class="s1">lax.div(lax.log1p(exp2(lax.neg(lax.abs(delta))))</span><span class="s3">,</span>
                                            <span class="s1">_constant_like(x1</span><span class="s3">, </span><span class="s1">np.log(</span><span class="s4">2</span><span class="s1">)))))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">delta = lax.sub(lax.add(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">lax.mul(amax</span><span class="s3">, </span><span class="s1">_constant_like(amax</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)))</span>
    <span class="s1">out = lax.add(amax</span><span class="s3">, </span><span class="s1">lax.div(lax.log1p(exp2(delta))</span><span class="s3">, </span><span class="s1">_constant_like(x1</span><span class="s3">, </span><span class="s1">np.log(</span><span class="s4">2</span><span class="s1">))))</span>
    <span class="s3">return </span><span class="s1">lax.complex(lax.real(out)</span><span class="s3">, </span><span class="s1">_wrap_between(lax.imag(out)</span><span class="s3">, </span><span class="s1">np.pi / np.log(</span><span class="s4">2</span><span class="s1">)))</span>


<span class="s1">@logaddexp2.defjvp</span>
<span class="s3">def </span><span class="s1">_logaddexp2_jvp(primals</span><span class="s3">, </span><span class="s1">tangents):</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = primals</span>
  <span class="s1">t1</span><span class="s3">, </span><span class="s1">t2 = tangents</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">, </span><span class="s1">t2 = promote_args_inexact(</span><span class="s5">&quot;logaddexp2_jvp&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">, </span><span class="s1">t2)</span>
  <span class="s1">primal_out = logaddexp2(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">tangent_out = lax.add(lax.mul(t1</span><span class="s3">, </span><span class="s1">exp2(lax.sub(_replace_inf(x1)</span><span class="s3">, </span><span class="s1">_replace_inf(primal_out))))</span><span class="s3">,</span>
                        <span class="s1">lax.mul(t2</span><span class="s3">, </span><span class="s1">exp2(lax.sub(_replace_inf(x2)</span><span class="s3">, </span><span class="s1">_replace_inf(primal_out)))))</span>
  <span class="s3">return </span><span class="s1">primal_out</span><span class="s3">, </span><span class="s1">tangent_out</span>


<span class="s1">@_wraps(np.log2</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">log2(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args_inexact(</span><span class="s5">&quot;log2&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.div(lax.log(x)</span><span class="s3">, </span><span class="s1">lax.log(_constant_like(x</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)))</span>


<span class="s1">@_wraps(np.log10</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">log10(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args_inexact(</span><span class="s5">&quot;log10&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.div(lax.log(x)</span><span class="s3">, </span><span class="s1">lax.log(_constant_like(x</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)))</span>


<span class="s1">@_wraps(np.exp2</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">exp2(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args_inexact(</span><span class="s5">&quot;exp2&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.exp(lax.mul(lax.log(_constant_like(x</span><span class="s3">, </span><span class="s4">2</span><span class="s1">))</span><span class="s3">, </span><span class="s1">x))</span>


<span class="s1">@_wraps(np.signbit</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">signbit(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args(</span><span class="s5">&quot;signbit&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s3">return </span><span class="s1">lax.lt(x</span><span class="s3">, </span><span class="s1">_constant_like(x</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.bool_):</span>
    <span class="s3">return </span><span class="s1">lax.full_like(x</span><span class="s3">, False, </span><span class="s1">dtype=np.bool_)</span>
  <span class="s3">elif not </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span>
        <span class="s5">&quot;jax.numpy.signbit is not well defined for %s&quot; </span><span class="s1">% dtype)</span>

  <span class="s0"># TPU supports BF16 but not S16 types, so as a workaround, convert BF16 to</span>
  <span class="s0"># F32.</span>
  <span class="s3">if </span><span class="s1">dtype == dtypes.bfloat16:</span>
    <span class="s1">dtype = np.dtype(</span><span class="s5">'float32'</span><span class="s1">)</span>
    <span class="s1">x = lax.convert_element_type(x</span><span class="s3">, </span><span class="s1">dtype)</span>

  <span class="s1">info = dtypes.finfo(dtype)</span>
  <span class="s3">if </span><span class="s1">info.bits </span><span class="s3">not in </span><span class="s1">_INT_DTYPES:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
        <span class="s5">&quot;jax.numpy.signbit only supports 16, 32, and 64-bit types.&quot;</span><span class="s1">)</span>
  <span class="s1">int_type = _INT_DTYPES[info.bits]</span>
  <span class="s1">x = lax.bitcast_convert_type(x</span><span class="s3">, </span><span class="s1">int_type)</span>
  <span class="s3">return </span><span class="s1">lax.convert_element_type(x &gt;&gt; (info.nexp + info.nmant)</span><span class="s3">, </span><span class="s1">np.bool_)</span>


<span class="s3">def </span><span class="s1">_normalize_float(x):</span>
  <span class="s1">info = dtypes.finfo(dtypes.dtype(x))</span>
  <span class="s1">int_type = _INT_DTYPES[info.bits]</span>
  <span class="s1">cond = lax.abs(x) &lt; info.tiny</span>
  <span class="s1">x1 = _where(cond</span><span class="s3">, </span><span class="s1">x * _lax_const(x</span><span class="s3">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nmant)</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x2 = _where(cond</span><span class="s3">, </span><span class="s1">int_type(-info.nmant)</span><span class="s3">, </span><span class="s1">int_type(</span><span class="s4">0</span><span class="s1">))</span>
  <span class="s3">return </span><span class="s1">lax.bitcast_convert_type(x1</span><span class="s3">, </span><span class="s1">int_type)</span><span class="s3">, </span><span class="s1">x2</span>


<span class="s1">@_wraps(np.ldexp</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">ldexp(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;ldexp&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1_dtype = dtypes.dtype(x1)</span>
  <span class="s1">x2_dtype = dtypes.dtype(x2)</span>
  <span class="s3">if </span><span class="s1">(dtypes.issubdtype(x1_dtype</span><span class="s3">, </span><span class="s1">np.complexfloating)</span>
      <span class="s3">or </span><span class="s1">dtypes.issubdtype(x2_dtype</span><span class="s3">, </span><span class="s1">np.inexact)):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;ldexp not supported for input types </span><span class="s3">{</span><span class="s1">(x1_dtype</span><span class="s3">, </span><span class="s1">x2_dtype)</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">)</span>

  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_shapes(</span><span class="s5">&quot;ldexp&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>

  <span class="s1">dtype = dtypes.canonicalize_dtype(dtypes.to_inexact_dtype(x1_dtype))</span>
  <span class="s1">info = dtypes.finfo(dtype)</span>
  <span class="s1">int_type = _INT_DTYPES[info.bits]</span>

  <span class="s1">x1 = lax.convert_element_type(x1</span><span class="s3">, </span><span class="s1">dtype)</span>
  <span class="s1">x2 = lax.convert_element_type(x2</span><span class="s3">, </span><span class="s1">int_type)</span>

  <span class="s1">mask = (</span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nexp) - </span><span class="s4">1</span>
  <span class="s1">bias = ((</span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nexp) - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">e = _normalize_float(x1)</span>
  <span class="s1">x2 += e + ((x &gt;&gt; info.nmant) &amp; mask) - bias</span>

  <span class="s0"># find underflow/overflow before denormalization</span>
  <span class="s1">underflow_cond = less(x2</span><span class="s3">, </span><span class="s1">-(bias + info.nmant))</span>
  <span class="s1">overflow_cond = greater(x2</span><span class="s3">, </span><span class="s1">bias)</span>

  <span class="s1">m = lax.full_like(x</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

  <span class="s0"># denormals</span>
  <span class="s1">cond = less(x2</span><span class="s3">, </span><span class="s1">-bias + </span><span class="s4">1</span><span class="s1">)</span>
  <span class="s1">x2 = _where(cond</span><span class="s3">, </span><span class="s1">x2 + info.nmant</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">m = _where(cond</span><span class="s3">, </span><span class="s1">m / (</span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nmant)</span><span class="s3">, </span><span class="s1">m)</span>

  <span class="s1">x2 = lax.convert_element_type(x2</span><span class="s3">, </span><span class="s1">np.int32)</span>
  <span class="s1">x &amp;= ~(mask &lt;&lt; info.nmant)</span>
  <span class="s1">x |= ((lax.convert_element_type(x2</span><span class="s3">, </span><span class="s1">int_type) + bias) &lt;&lt; info.nmant)</span>

  <span class="s1">x = lax.convert_element_type(m</span><span class="s3">, </span><span class="s1">dtype) * lax.bitcast_convert_type(x</span><span class="s3">, </span><span class="s1">dtype)</span>

  <span class="s0"># underflow</span>
  <span class="s1">x = _where(underflow_cond</span><span class="s3">, </span><span class="s1">lax.full_like(x</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype=dtype)</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s0"># overflow</span>
  <span class="s1">x = _where(overflow_cond</span><span class="s3">, </span><span class="s1">lax.sign(x1) * lax.full_like(x</span><span class="s3">, </span><span class="s1">np.inf)</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s0"># ldexp(x1, x2) = x1 for x1 = inf, -inf, nan, 0</span>
  <span class="s3">return </span><span class="s1">_where(isinf(x1) | isnan(x1) | (x1 == </span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s1">@_wraps(np.frexp</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">frexp(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;frexp&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_dtypes_inexact(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(x.dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;frexp does not support complex-valued inputs&quot;</span><span class="s1">)</span>

  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s1">info = dtypes.finfo(dtype)</span>
  <span class="s1">mask = (</span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nexp) - </span><span class="s4">1</span>
  <span class="s1">bias = ((</span><span class="s4">1 </span><span class="s1">&lt;&lt; info.nexp) - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>

  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = _normalize_float(x)</span>
  <span class="s1">x2 += ((x1 &gt;&gt; info.nmant) &amp; mask) - bias + </span><span class="s4">1</span>
  <span class="s1">x1 &amp;= ~(mask &lt;&lt; info.nmant)</span>
  <span class="s1">x1 |= (bias - </span><span class="s4">1</span><span class="s1">) &lt;&lt; info.nmant</span>
  <span class="s1">x1 = lax.bitcast_convert_type(x1</span><span class="s3">, </span><span class="s1">dtype)</span>

  <span class="s1">cond = isinf(x) | isnan(x) | (x == </span><span class="s4">0</span><span class="s1">)</span>
  <span class="s1">x2 = _where(cond</span><span class="s3">, </span><span class="s1">lax._zeros(x2)</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">_where(cond</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x1)</span><span class="s3">, </span><span class="s1">lax.convert_element_type(x2</span><span class="s3">, </span><span class="s1">np.int32)</span>


<span class="s1">@_wraps(np.remainder</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">remainder(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_args_numeric(</span><span class="s5">&quot;remainder&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">zero = _constant_like(x1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(x2.dtype</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s1">x2 = _where(x2 == </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lax._ones(x2)</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">trunc_mod = lax.rem(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">trunc_mod_not_zero = lax.ne(trunc_mod</span><span class="s3">, </span><span class="s1">zero)</span>
  <span class="s1">do_plus = lax.bitwise_and(</span>
      <span class="s1">lax.ne(lax.lt(trunc_mod</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">lax.lt(x2</span><span class="s3">, </span><span class="s1">zero))</span><span class="s3">, </span><span class="s1">trunc_mod_not_zero)</span>
  <span class="s3">return </span><span class="s1">lax.select(do_plus</span><span class="s3">, </span><span class="s1">lax.add(trunc_mod</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">trunc_mod)</span>
<span class="s1">mod = _wraps(np.mod</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)(remainder)</span>


<span class="s1">@_wraps(np.fmod</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">fmod(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;fmod&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtypes.result_type(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">np.integer):</span>
    <span class="s1">x2 = _where(x2 == </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lax._ones(x2)</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">lax.rem(*promote_args_numeric(</span><span class="s5">&quot;fmod&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2))</span>


<span class="s1">@_wraps(np.square</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">square(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;square&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_dtypes_numeric(x)</span>
  <span class="s3">return </span><span class="s1">lax.integer_pow(x</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s1">@_wraps(np.deg2rad</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">deg2rad(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args_inexact(</span><span class="s5">&quot;deg2rad&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.mul(x</span><span class="s3">, </span><span class="s1">_lax_const(x</span><span class="s3">, </span><span class="s1">np.pi / </span><span class="s4">180</span><span class="s1">))</span>


<span class="s1">@_wraps(np.rad2deg</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">rad2deg(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_args_inexact(</span><span class="s5">&quot;rad2deg&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.mul(x</span><span class="s3">, </span><span class="s1">_lax_const(x</span><span class="s3">, </span><span class="s4">180 </span><span class="s1">/ np.pi))</span>


<span class="s1">degrees = rad2deg</span>
<span class="s1">radians = deg2rad</span>


<span class="s1">@_wraps(np.conjugate</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">conjugate(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;conjugate&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.conj(x) </span><span class="s3">if </span><span class="s1">np.iscomplexobj(x) </span><span class="s3">else </span><span class="s1">_asarray(x)</span>
<span class="s1">conj = conjugate</span>


<span class="s1">@_wraps(np.imag)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">imag(val: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;imag&quot;</span><span class="s3">, </span><span class="s1">val)</span>
  <span class="s3">return </span><span class="s1">lax.imag(val) </span><span class="s3">if </span><span class="s1">np.iscomplexobj(val) </span><span class="s3">else </span><span class="s1">lax.full_like(val</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@_wraps(np.real)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">real(val: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;real&quot;</span><span class="s3">, </span><span class="s1">val)</span>
  <span class="s3">return </span><span class="s1">lax.real(val) </span><span class="s3">if </span><span class="s1">np.iscomplexobj(val) </span><span class="s3">else </span><span class="s1">_asarray(val)</span>

<span class="s1">@_wraps(np.modf</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s5">'out'</span><span class="s1">])</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">modf(x: ArrayLike</span><span class="s3">, </span><span class="s1">/</span><span class="s3">, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">) -&gt; Tuple[Array</span><span class="s3">, </span><span class="s1">Array]:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;modf&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_dtypes_inexact(x)</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;The 'out' argument to jnp.modf is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">whole = _where(lax.ge(x</span><span class="s3">, </span><span class="s1">lax._zero(x))</span><span class="s3">, </span><span class="s1">floor(x)</span><span class="s3">, </span><span class="s1">ceil(x))</span>
  <span class="s3">return </span><span class="s1">x - whole</span><span class="s3">, </span><span class="s1">whole</span>


<span class="s1">@_wraps(np.isfinite</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">isfinite(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;isfinite&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s3">return </span><span class="s1">lax.is_finite(x)</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">return </span><span class="s1">lax.bitwise_and(lax.is_finite(real(x))</span><span class="s3">, </span><span class="s1">lax.is_finite(imag(x)))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.full_like(x</span><span class="s3">, True, </span><span class="s1">dtype=np.bool_)</span>


<span class="s1">@_wraps(np.isinf</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">isinf(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;isinf&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s3">return </span><span class="s1">lax.eq(lax.abs(x)</span><span class="s3">, </span><span class="s1">_constant_like(x</span><span class="s3">, </span><span class="s1">np.inf))</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s1">re = lax.real(x)</span>
    <span class="s1">im = lax.imag(x)</span>
    <span class="s3">return </span><span class="s1">lax.bitwise_or(lax.eq(lax.abs(re)</span><span class="s3">, </span><span class="s1">_constant_like(re</span><span class="s3">, </span><span class="s1">np.inf))</span><span class="s3">,</span>
                          <span class="s1">lax.eq(lax.abs(im)</span><span class="s3">, </span><span class="s1">_constant_like(im</span><span class="s3">, </span><span class="s1">np.inf)))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.full_like(x</span><span class="s3">, False, </span><span class="s1">dtype=np.bool_)</span>


<span class="s3">def </span><span class="s1">_isposneginf(infinity: float</span><span class="s3">, </span><span class="s1">x: ArrayLike</span><span class="s3">, </span><span class="s1">out) -&gt; Array:</span>
  <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;The 'out' argument to isneginf/isposinf is not supported.&quot;</span><span class="s1">)</span>
  <span class="s1">dtype = dtypes.dtype(x)</span>
  <span class="s3">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
    <span class="s3">return </span><span class="s1">lax.eq(x</span><span class="s3">, </span><span class="s1">_constant_like(x</span><span class="s3">, </span><span class="s1">infinity))</span>
  <span class="s3">elif </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s3">, </span><span class="s1">np.complexfloating):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;isposinf/isneginf are not well defined for complex types&quot;</span><span class="s1">)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">lax.full_like(x</span><span class="s3">, False, </span><span class="s1">dtype=np.bool_)</span>


<span class="s1">isposinf: UnOp = _wraps(np.isposinf</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s5">'out'</span><span class="s1">])(</span>
  <span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">/</span><span class="s3">, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">: _isposneginf(np.inf</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">out)</span>
<span class="s1">)</span>


<span class="s1">isneginf: UnOp = _wraps(np.isneginf</span><span class="s3">, </span><span class="s1">skip_params=[</span><span class="s5">'out'</span><span class="s1">])(</span>
  <span class="s3">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">/</span><span class="s3">, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">: _isposneginf(-np.inf</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">out)</span>
<span class="s1">)</span>


<span class="s1">@_wraps(np.isnan</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">isnan(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;isnan&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s3">return </span><span class="s1">lax.ne(x</span><span class="s3">, </span><span class="s1">x)</span>


<span class="s1">@_wraps(np.heaviside</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">heaviside(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;heaviside&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_dtypes_inexact(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">zero = _lax_const(x1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">_where(lax.lt(x1</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">,</span>
                <span class="s1">_where(lax.gt(x1</span><span class="s3">, </span><span class="s1">zero)</span><span class="s3">, </span><span class="s1">_lax_const(x1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">x2))</span>


<span class="s1">@_wraps(np.hypot</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">hypot(x1: ArrayLike</span><span class="s3">, </span><span class="s1">x2: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;hypot&quot;</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = promote_dtypes_inexact(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s1">x1 = lax.abs(x1)</span>
  <span class="s1">x2 = lax.abs(x2)</span>
  <span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = maximum(x1</span><span class="s3">, </span><span class="s1">x2)</span><span class="s3">, </span><span class="s1">minimum(x1</span><span class="s3">, </span><span class="s1">x2)</span>
  <span class="s3">return </span><span class="s1">lax.select(x1 == </span><span class="s4">0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x1 * lax.sqrt(</span><span class="s4">1 </span><span class="s1">+ lax.square(lax.div(x2</span><span class="s3">, </span><span class="s1">lax.select(x1 == </span><span class="s4">0</span><span class="s3">, </span><span class="s1">lax._ones(x1)</span><span class="s3">, </span><span class="s1">x1)))))</span>


<span class="s1">@_wraps(np.reciprocal</span><span class="s3">, </span><span class="s1">module=</span><span class="s5">'numpy'</span><span class="s1">)</span>
<span class="s1">@partial(jit</span><span class="s3">, </span><span class="s1">inline=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">reciprocal(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;reciprocal&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_dtypes_inexact(x)</span>
  <span class="s3">return </span><span class="s1">lax.integer_pow(x</span><span class="s3">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@_wraps(np.sinc</span><span class="s3">, </span><span class="s1">update_doc=</span><span class="s3">False</span><span class="s1">)</span>
<span class="s1">@jit</span>
<span class="s3">def </span><span class="s1">sinc(x: ArrayLike</span><span class="s3">, </span><span class="s1">/) -&gt; Array:</span>
  <span class="s1">check_arraylike(</span><span class="s5">&quot;sinc&quot;</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">x</span><span class="s3">, </span><span class="s1">= promote_dtypes_inexact(x)</span>
  <span class="s1">eq_zero = lax.eq(x</span><span class="s3">, </span><span class="s1">_lax_const(x</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
  <span class="s1">pi_x = lax.mul(_lax_const(x</span><span class="s3">, </span><span class="s1">np.pi)</span><span class="s3">, </span><span class="s1">x)</span>
  <span class="s1">safe_pi_x = _where(eq_zero</span><span class="s3">, </span><span class="s1">_lax_const(x</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">pi_x)</span>
  <span class="s3">return </span><span class="s1">_where(eq_zero</span><span class="s3">, </span><span class="s1">_sinc_maclaurin(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">pi_x)</span><span class="s3">,</span>
                <span class="s1">lax.div(lax.sin(safe_pi_x)</span><span class="s3">, </span><span class="s1">safe_pi_x))</span>


<span class="s1">@partial(custom_jvp</span><span class="s3">, </span><span class="s1">nondiff_argnums=(</span><span class="s4">0</span><span class="s3">,</span><span class="s1">))</span>
<span class="s3">def </span><span class="s1">_sinc_maclaurin(k</span><span class="s3">, </span><span class="s1">x):</span>
  <span class="s0"># compute the kth derivative of x -&gt; sin(x)/x evaluated at zero (since we</span>
  <span class="s0"># compute the monomial term in the jvp rule)</span>
  <span class="s0"># TODO(mattjj): see https://github.com/google/jax/issues/10750</span>
  <span class="s3">if </span><span class="s1">k % </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">x * </span><span class="s4">0</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">x * </span><span class="s4">0 </span><span class="s1">+ _lax_const(x</span><span class="s3">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s1">) ** (k // </span><span class="s4">2</span><span class="s1">) / (k + </span><span class="s4">1</span><span class="s1">))</span>

<span class="s1">@_sinc_maclaurin.defjvp</span>
<span class="s3">def </span><span class="s1">_sinc_maclaurin_jvp(k</span><span class="s3">, </span><span class="s1">primals</span><span class="s3">, </span><span class="s1">tangents):</span>
  <span class="s1">(x</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(t</span><span class="s3">,</span><span class="s1">) = primals</span><span class="s3">, </span><span class="s1">tangents</span>
  <span class="s3">return </span><span class="s1">_sinc_maclaurin(k</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">, </span><span class="s1">_sinc_maclaurin(k + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">x) * t</span>
</pre>
</body>
</html>