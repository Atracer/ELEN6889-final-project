<html>
<head>
<title>shape_poly.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shape_poly.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;Shape polymorphism support. 
 
We introduce a set of dimension variables at the top-level of a `jit` function. 
They are introduced implicitly by way of specifying for each dimension of each 
argument a symbolic dimension expression in terms of some dimension variables. 
All dimension variables are assumed to range over integers greater or equal to 1. 
 
Symbolic dimensions overload some integer operations, such as 
add, multiply, divide, equality, etc. The JAX NumPy layer and the LAX layers have been 
touched up to be sensitive to handling shapes that contain symbolic dimensions. 
This enables many JAX programs to be traced with symbolic dimensions 
in some dimensions. A priority has been to enable the batch 
dimension in neural network examples to be polymorphic. 
 
This was built initially for jax2tf, but it is now customizeable to be 
independent of TF. The best documentation at the moment is in the 
jax2tf.convert docstring, and the 
[README](https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md). 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">dataclasses</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">math</span>
<span class="s3">import </span><span class="s1">operator </span><span class="s3">as </span><span class="s1">op</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Set</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">opt_einsum</span>

<span class="s3">import </span><span class="s1">jax</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">config</span>
<span class="s3">from </span><span class="s1">jax.interpreters </span><span class="s3">import </span><span class="s1">xla</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">mlir</span>
<span class="s3">from </span><span class="s1">jax._src.numpy </span><span class="s3">import </span><span class="s1">lax_numpy</span>
<span class="s3">from </span><span class="s1">jax._src.lax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax._src.typing </span><span class="s3">import </span><span class="s1">DimSize</span><span class="s3">, </span><span class="s1">Shape</span>


<span class="s1">TfVal = Any</span>
<span class="s0"># A dimension environment maps dimension variables to expressions that</span>
<span class="s0"># compute the values of the dimension. An expression must support addition</span>
<span class="s0"># and multiplication with other expressions or with int32/int64, e.g.,</span>
<span class="s0"># by overloading __add__, __radd__, __mul__, __rmul__, __divmod__, __rdivmod__.</span>
<span class="s1">ShapeEnv = Dict[str</span><span class="s3">, </span><span class="s1">Any]</span>
<span class="s1">DType = Any</span>

<span class="s3">class </span><span class="s1">InconclusiveDimensionOperation(core.InconclusiveDimensionOperation):</span>
  <span class="s2">&quot;&quot;&quot;Raised when we cannot conclusively compute with symbolic dimensions.&quot;&quot;&quot;</span>

  <span class="s1">_help_msg = </span><span class="s4">&quot;&quot;&quot; 
This error arises for comparison operations with shapes that 
are non-constant, and the result of the operation cannot be represented as 
a boolean value for all values of the symbolic dimensions involved. 
 
Please see https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md#computing-with-dimension-variables 
for more details. 
&quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">message: str):</span>
    <span class="s1">error_msg = </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">message</span><span class="s3">}\n{</span><span class="s1">InconclusiveDimensionOperation._help_msg</span><span class="s3">}</span><span class="s4">&quot;</span>
    <span class="s0"># https://github.com/python/mypy/issues/5887</span>
    <span class="s1">super().__init__(error_msg)  </span><span class="s0"># type: ignore</span>

<span class="s3">class </span><span class="s1">_DimAtom:</span>
  <span class="s2">&quot;&quot;&quot;Represents an atom in a symbolic dimension expression. 
 
  Atoms are either variables, or expressions of the form floordiv(E1, E2) or 
  mod(E1, E2). Atoms are multiplied to form monomials (see _DimMon), and 
  monomials are added to form symbolic expressions (see _DimExpr). 
 
  Args: 
    * var: if specified then the atom is a dimension variable. `operation` 
      must be `None`. 
    * operation: if specified then the atom is an operation applied to 
      `operands`. One of `FLOORDIR` or `MOD`. `var` must be `None` 
    * operands: the operands to which the operation is applied. 
  &quot;&quot;&quot;</span>
  <span class="s0"># The supported operations</span>
  <span class="s1">FLOORDIV = </span><span class="s4">&quot;floordiv&quot;</span>
  <span class="s1">MOD = </span><span class="s4">&quot;mod&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*operands: </span><span class="s4">'_DimExpr'</span><span class="s3">,</span>
               <span class="s1">var: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">operation: Optional[str] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">assert </span><span class="s1">operation </span><span class="s3">is None</span>
      <span class="s3">assert not </span><span class="s1">operands</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">assert </span><span class="s1">operation </span><span class="s3">is not None</span>
    <span class="s1">self.var = var</span>
    <span class="s1">self.operation = operation</span>
    <span class="s1">self.operands = operands</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_var(cls</span><span class="s3">, </span><span class="s1">v: str) -&gt; </span><span class="s4">'_DimAtom'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimAtom(var=v)</span>

  <span class="s3">def </span><span class="s1">to_var(self) -&gt; Optional[str]:</span>
    <span class="s3">return </span><span class="s1">self.var</span>

  <span class="s3">def </span><span class="s1">get_vars(self) -&gt; Set[str]:</span>
    <span class="s0"># All the vars that appear</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">{self.var}</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">acc = set()</span>
      <span class="s3">for </span><span class="s1">opnd </span><span class="s3">in </span><span class="s1">self.operands:</span>
        <span class="s1">acc.update(opnd.get_vars())</span>
      <span class="s3">return </span><span class="s1">acc</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_operation(cls</span><span class="s3">, </span><span class="s1">operation: str</span><span class="s3">, </span><span class="s1">*operands: </span><span class="s4">'_DimExpr'</span><span class="s1">) -&gt; </span><span class="s4">'_DimAtom'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimAtom(*operands</span><span class="s3">, </span><span class="s1">operation=operation)</span>

  <span class="s3">def </span><span class="s1">__str__(self):</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self.var</span>
    <span class="s1">opnd_str = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([str(opnd) </span><span class="s3">for </span><span class="s1">opnd </span><span class="s3">in </span><span class="s1">self.operands])</span>
    <span class="s3">return </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">self.operation</span><span class="s3">}</span><span class="s4">(</span><span class="s3">{</span><span class="s1">opnd_str</span><span class="s3">}</span><span class="s4">)&quot;</span>
  <span class="s1">__repr__ = __str__</span>

  <span class="s3">def </span><span class="s1">__hash__(self):</span>
    <span class="s3">return </span><span class="s1">hash((self.var</span><span class="s3">, </span><span class="s1">self.operation</span><span class="s3">, </span><span class="s1">*self.operands))</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other: Any):</span>
    <span class="s0"># Used only for hashing</span>
    <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">_DimAtom): </span><span class="s3">return False</span>
    <span class="s3">if </span><span class="s1">(self.var </span><span class="s3">is None</span><span class="s1">) != (other.var </span><span class="s3">is None</span><span class="s1">): </span><span class="s3">return False</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self.var == other.var</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">def </span><span class="s1">symbolic_equal(e1: </span><span class="s4">'_DimExpr'</span><span class="s3">, </span><span class="s1">e2: </span><span class="s4">'_DimExpr'</span><span class="s1">) -&gt; bool:</span>
        <span class="s3">try</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">e1 == e2</span>
        <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation:</span>
          <span class="s3">return False</span>
      <span class="s3">return </span><span class="s1">(self.operation == other.operation </span><span class="s3">and</span>
              <span class="s1">all(symbolic_equal(self_o</span><span class="s3">, </span><span class="s1">other_o)</span>
                  <span class="s3">for </span><span class="s1">self_o</span><span class="s3">, </span><span class="s1">other_o </span><span class="s3">in </span><span class="s1">zip(self.operands</span><span class="s3">, </span><span class="s1">other.operands)))</span>

  <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other: </span><span class="s4">'_DimAtom'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Comparison to another atom in graded reverse lexicographic order. 
    Used only for determining a sorting order, does not relate to the 
    comparison of the values of the atom. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None and </span><span class="s1">other.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self.var &lt; other.var</span>
    <span class="s3">elif </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return True</span>
    <span class="s3">elif </span><span class="s1">other.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return True</span>
    <span class="s3">elif </span><span class="s1">self.operation != other.operation:</span>
      <span class="s3">return </span><span class="s1">self.operation &lt; other.operation  </span><span class="s0"># type: ignore</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">id(self) &lt; id(other)</span>

  <span class="s3">def </span><span class="s1">bounds(self) -&gt; Tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot;Returns the lower and upper bounds, or -+ inf.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.PINF)  </span><span class="s0"># variables are assumed to be &gt;= 1</span>
    <span class="s1">opnd_bounds = [opnd.bounds() </span><span class="s3">for </span><span class="s1">opnd </span><span class="s3">in </span><span class="s1">self.operands]</span>
    <span class="s3">if </span><span class="s1">self.operation == _DimAtom.FLOORDIV:  </span><span class="s0">#  a // b</span>
      <span class="s1">(a_l</span><span class="s3">, </span><span class="s1">a_u)</span><span class="s3">, </span><span class="s1">(b_l</span><span class="s3">, </span><span class="s1">b_u) = opnd_bounds</span>
      <span class="s3">def </span><span class="s1">math_floor_with_inf(a: float</span><span class="s3">, </span><span class="s1">b: float):  </span><span class="s0"># math.floor, but aware of inf</span>
        <span class="s3">assert </span><span class="s1">b != </span><span class="s5">0</span>
        <span class="s3">if not </span><span class="s1">np.isinf(b):  </span><span class="s0"># divisor is finite</span>
          <span class="s3">return </span><span class="s1">math.floor(a / b) </span><span class="s3">if not </span><span class="s1">np.isinf(a) </span><span class="s3">else </span><span class="s1">np.NINF </span><span class="s3">if </span><span class="s1">(a &gt;= </span><span class="s5">0</span><span class="s1">) != (b &gt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s3">else </span><span class="s1">np.PINF</span>
        <span class="s3">elif not </span><span class="s1">np.isinf(a):  </span><span class="s0"># dividend is finite and divisor is infinite</span>
          <span class="s3">return </span><span class="s1">-</span><span class="s5">1 </span><span class="s3">if </span><span class="s1">(a &gt;= </span><span class="s5">0</span><span class="s1">) != (b &gt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s3">else </span><span class="s5">0</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s0"># both dividend and divisor are infinite</span>
          <span class="s3">return </span><span class="s1">np.NINF </span><span class="s3">if </span><span class="s1">(a &gt;= </span><span class="s5">0</span><span class="s1">) != (b &gt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s3">else </span><span class="s1">np.PINF</span>

      <span class="s0"># Same reasoning as for multiplication: the bounds are among the cross-product</span>
      <span class="s0"># of the bounds.</span>
      <span class="s1">bound_candidates = [math_floor_with_inf(a_l</span><span class="s3">, </span><span class="s1">b_l)</span><span class="s3">, </span><span class="s1">math_floor_with_inf(a_l</span><span class="s3">, </span><span class="s1">b_u)</span><span class="s3">,</span>
                          <span class="s1">math_floor_with_inf(a_u</span><span class="s3">, </span><span class="s1">b_l)</span><span class="s3">, </span><span class="s1">math_floor_with_inf(a_u</span><span class="s3">, </span><span class="s1">b_u)]</span>
      <span class="s3">return </span><span class="s1">(min(*bound_candidates)</span><span class="s3">, </span><span class="s1">max(*bound_candidates))</span>

    <span class="s3">elif </span><span class="s1">self.operation == _DimAtom.MOD:</span>
      <span class="s1">_</span><span class="s3">, </span><span class="s1">(b_l</span><span class="s3">, </span><span class="s1">b_u) = opnd_bounds</span>
      <span class="s3">if </span><span class="s1">b_l &gt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># positive divisor</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">b_u - </span><span class="s5">1</span><span class="s1">)</span>
      <span class="s3">elif </span><span class="s1">b_u &lt; </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># negative divisor</span>
        <span class="s3">return </span><span class="s1">(b_l + </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">(np.NINF</span><span class="s3">, </span><span class="s1">np.PINF)</span>

    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">assert False</span>

  <span class="s3">def </span><span class="s1">evaluate(self</span><span class="s3">, </span><span class="s1">env: ShapeEnv):</span>
    <span class="s3">if </span><span class="s1">self.var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">env[self.var]</span>
      <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">err_msg = (</span>
            <span class="s4">f&quot;Encountered dimension variable '</span><span class="s3">{</span><span class="s1">self.var</span><span class="s3">}</span><span class="s4">' that is not appearing in the shapes of the used function arguments.</span><span class="s3">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Please see https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md#dimension-variables-must-be-solvable-from-the-input-shapes for more details.&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">KeyError(err_msg)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">operand_values = [opnd.evaluate(env) </span><span class="s3">for </span><span class="s1">opnd </span><span class="s3">in </span><span class="s1">self.operands]</span>
      <span class="s1">div_mod = divmod(*operand_values)  </span><span class="s0"># type: ignore</span>
      <span class="s3">if </span><span class="s1">self.operation == _DimAtom.FLOORDIV:</span>
        <span class="s3">return </span><span class="s1">div_mod[</span><span class="s5">0</span><span class="s1">]</span>
      <span class="s3">elif </span><span class="s1">self.operation == _DimAtom.MOD:</span>
        <span class="s3">return </span><span class="s1">div_mod[</span><span class="s5">1</span><span class="s1">]</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">assert False, </span><span class="s1">self.operation</span>

<span class="s3">class </span><span class="s1">_DimMon(dict):</span>
  <span class="s2">&quot;&quot;&quot;Represents a multiplication of atoms. 
 
  The representation is a dictionary mapping _DimAtom to exponent. 
  The exponents are integers &gt;= 1. 
  &quot;&quot;&quot;</span>
  <span class="s3">def </span><span class="s1">__hash__(self):</span>
    <span class="s3">return </span><span class="s1">hash(frozenset(self.items()))</span>

  <span class="s3">def </span><span class="s1">__str__(self):</span>
    <span class="s3">return </span><span class="s4">&quot;*&quot;</span><span class="s1">.join(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s4">^</span><span class="s3">{</span><span class="s1">exponent</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s3">if </span><span class="s1">exponent != </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">str(key)</span>
                    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">exponent </span><span class="s3">in </span><span class="s1">sorted(self.items()))</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_var(cls</span><span class="s3">, </span><span class="s1">v: str) -&gt; </span><span class="s4">'_DimMon'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimMon({_DimAtom.from_var(v): </span><span class="s5">1</span><span class="s1">})</span>

  <span class="s3">def </span><span class="s1">to_var(self) -&gt; Optional[str]:</span>
    <span class="s2">&quot;&quot;&quot;Extract the variable name &quot;x&quot;, from a monomial &quot;x&quot;. 
     Return None, if the monomial is not a single variable.&quot;&quot;&quot;</span>
    <span class="s1">items = self.items()</span>
    <span class="s3">if </span><span class="s1">len(items) != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return None</span>
    <span class="s1">(a</span><span class="s3">, </span><span class="s1">aexp)</span><span class="s3">, </span><span class="s1">= items</span>
    <span class="s3">if </span><span class="s1">aexp != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">a.to_var()</span>

  <span class="s3">def </span><span class="s1">get_vars(self) -&gt; Set[str]:</span>
    <span class="s0"># All the vars that appear in the monomial</span>
    <span class="s1">acc = set()</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">self.keys():</span>
      <span class="s1">acc.update(a.get_vars())</span>
    <span class="s3">return </span><span class="s1">acc</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_operation(cls</span><span class="s3">, </span><span class="s1">operation: str</span><span class="s3">, </span><span class="s1">*operands: </span><span class="s4">'_DimExpr'</span><span class="s1">) -&gt; </span><span class="s4">'_DimMon'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimMon({_DimAtom.from_operation(operation</span><span class="s3">, </span><span class="s1">*operands): </span><span class="s5">1</span><span class="s1">})</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">degree(self):</span>
    <span class="s3">return </span><span class="s1">sum(self.values())</span>

  <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other: </span><span class="s4">'_DimMon'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Comparison to another monomial in graded reverse lexicographic order. 
    Used only for determining a sorting order, does not relate to the 
    comparison of the values of the monomial. 
    &quot;&quot;&quot;</span>
    <span class="s1">self_key = -self.degree</span><span class="s3">, </span><span class="s1">tuple(sorted(self))</span>
    <span class="s1">other_key = -other.degree</span><span class="s3">, </span><span class="s1">tuple(sorted(other))</span>
    <span class="s3">return </span><span class="s1">self_key &gt; other_key</span>

  <span class="s3">def </span><span class="s1">mul(self</span><span class="s3">, </span><span class="s1">other: </span><span class="s4">'_DimMon'</span><span class="s1">) -&gt; </span><span class="s4">'_DimMon'</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Returns the product with another monomial. Example: (n^2*m) * n == n^3 * m. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_DimMon(collections.Counter(self) + collections.Counter(other))</span>

  <span class="s3">def </span><span class="s1">divide(self</span><span class="s3">, </span><span class="s1">divisor: </span><span class="s4">'_DimMon'</span><span class="s1">) -&gt; </span><span class="s4">'_DimMon'</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Divides by another monomial. Raises a InconclusiveDimensionOperation 
    if the result is not a monomial. 
    For example, (n^3 * m) // n == n^2*m, but n // m fails. 
    &quot;&quot;&quot;</span>
    <span class="s1">d = collections.Counter(self)</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">exponent </span><span class="s3">in </span><span class="s1">divisor.items():</span>
      <span class="s1">diff = self.get(key</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) - exponent</span>
      <span class="s3">if </span><span class="s1">diff &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">f&quot;Cannot divide </span><span class="s3">{</span><span class="s1">self</span><span class="s3">} </span><span class="s4">by </span><span class="s3">{</span><span class="s1">divisor</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>
      <span class="s3">elif </span><span class="s1">diff == </span><span class="s5">0</span><span class="s1">: </span><span class="s3">del </span><span class="s1">d[key]</span>
      <span class="s3">elif </span><span class="s1">diff &gt; </span><span class="s5">0</span><span class="s1">: d[key] = diff</span>
    <span class="s3">return </span><span class="s1">_DimMon(d)</span>

  <span class="s3">def </span><span class="s1">bounds(self) -&gt; Tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot;Returns the lower and upper bounds, or -+inf.&quot;&quot;&quot;</span>
    <span class="s0"># The bounds of a product are among the product of bounds.</span>
    <span class="s1">bounds = []</span>
    <span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">self.items():</span>
      <span class="s1">a_l</span><span class="s3">, </span><span class="s1">a_u = a.bounds()</span>
      <span class="s3">assert </span><span class="s1">a_l &lt;= a_u</span>
      <span class="s1">bounds.append((a_l ** exp</span><span class="s3">, </span><span class="s1">a_u ** exp))</span>

    <span class="s1">candidates = [np.prod(atom_bounds) </span><span class="s3">for </span><span class="s1">atom_bounds </span><span class="s3">in </span><span class="s1">itertools.product(*bounds)]</span>
    <span class="s3">return </span><span class="s1">(min(*candidates)</span><span class="s3">, </span><span class="s1">max(*candidates))  </span><span class="s0"># type: ignore</span>


  <span class="s3">def </span><span class="s1">evaluate(self</span><span class="s3">, </span><span class="s1">env: ShapeEnv):</span>
    <span class="s1">prod = </span><span class="s3">lambda </span><span class="s1">xs: functools.reduce(_evaluate_multiply</span><span class="s3">, </span><span class="s1">xs) </span><span class="s3">if </span><span class="s1">xs </span><span class="s3">else </span><span class="s1">dim_constant(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">pow_opt(v</span><span class="s3">, </span><span class="s1">p: int):</span>
      <span class="s3">return </span><span class="s1">v </span><span class="s3">if </span><span class="s1">p == </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">prod([v] * p)</span>
    <span class="s3">return </span><span class="s1">prod([pow_opt(a.evaluate(env)</span><span class="s3">, </span><span class="s1">deg) </span><span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">deg </span><span class="s3">in </span><span class="s1">self.items()])</span>


<span class="s3">class </span><span class="s1">_DimExpr():</span>
  <span class="s2">&quot;&quot;&quot;Symbolic expression in terms of dimension variables. 
 
  A dimension expression is an addition of products (_DimMon) 
  f atoms (_DimAtom). 
 
  We overload integer operations, but we do that soundly, raising 
  :class:`InconclusiveDimensionOperation` when the result is not 
  representable as a _DimExpr. 
 
  The representation of a _DimExpr is as a dictionary mapping _DimMon to 
  integer coefficients. The special monomial `_DimMon()` is mapped to the 
  free integer coefficient of the expression. 
  &quot;&quot;&quot;</span>

  <span class="s1">__array_priority__ = </span><span class="s5">1000   </span><span class="s0"># Same as tracer, for __radd__ and others on ndarray</span>
  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">coeffs: Dict[_DimMon</span><span class="s3">, </span><span class="s1">int]):</span>
    <span class="s0"># Do not construct _DimExpr directly, use _DimExpr.normalize</span>
    <span class="s1">self._coeffs = coeffs.copy() </span><span class="s3">or </span><span class="s1">{_DimMon(): </span><span class="s5">0</span><span class="s1">}</span>

  <span class="s3">def </span><span class="s1">monomials(self) -&gt; Iterable[Tuple[_DimMon</span><span class="s3">, </span><span class="s1">int]]:</span>
    <span class="s3">return </span><span class="s1">self._coeffs.items()</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">normalize(cls</span><span class="s3">, </span><span class="s1">coeffs: Dict[_DimMon</span><span class="s3">, </span><span class="s1">int]) -&gt; DimSize:</span>
    <span class="s2">&quot;&quot;&quot;The main constructor for _DimExpr. 
 
    Ensures that the symbolic dimension is normalized, e.g., 
    it is represented as a Python int if it is known to be a constant. 
    &quot;&quot;&quot;</span>
    <span class="s1">has_non_zero_degree = </span><span class="s3">False</span>
    <span class="s1">free_const = </span><span class="s5">0</span>
    <span class="s1">new_coeffs: Dict[_DimMon</span><span class="s3">, </span><span class="s1">int] = {}</span>
    <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">coeff </span><span class="s3">in </span><span class="s1">coeffs.items():</span>
      <span class="s3">if </span><span class="s1">coeff == </span><span class="s5">0</span><span class="s1">: </span><span class="s3">continue</span>
      <span class="s3">if </span><span class="s1">mon.degree == </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># A constant, there can be a single one</span>
        <span class="s1">free_const = coeff</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">has_non_zero_degree = </span><span class="s3">True</span>

      <span class="s0"># Look for floordiv(E, M) * M and turn into E - mod(E, M). This comes</span>
      <span class="s0"># up when handling strided convolution.</span>
      <span class="s3">def </span><span class="s1">normalize_floordiv_times(m: _DimMon</span><span class="s3">, </span><span class="s1">coeff: int) -&gt; Optional[</span><span class="s4">'_DimExpr'</span><span class="s1">]:</span>
        <span class="s1">floordivs = [(a</span><span class="s3">, </span><span class="s1">aexp) </span><span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">aexp </span><span class="s3">in </span><span class="s1">m.items() </span><span class="s3">if </span><span class="s1">a.operation == _DimAtom.FLOORDIV]</span>
        <span class="s0"># A single floordiv with exponent 1</span>
        <span class="s3">if </span><span class="s1">len(floordivs) != </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">floordivs[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">: </span><span class="s3">return None</span>
        <span class="s1">floordiv</span><span class="s3">, </span><span class="s1">_ = floordivs[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">floordiv_dividend_monomials = list(floordiv.operands[</span><span class="s5">1</span><span class="s1">].monomials())</span>
        <span class="s3">if </span><span class="s1">len(floordiv_dividend_monomials) != </span><span class="s5">1</span><span class="s1">: </span><span class="s3">return None</span>
        <span class="s1">floordiv_dividend_monomial</span><span class="s3">, </span><span class="s1">floordiv_dividend_coeff = floordiv_dividend_monomials[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">coeff % floordiv_dividend_coeff: </span><span class="s3">return None</span>
        <span class="s3">try</span><span class="s1">:</span>
          <span class="s1">m_trimmed = m.divide(floordiv_dividend_monomial)</span>
        <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation:</span>
          <span class="s3">return None</span>
        <span class="s1">c = coeff // floordiv_dividend_coeff</span>
        <span class="s1">m_trimmed = m_trimmed.divide(_DimMon({floordiv: </span><span class="s5">1</span><span class="s1">}))  </span><span class="s0"># Remove the floordiv</span>
        <span class="s3">return </span><span class="s1">(_DimExpr.from_monomial(m_trimmed</span><span class="s3">, </span><span class="s1">c) *</span>
                 <span class="s1">(floordiv.operands[</span><span class="s5">0</span><span class="s1">] - _DimExpr.from_operation(_DimAtom.MOD</span><span class="s3">, </span><span class="s1">*floordiv.operands)))</span>

      <span class="s1">mon_poly = normalize_floordiv_times(mon</span><span class="s3">, </span><span class="s1">coeff)</span>
      <span class="s3">if </span><span class="s1">mon_poly </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">monomials = mon_poly.monomials()</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">monomials = [(mon</span><span class="s3">, </span><span class="s1">coeff)]</span>
      <span class="s3">for </span><span class="s1">m</span><span class="s3">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">monomials:</span>
        <span class="s1">new_coeffs[m] = new_coeffs.get(m</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + c</span>

    <span class="s3">if </span><span class="s1">has_non_zero_degree:</span>
      <span class="s3">return </span><span class="s1">_DimExpr(new_coeffs)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">int(free_const)</span>


  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_monomial(cls</span><span class="s3">, </span><span class="s1">mon: _DimMon</span><span class="s3">, </span><span class="s1">exp: int):</span>
    <span class="s3">return </span><span class="s1">_DimExpr.normalize({mon: exp})</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_var(cls</span><span class="s3">, </span><span class="s1">v: str) -&gt; </span><span class="s4">'_DimExpr'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimExpr({_DimMon.from_var(v): </span><span class="s5">1</span><span class="s1">})</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">from_operation(cls</span><span class="s3">, </span><span class="s1">operation: str</span><span class="s3">, </span><span class="s1">*operands: </span><span class="s4">'_DimExpr'</span><span class="s1">) -&gt; </span><span class="s4">'_DimExpr'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimExpr.from_monomial(_DimMon.from_operation(operation</span><span class="s3">, </span><span class="s1">*operands)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">to_var(self) -&gt; Optional[str]:</span>
    <span class="s2">&quot;&quot;&quot;Extract the variable name &quot;x&quot;, from a symbolic expression.&quot;&quot;&quot;</span>
    <span class="s1">items = self.monomials()</span>
    <span class="s3">if </span><span class="s1">len(items) != </span><span class="s5">1</span><span class="s1">:  </span><span class="s0"># type: ignore</span>
      <span class="s3">return None</span>
    <span class="s1">(mon</span><span class="s3">, </span><span class="s1">mon_count)</span><span class="s3">, </span><span class="s1">= items</span>
    <span class="s3">if </span><span class="s1">mon_count != </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return None</span>
    <span class="s3">return </span><span class="s1">mon.to_var()</span>

  <span class="s3">def </span><span class="s1">get_vars(self) -&gt; Set[str]:</span>
    <span class="s2">&quot;&quot;&quot;The variables that appear in a symbolic dimension.&quot;&quot;&quot;</span>
    <span class="s1">acc = set()</span>
    <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self.monomials():</span>
      <span class="s1">acc.update(mon.get_vars())</span>
    <span class="s3">return </span><span class="s1">acc</span>

  <span class="s3">def </span><span class="s1">eq(self</span><span class="s3">, </span><span class="s1">other: DimSize) -&gt; bool:</span>
    <span class="s1">lb</span><span class="s3">, </span><span class="s1">ub = _ensure_poly(self - other</span><span class="s3">, </span><span class="s4">&quot;eq&quot;</span><span class="s1">).bounds()</span>
    <span class="s3">if </span><span class="s1">lb == ub == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return True</span>
    <span class="s3">if </span><span class="s1">lb &gt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ub &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return False</span>
    <span class="s0"># See https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md#comparison-of-symbolic-dimensions-is-partially-supported</span>
    <span class="s3">return False</span>

  <span class="s3">def </span><span class="s1">ge(self</span><span class="s3">, </span><span class="s1">other: DimSize) -&gt; bool:</span>
    <span class="s1">lb</span><span class="s3">, </span><span class="s1">ub = _ensure_poly(self - other</span><span class="s3">, </span><span class="s4">&quot;ge&quot;</span><span class="s1">).bounds()</span>
    <span class="s3">if </span><span class="s1">lb &gt;= </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return True</span>
    <span class="s3">if </span><span class="s1">ub &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return False</span>
    <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span>
        <span class="s4">f&quot;Symbolic dimension comparison '</span><span class="s3">{</span><span class="s1">self</span><span class="s3">}</span><span class="s4">' &gt;= '</span><span class="s3">{</span><span class="s1">other</span><span class="s3">}</span><span class="s4">' is inconclusive.</span><span class="s3">\n</span><span class="s4">&quot;</span>
        <span class="s4">&quot;See https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md#comparison-of-symbolic0dimensions-is-partially-supported.&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__hash__(self):</span>
    <span class="s3">return </span><span class="s1">hash(tuple(sorted(self.monomials())))</span>

  <span class="s3">def </span><span class="s1">__str__(self):</span>
    <span class="s3">def </span><span class="s1">_one_monomial(mon</span><span class="s3">, </span><span class="s1">c):</span>
      <span class="s3">if </span><span class="s1">mon.degree == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">str(c)</span>
      <span class="s3">if </span><span class="s1">c == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">str(mon)</span>
      <span class="s3">return </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">c</span><span class="s3">}</span><span class="s4">*</span><span class="s3">{</span><span class="s1">mon</span><span class="s3">}</span><span class="s4">&quot;</span>
    <span class="s3">return </span><span class="s4">&quot; + &quot;</span><span class="s1">.join(_one_monomial(mon</span><span class="s3">, </span><span class="s1">c)</span>
                      <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">sorted(self.monomials()</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">))</span>

  <span class="s3">def </span><span class="s1">__repr__(self):</span>
    <span class="s3">return </span><span class="s1">str(self)</span>

  <span class="s0"># We overload +, -, *, because they are fully defined for _DimExpr.</span>
  <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__add__(other)</span>

    <span class="s1">other = _ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;add&quot;</span><span class="s1">)</span>
    <span class="s1">coeffs = self._coeffs.copy()</span>
    <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">coeff </span><span class="s3">in </span><span class="s1">other.monomials():</span>
      <span class="s1">coeffs[mon] = coeffs.get(mon</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + coeff</span>
    <span class="s3">return </span><span class="s1">_DimExpr.normalize(coeffs)</span>

  <span class="s3">def </span><span class="s1">__radd__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__radd__(other)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;add&quot;</span><span class="s1">).__add__(self)</span>

  <span class="s3">def </span><span class="s1">__sub__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__sub__(other)</span>
    <span class="s3">return </span><span class="s1">self + -_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;sub&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__rsub__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__rsub__(other)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;sub&quot;</span><span class="s1">).__sub__(self)</span>

  <span class="s3">def </span><span class="s1">__neg__(self) -&gt; </span><span class="s4">'_DimExpr'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">_DimExpr({mon: -coeff </span><span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">coeff </span><span class="s3">in </span><span class="s1">self.monomials()})</span>

  <span class="s3">def </span><span class="s1">__mul__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__mul__(other)</span>
    <span class="s1">other = _ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;mul&quot;</span><span class="s1">)</span>
    <span class="s1">coeffs: Dict[_DimMon</span><span class="s3">, </span><span class="s1">int] = {}</span>
    <span class="s3">for </span><span class="s1">mon1</span><span class="s3">, </span><span class="s1">coeff1 </span><span class="s3">in </span><span class="s1">self.monomials():</span>
      <span class="s3">for </span><span class="s1">mon2</span><span class="s3">, </span><span class="s1">coeff2 </span><span class="s3">in </span><span class="s1">other.monomials():</span>
        <span class="s1">mon = mon1.mul(mon2)</span>
        <span class="s1">coeffs[mon] = coeffs.get(mon</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + coeff1 * coeff2</span>
    <span class="s3">return </span><span class="s1">_DimExpr.normalize(coeffs)</span>

  <span class="s3">def </span><span class="s1">__rmul__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__rmul__(other)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;mul&quot;</span><span class="s1">).__mul__(self)</span>

  <span class="s3">def </span><span class="s1">__pow__(self</span><span class="s3">, </span><span class="s1">power</span><span class="s3">, </span><span class="s1">modulo=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">assert </span><span class="s1">modulo </span><span class="s3">is None</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">power = int(power)</span>
    <span class="s3">except</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">f&quot;Symblic dimension cannot be raised to non-integer power '</span><span class="s3">{</span><span class="s1">self</span><span class="s3">}</span><span class="s4">' ^ '</span><span class="s3">{</span><span class="s1">power</span><span class="s3">}</span><span class="s4">'&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">functools.reduce(op.mul</span><span class="s3">, </span><span class="s1">[self] * power)</span>

  <span class="s3">def </span><span class="s1">__floordiv__(self</span><span class="s3">, </span><span class="s1">divisor):</span>
    <span class="s3">if </span><span class="s1">isinstance(divisor</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(divisor):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__floordiv__(divisor)</span>
    <span class="s3">return </span><span class="s1">self.divmod(_ensure_poly(divisor</span><span class="s3">, </span><span class="s4">&quot;floordiv&quot;</span><span class="s1">))[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__rfloordiv__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(other):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__rfloordiv__(other)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;floordiv&quot;</span><span class="s1">).__floordiv__(self)</span>

  <span class="s3">def </span><span class="s1">__truediv__(self</span><span class="s3">, </span><span class="s1">divisor):</span>
    <span class="s0"># Used for &quot;/&quot;, which always returns a float</span>
    <span class="s3">return </span><span class="s1">self.__jax_array__().__truediv__(divisor)</span>

  <span class="s3">def </span><span class="s1">__rtruediv__(self</span><span class="s3">, </span><span class="s1">dividend):</span>
    <span class="s0"># Used for &quot;/&quot;, when dividend is not a _DimExpr</span>
    <span class="s3">return </span><span class="s1">self.__jax_array__().__rtruediv__(dividend)</span>

  <span class="s3">def </span><span class="s1">__mod__(self</span><span class="s3">, </span><span class="s1">divisor):</span>
    <span class="s3">if </span><span class="s1">isinstance(divisor</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(divisor):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__mod__(divisor)</span>
    <span class="s3">return </span><span class="s1">self.divmod(_ensure_poly(divisor</span><span class="s3">, </span><span class="s4">&quot;mod&quot;</span><span class="s1">))[</span><span class="s5">1</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__rmod__(self</span><span class="s3">, </span><span class="s1">dividend):</span>
    <span class="s3">if </span><span class="s1">isinstance(dividend</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(dividend):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__rmod__(dividend)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(dividend</span><span class="s3">, </span><span class="s4">&quot;mod&quot;</span><span class="s1">).__mod__(self)</span>

  <span class="s3">def </span><span class="s1">__divmod__(self</span><span class="s3">, </span><span class="s1">divisor):</span>
    <span class="s3">if </span><span class="s1">isinstance(divisor</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(divisor):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__divmod__(divisor)</span>
    <span class="s3">return </span><span class="s1">self.divmod(_ensure_poly(divisor</span><span class="s3">, </span><span class="s4">&quot;divmod&quot;</span><span class="s1">))</span>

  <span class="s3">def </span><span class="s1">__rdivmod__(self</span><span class="s3">, </span><span class="s1">dividend):</span>
    <span class="s3">if </span><span class="s1">isinstance(dividend</span><span class="s3">, </span><span class="s1">core.Tracer) </span><span class="s3">or not </span><span class="s1">_convertible_to_poly(dividend):</span>
      <span class="s3">return </span><span class="s1">self.__jax_array__().__rdivmod__(dividend)</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(dividend</span><span class="s3">, </span><span class="s4">&quot;divmod&quot;</span><span class="s1">).__divmod__(self)</span>

  <span class="s3">def </span><span class="s1">__int__(self):</span>
    <span class="s3">if </span><span class="s1">self.is_constant:</span>
      <span class="s3">return </span><span class="s1">op.index(next(iter(self._coeffs.values())))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">f&quot;Symbolic dimension '</span><span class="s3">{</span><span class="s1">self</span><span class="s3">}</span><span class="s4">' used in a context that requires a constant&quot;</span><span class="s1">)</span>

  <span class="s0"># We must overload __eq__ and __ne__, or else we get unsound defaults.</span>
  <span class="s1">__eq__ = eq</span>
  <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other: DimSize) -&gt; bool:</span>
    <span class="s3">return not </span><span class="s1">self.eq(other)</span>

  <span class="s1">__ge__ = ge</span>

  <span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other: DimSize):</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;le&quot;</span><span class="s1">).__ge__(self)</span>

  <span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other: DimSize):</span>
    <span class="s3">return not </span><span class="s1">_ensure_poly(other</span><span class="s3">, </span><span class="s4">&quot;gt&quot;</span><span class="s1">).__ge__(self)</span>

  <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other: DimSize):</span>
    <span class="s3">return not </span><span class="s1">self.__ge__(other)</span>

  <span class="s3">def </span><span class="s1">divmod(self</span><span class="s3">, </span><span class="s1">divisor: </span><span class="s4">&quot;_DimExpr&quot;</span><span class="s1">) -&gt; Tuple[DimSize</span><span class="s3">, </span><span class="s1">int]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Floor division with remainder (divmod) generalized to polynomials. 
    If the `divisor` is not a constant, the remainder must be 0. 
    If the `divisor` is a constant, the remainder may be non 0, for consistency 
    with integer divmod. 
 
    :return: Quotient resulting from polynomial division and integer remainder. 
    &quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(divisor</span><span class="s3">, </span><span class="s1">_DimExpr)</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">dmon</span><span class="s3">, </span><span class="s1">dcount = divisor.leading_term</span>
      <span class="s1">dividend</span><span class="s3">, </span><span class="s1">quotient = self</span><span class="s3">, </span><span class="s5">0</span>
      <span class="s0"># invariant: self = dividend + divisor * quotient</span>
      <span class="s0"># quotient and dividend are changed in the loop; the leading term of</span>
      <span class="s0"># dividend decreases at each iteration.</span>
      <span class="s3">while </span><span class="s1">is_poly_dim(dividend) </span><span class="s3">and not </span><span class="s1">dividend.is_constant:</span>
        <span class="s1">mon</span><span class="s3">, </span><span class="s1">count = dividend.leading_term</span>
        <span class="s3">try</span><span class="s1">:</span>
          <span class="s1">qmon = mon.divide(dmon)</span>
        <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation:</span>
          <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">qcount</span><span class="s3">, </span><span class="s1">rcount = divmod(count</span><span class="s3">, </span><span class="s1">dcount)</span>
        <span class="s3">if </span><span class="s1">rcount != </span><span class="s5">0</span><span class="s1">:</span>
          <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">q = _DimExpr.from_monomial(qmon</span><span class="s3">, </span><span class="s1">qcount)</span>
        <span class="s1">quotient += q</span>
        <span class="s1">dividend -= q * divisor  </span><span class="s0"># type: ignore[assignment]</span>

      <span class="s1">dividend = int(dividend)  </span><span class="s0"># type: ignore[assignment]</span>
      <span class="s3">if </span><span class="s1">divisor.is_constant:</span>
        <span class="s1">q</span><span class="s3">, </span><span class="s1">r = divmod(dividend</span><span class="s3">, </span><span class="s1">int(divisor))  </span><span class="s0"># type: ignore</span>
        <span class="s1">quotient += q</span>
        <span class="s1">remainder = r</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">dividend != </span><span class="s5">0</span><span class="s1">:</span>
          <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">remainder = </span><span class="s5">0</span>

      <span class="s3">if </span><span class="s1">config.jax_enable_checks:</span>
        <span class="s3">assert </span><span class="s1">self == divisor * quotient + remainder</span>
      <span class="s3">return </span><span class="s1">quotient</span><span class="s3">, </span><span class="s1">remainder</span>
    <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation:</span>
      <span class="s3">return </span><span class="s1">(_DimExpr.from_operation(_DimAtom.FLOORDIV</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">divisor)</span><span class="s3">,  </span><span class="s0"># type: ignore</span>
              <span class="s1">_DimExpr.from_operation(_DimAtom.MOD</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">divisor))</span>

  <span class="s3">def </span><span class="s1">bounds(self) -&gt; Tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot;Returns the lower and upper bounds, or -+inf.&quot;&quot;&quot;</span>
    <span class="s1">lb = ub = self._coeffs.get(_DimMon()</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)  </span><span class="s0"># The free coefficient</span>
    <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">coeff </span><span class="s3">in </span><span class="s1">self.monomials():</span>
      <span class="s3">if </span><span class="s1">mon.degree == </span><span class="s5">0</span><span class="s1">: </span><span class="s3">continue  </span><span class="s0"># We already included the free coefficient</span>
      <span class="s1">m_l</span><span class="s3">, </span><span class="s1">m_u = mon.bounds()</span>
      <span class="s3">assert </span><span class="s1">m_l &lt;= m_u </span><span class="s3">and </span><span class="s1">coeff != </span><span class="s5">0</span>
      <span class="s1">item_l</span><span class="s3">, </span><span class="s1">item_u = coeff * m_l</span><span class="s3">, </span><span class="s1">coeff * m_u</span>
      <span class="s1">lb = lb + min(item_l</span><span class="s3">, </span><span class="s1">item_u)  </span><span class="s0"># type: ignore</span>
      <span class="s1">ub = ub + max(item_l</span><span class="s3">, </span><span class="s1">item_u)  </span><span class="s0"># type: ignore</span>

    <span class="s3">return </span><span class="s1">lb</span><span class="s3">, </span><span class="s1">ub</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">is_constant(self):</span>
    <span class="s3">return </span><span class="s1">len(self._coeffs) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">next(iter(self._coeffs)).degree == </span><span class="s5">0</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">leading_term(self) -&gt; Tuple[_DimMon</span><span class="s3">, </span><span class="s1">int]:</span>
    <span class="s2">&quot;&quot;&quot;Returns the highest degree term that comes first lexicographically.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">max(self.monomials())</span>

  <span class="s3">def </span><span class="s1">evaluate(self</span><span class="s3">, </span><span class="s1">env: ShapeEnv):</span>
    <span class="s0"># Evaluates as a value of dtype=dim_as_value_dtype()</span>
    <span class="s1">terms = [_evaluate_multiply(mon.evaluate(env)</span><span class="s3">, </span><span class="s1">dim_constant(coeff)) </span><span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">coeff </span><span class="s3">in </span><span class="s1">self.monomials()]</span>
    <span class="s3">return </span><span class="s1">functools.reduce(_evaluate_add</span><span class="s3">, </span><span class="s1">terms) </span><span class="s3">if </span><span class="s1">len(terms) &gt; </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">terms[</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s1">@staticmethod</span>
  <span class="s3">def </span><span class="s1">get_aval(dim: </span><span class="s4">&quot;_DimExpr&quot;</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">dim_as_value_abstract(dim)</span>

  <span class="s3">def </span><span class="s1">dimension_as_value(self):</span>
    <span class="s2">&quot;&quot;&quot;Turns a dimension size into a Jax value that we can compute with.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_dim_as_value(self)</span>

  <span class="s3">def </span><span class="s1">__jax_array__(self):</span>
    <span class="s0"># Used for implicit coercions of polynomials as JAX arrays</span>
    <span class="s3">return </span><span class="s1">_dim_as_value(self)</span>

<span class="s1">core.pytype_aval_mappings[_DimExpr] = _DimExpr.get_aval</span>
<span class="s1">xla.pytype_aval_mappings[_DimExpr] = _DimExpr.get_aval</span>
<span class="s1">dtypes._weak_types.append(_DimExpr)</span>

<span class="s3">def </span><span class="s1">_convertible_to_int(p: DimSize) -&gt; bool:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">op.index(p)</span>
    <span class="s3">return True</span>
  <span class="s3">except</span><span class="s1">:</span>
    <span class="s3">return False</span>

<span class="s3">def </span><span class="s1">_ensure_poly(p: DimSize</span><span class="s3">,</span>
                 <span class="s1">operation_name: str) -&gt; _DimExpr:</span>
  <span class="s3">if </span><span class="s1">isinstance(p</span><span class="s3">, </span><span class="s1">_DimExpr): </span><span class="s3">return </span><span class="s1">p</span>
  <span class="s3">if </span><span class="s1">_convertible_to_int(p):</span>
    <span class="s3">return </span><span class="s1">_DimExpr({_DimMon(): op.index(p)})</span>
  <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Symnbolic dimension </span><span class="s3">{</span><span class="s1">operation_name</span><span class="s3">} </span><span class="s4">not supported for </span><span class="s3">{</span><span class="s1">p</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_convertible_to_poly(p: DimSize) -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">isinstance(p</span><span class="s3">, </span><span class="s1">_DimExpr) </span><span class="s3">or </span><span class="s1">_convertible_to_int(p)</span>

<span class="s3">def </span><span class="s1">is_poly_dim(p: DimSize) -&gt; bool:</span>
  <span class="s3">return </span><span class="s1">isinstance(p</span><span class="s3">, </span><span class="s1">_DimExpr)</span>


<span class="s3">class </span><span class="s1">DimensionHandlerPoly(core.DimensionHandler):</span>
  <span class="s2">&quot;&quot;&quot;See core.DimensionHandler. 
 
  Most methods are inherited. 
  &quot;&quot;&quot;</span>
  <span class="s3">def </span><span class="s1">is_constant(self</span><span class="s3">, </span><span class="s1">d: DimSize) -&gt; bool:</span>
    <span class="s3">assert </span><span class="s1">isinstance(d</span><span class="s3">, </span><span class="s1">_DimExpr)</span>
    <span class="s3">return False</span>

  <span class="s3">def </span><span class="s1">symbolic_equal(self</span><span class="s3">, </span><span class="s1">d1: core.DimSize</span><span class="s3">, </span><span class="s1">d2: core.DimSize) -&gt; bool:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">_ensure_poly(d1</span><span class="s3">, </span><span class="s4">&quot;equal&quot;</span><span class="s1">) == d2</span>
    <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation:</span>
      <span class="s3">return False</span>

  <span class="s3">def </span><span class="s1">greater_equal(self</span><span class="s3">, </span><span class="s1">d1: DimSize</span><span class="s3">, </span><span class="s1">d2: DimSize):</span>
    <span class="s3">return </span><span class="s1">_ensure_poly(d1</span><span class="s3">, </span><span class="s4">&quot;ge&quot;</span><span class="s1">) &gt;= d2</span>

  <span class="s3">def </span><span class="s1">divide_shape_sizes(self</span><span class="s3">, </span><span class="s1">s1: Shape</span><span class="s3">, </span><span class="s1">s2: Shape) -&gt; DimSize:</span>
    <span class="s1">sz1 = np.prod(s1)</span>
    <span class="s1">sz2 = np.prod(s2)</span>
    <span class="s3">if </span><span class="s1">core.symbolic_equal_dim(sz1</span><span class="s3">, </span><span class="s1">sz2):  </span><span class="s0"># Takes care also of sz1 == sz2 == 0</span>
      <span class="s3">return </span><span class="s5">1</span>
    <span class="s1">err_msg = </span><span class="s4">f&quot;Cannot divide evenly the sizes of shapes </span><span class="s3">{</span><span class="s1">tuple(s1)</span><span class="s3">} </span><span class="s4">and </span><span class="s3">{</span><span class="s1">tuple(s2)</span><span class="s3">}</span><span class="s4">&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">q</span><span class="s3">, </span><span class="s1">r = _ensure_poly(sz1</span><span class="s3">, </span><span class="s4">&quot;divide_shape&quot;</span><span class="s1">).divmod(_ensure_poly(sz2</span><span class="s3">, </span><span class="s4">&quot;divide_shape&quot;</span><span class="s1">))</span>
    <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(err_msg + </span><span class="s4">f&quot;</span><span class="s3">\n</span><span class="s4">Details: </span><span class="s3">{</span><span class="s1">e</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">core.symbolic_equal_dim(r</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
      <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(err_msg + </span><span class="s4">f&quot;</span><span class="s3">\n</span><span class="s4">Remainder is not zero: </span><span class="s3">{</span><span class="s1">r</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">q  </span><span class="s0"># type: ignore[return-value]</span>

  <span class="s3">def </span><span class="s1">stride(self</span><span class="s3">, </span><span class="s1">d: DimSize</span><span class="s3">, </span><span class="s1">window_size: DimSize</span><span class="s3">, </span><span class="s1">window_stride: DimSize) -&gt; DimSize:</span>
    <span class="s2">&quot;&quot;&quot;Implements `(d - window_size) // window_stride + 1`&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s0"># TODO(necula): check for d == 0 or window_size &gt; d and return 0.</span>
      <span class="s1">q</span><span class="s3">, </span><span class="s1">r = _ensure_poly(d - window_size</span><span class="s3">, </span><span class="s4">&quot;stride&quot;</span><span class="s1">).divmod(_ensure_poly(window_stride</span><span class="s3">, </span><span class="s4">&quot;stride&quot;</span><span class="s1">))</span>
      <span class="s3">return </span><span class="s1">q + </span><span class="s5">1</span>
    <span class="s3">except </span><span class="s1">InconclusiveDimensionOperation </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s3">raise </span><span class="s1">InconclusiveDimensionOperation(</span>
          <span class="s4">f&quot;Cannot compute stride for dimension '</span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s4">', &quot;</span>
          <span class="s4">f&quot;window_size '</span><span class="s3">{</span><span class="s1">window_size</span><span class="s3">}</span><span class="s4">', stride '</span><span class="s3">{</span><span class="s1">window_stride</span><span class="s3">}</span><span class="s4">'.</span><span class="s3">\n</span><span class="s4">Details: </span><span class="s3">{</span><span class="s1">e</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">d</span>

  <span class="s3">def </span><span class="s1">as_value(self</span><span class="s3">, </span><span class="s1">d: DimSize):</span>
    <span class="s2">&quot;&quot;&quot;Turns a dimension size into a Jax value that we can compute with.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_dim_as_value(d)</span>

<span class="s1">core._SPECIAL_DIMENSION_HANDLERS[_DimExpr] = DimensionHandlerPoly()</span>
<span class="s1">dtypes.python_scalar_dtypes[_DimExpr] = dtypes.python_scalar_dtypes[int]</span>

<span class="s3">def </span><span class="s1">_einsum_contract_path(*operands</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s2">&quot;&quot;&quot;Like opt_einsum.contract_path, with support for DimExpr shapes. 
 
  We use opt_einsum.contract_path to compute the schedule, using a fixed 
  constant for all dimension variables. This is safe because we throw an 
  error if there are more than 1 contractions. Essentially, we just use 
  opt_einsum.contract_path to parse the specification. 
  &quot;&quot;&quot;</span>

  <span class="s0"># Replace the polymorphic shapes with some concrete shapes for calling</span>
  <span class="s0"># into opt_einsum.contract_path, because the latter wants to compute the</span>
  <span class="s0"># sizes of operands and intermediate results.</span>
  <span class="s1">fake_ops = []</span>
  <span class="s3">for </span><span class="s1">operand </span><span class="s3">in </span><span class="s1">operands:</span>
    <span class="s0"># We replace only array operands</span>
    <span class="s3">if not </span><span class="s1">hasattr(operand</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s1">):</span>
      <span class="s1">fake_ops.append(operand)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">shape = np.shape(operand)</span>
      <span class="s3">def </span><span class="s1">fake_dim(d):</span>
        <span class="s3">if </span><span class="s1">core.is_constant_dim(d):</span>
          <span class="s3">return </span><span class="s1">d</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s3">if not </span><span class="s1">isinstance(d</span><span class="s3">, </span><span class="s1">_DimExpr):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Encountered unexpected shape dimension </span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
          <span class="s0"># It is Ok to replace all polynomials with the same value. We may miss</span>
          <span class="s0"># here some errors due to non-equal dimensions, but we catch them</span>
          <span class="s0"># later.</span>
          <span class="s3">return </span><span class="s5">8</span>
      <span class="s1">fake_ops.append(jax.ShapeDtypeStruct(tuple(map(fake_dim</span><span class="s3">, </span><span class="s1">shape))</span><span class="s3">,</span>
                                           <span class="s1">operand.dtype))</span>

  <span class="s1">contract_fake_ops</span><span class="s3">, </span><span class="s1">contractions = opt_einsum.contract_path(*fake_ops</span><span class="s3">,</span>
                                                             <span class="s1">**kwargs)</span>
  <span class="s1">contract_operands = []</span>
  <span class="s3">for </span><span class="s1">operand </span><span class="s3">in </span><span class="s1">contract_fake_ops:</span>
    <span class="s1">idx = tuple(i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">fake_op </span><span class="s3">in </span><span class="s1">enumerate(fake_ops) </span><span class="s3">if </span><span class="s1">operand </span><span class="s3">is </span><span class="s1">fake_op)</span>
    <span class="s3">assert </span><span class="s1">len(idx) == </span><span class="s5">1</span>
    <span class="s1">contract_operands.append(operands[idx[</span><span class="s5">0</span><span class="s1">]])</span>
  <span class="s3">return </span><span class="s1">contract_operands</span><span class="s3">, </span><span class="s1">contractions</span>

<span class="s1">lax_numpy._poly_einsum_handlers[_DimExpr] = _einsum_contract_path</span>

<span class="s0"># A JAX primitive with no array arguments but with a dimension parameter</span>
<span class="s0"># that is a DimExpr. The value of the primitive is the value of the dimension,</span>
<span class="s0"># using int64 in x64 mode or int32 otherwise (dim_as_value_dtype())</span>
<span class="s1">dim_as_value_p = core.Primitive(</span><span class="s4">&quot;dim_as_value&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">dim_as_value_dtype():</span>
  <span class="s3">return </span><span class="s1">dtypes.canonicalize_dtype(np.int64)</span>

<span class="s3">def </span><span class="s1">dim_constant(ct: int):</span>
  <span class="s3">return </span><span class="s1">np.array(ct</span><span class="s3">, </span><span class="s1">dtype=dim_as_value_dtype())</span>

<span class="s3">def </span><span class="s1">dim_as_value_abstract(dim: DimSize) -&gt; core.AbstractValue:</span>
  <span class="s3">return </span><span class="s1">core.ShapedArray(()</span><span class="s3">, </span><span class="s1">dim_as_value_dtype()</span><span class="s3">, </span><span class="s1">weak_type=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">dim_as_value_p.def_abstract_eval(dim_as_value_abstract)</span>

<span class="s3">def </span><span class="s1">dim_as_value_impl(dim: DimSize):</span>
  <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
      <span class="s4">&quot;Evaluation rule for 'dim_as_value' is not implemented. &quot;</span>
      <span class="s4">&quot;It seems that you are using shape polymorphism outside jax2tf.&quot;</span><span class="s1">)</span>

<span class="s1">dim_as_value_p.def_impl(dim_as_value_impl)</span>
<span class="s3">def </span><span class="s1">_dim_as_value(dim: DimSize):</span>
  <span class="s3">return </span><span class="s1">dim_as_value_p.bind(dim=dim)</span>

<span class="s3">def </span><span class="s1">_dim_as_value_lowering(ctx: mlir.LoweringRuleContext</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
                           <span class="s1">dim):</span>
  <span class="s1">res</span><span class="s3">, </span><span class="s1">= mlir.eval_dynamic_shape(ctx</span><span class="s3">, </span><span class="s1">(dim</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s1">out_type = mlir.aval_to_ir_type(ctx.avals_out[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s3">if </span><span class="s1">out_type != res.type:  </span><span class="s0"># type: ignore</span>
    <span class="s3">return </span><span class="s1">mlir.hlo.ConvertOp(out_type</span><span class="s3">, </span><span class="s1">res).results</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">[res]</span>

<span class="s1">mlir.register_lowering(dim_as_value_p</span><span class="s3">, </span><span class="s1">_dim_as_value_lowering)</span>


<span class="s3">class </span><span class="s1">PolyShape(tuple):</span>
  <span class="s2">&quot;&quot;&quot;Tuple of polymorphic dimension specifications. 
 
  See docstring of :func:`jax2tf.convert`. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*dim_specs):</span>
    <span class="s1">tuple.__init__(dim_specs)</span>

  <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">*dim_specs):</span>
    <span class="s3">for </span><span class="s1">ds </span><span class="s3">in </span><span class="s1">dim_specs:</span>
      <span class="s3">if not </span><span class="s1">isinstance(ds</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">str)) </span><span class="s3">and </span><span class="s1">ds != ...:</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;Invalid polymorphic shape element: </span><span class="s3">{</span><span class="s1">repr(ds)</span><span class="s3">}</span><span class="s4">; must be a string &quot;</span>
               <span class="s4">&quot;representing a dimension variable, or an integer, or ...&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s3">return </span><span class="s1">tuple.__new__(PolyShape</span><span class="s3">, </span><span class="s1">dim_specs)</span>


<span class="s3">def </span><span class="s1">_parse_spec(spec: Optional[Union[str</span><span class="s3">, </span><span class="s1">PolyShape]]</span><span class="s3">,</span>
                <span class="s1">arg_shape: Sequence[Optional[int]]) -&gt; Tuple[DimSize</span><span class="s3">, </span><span class="s1">...]:</span>
  <span class="s2">&quot;&quot;&quot;Parse the shape polymorphic specification for one array argument. 
  Args: 
    spec: a shape polymorphic specification, either a string, or a PolyShape. 
    arg_shape: an actual shape, possibly containing unknown dimensions (None). 
 
  The placeholders `_` in the specification are replaced with the values from 
  the actual shape, which must be known. 
 
  See the README.md for usage. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">spec </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">spec_tuple = (...</span><span class="s3">,</span><span class="s1">)  </span><span class="s0"># type: Tuple[Any,...]</span>
  <span class="s3">elif </span><span class="s1">isinstance(spec</span><span class="s3">, </span><span class="s1">PolyShape):</span>
    <span class="s1">spec_tuple = spec</span>
  <span class="s3">elif </span><span class="s1">isinstance(spec</span><span class="s3">, </span><span class="s1">str):</span>
    <span class="s1">spec_ = spec.strip()</span>
    <span class="s3">if </span><span class="s1">spec_[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;(&quot;</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">spec_[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s4">&quot;)&quot;</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">has invalid syntax&quot;</span><span class="s1">)</span>
      <span class="s1">spec_ = spec_[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
      <span class="s1">spec_ = spec_.strip()</span>
    <span class="s1">spec_ = spec_.rstrip(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">spec_:</span>
      <span class="s1">spec_tuple = ()</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">spec_tuple = spec_.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)  </span><span class="s0"># type: ignore</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">must be either None, a string, or PolyShape.&quot;</span><span class="s1">)</span>

  <span class="s0"># Process ...</span>
  <span class="s1">spec_tuple = tuple(map(</span><span class="s3">lambda </span><span class="s1">s: ... </span><span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">and </span><span class="s1">s.strip() == </span><span class="s4">&quot;...&quot; </span><span class="s3">else </span><span class="s1">s</span><span class="s3">,</span>
                         <span class="s1">spec_tuple))</span>
  <span class="s1">ds_ellipses = tuple(ds </span><span class="s3">for </span><span class="s1">ds </span><span class="s3">in </span><span class="s1">spec_tuple </span><span class="s3">if </span><span class="s1">ds == ...)</span>
  <span class="s3">if </span><span class="s1">ds_ellipses:</span>
    <span class="s3">if </span><span class="s1">len(ds_ellipses) &gt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">spec_tuple[-</span><span class="s5">1</span><span class="s1">] != ...:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">can contain Ellipsis only at the end.&quot;</span><span class="s1">)</span>
    <span class="s1">spec_tuple = spec_tuple[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">len(arg_shape) &gt;= len(spec_tuple):</span>
      <span class="s1">spec_tuple = spec_tuple + (</span><span class="s4">&quot;_&quot;</span><span class="s3">,</span><span class="s1">) * (len(arg_shape) - len(spec_tuple))</span>

  <span class="s3">if </span><span class="s1">len(arg_shape) != len(spec_tuple):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">of rank </span><span class="s3">{</span><span class="s1">len(spec_tuple)</span><span class="s3">} </span><span class="s4">must match the rank </span><span class="s3">{</span><span class="s1">len(arg_shape)</span><span class="s3">} </span><span class="s4">of argument shape </span><span class="s3">{</span><span class="s1">arg_shape</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

  <span class="s0"># The actual parsing.</span>
  <span class="s0"># We actually parse not just dimension variables, but polynomials.</span>
  <span class="s0"># This is not a supported feature of the API, but is needed when parsing the</span>
  <span class="s0"># polymorphic_shapes of a gradient function, when the primal function has polynomial</span>
  <span class="s0"># output shapes.</span>
  <span class="s3">def </span><span class="s1">_parse_dim(dim_spec: Union[str</span><span class="s3">, </span><span class="s1">int]) -&gt; DimSize:</span>
    <span class="s3">if </span><span class="s1">isinstance(dim_spec</span><span class="s3">, </span><span class="s1">int):</span>
      <span class="s3">return </span><span class="s1">dim_spec  </span><span class="s0">#</span>
    <span class="s1">dim_spec = dim_spec.strip()</span>
    <span class="s3">if not </span><span class="s1">dim_spec:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">has invalid syntax (empty dimension '</span><span class="s3">{</span><span class="s1">dim_spec</span><span class="s3">}</span><span class="s4">')&quot;</span><span class="s1">)</span>
    <span class="s0"># Terms are separated by &quot;+&quot;</span>
    <span class="s1">terms = dim_spec.split(</span><span class="s4">&quot;+&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">terms:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">has invalid syntax (empty dimension '</span><span class="s3">{</span><span class="s1">dim_spec</span><span class="s3">}</span><span class="s4">')&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_parse_term(term_spec: str) -&gt; DimSize:</span>
      <span class="s1">term_spec = term_spec.strip()</span>
      <span class="s0"># Factors are separated by &quot;*&quot;</span>
      <span class="s1">factors = term_spec.split(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
      <span class="s3">if not </span><span class="s1">factors:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">has invalid syntax (unexpected term '</span><span class="s3">{</span><span class="s1">term_spec</span><span class="s3">}</span><span class="s4">')&quot;</span><span class="s1">)</span>
      <span class="s3">def </span><span class="s1">_parse_factor(factor_spec: str) -&gt; DimSize:</span>
        <span class="s1">factor_spec = factor_spec.strip()</span>
        <span class="s3">if </span><span class="s1">re.match(</span><span class="s4">r&quot;^-?\d+$&quot;</span><span class="s3">, </span><span class="s1">factor_spec):</span>
          <span class="s3">return </span><span class="s1">int(factor_spec)</span>
        <span class="s1">m = re.match(</span><span class="s4">r&quot;^([a-zA-Z]\w*)(\^(\d+))?$&quot;</span><span class="s3">, </span><span class="s1">factor_spec)</span>
        <span class="s3">if not </span><span class="s1">m:</span>
          <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">has invalid syntax (unexpected term '</span><span class="s3">{</span><span class="s1">factor_spec</span><span class="s3">}</span><span class="s4">')&quot;</span><span class="s1">)</span>
        <span class="s1">var = _DimExpr.from_var(m.group(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">3</span><span class="s1">) </span><span class="s3">is None</span><span class="s1">:</span>
          <span class="s3">return </span><span class="s1">var</span>
        <span class="s3">return </span><span class="s1">var ** int(m.group(</span><span class="s5">3</span><span class="s1">))</span>

      <span class="s3">return </span><span class="s1">functools.reduce(op.mul</span><span class="s3">, </span><span class="s1">map(_parse_factor</span><span class="s3">, </span><span class="s1">factors))</span>
    <span class="s3">return </span><span class="s1">functools.reduce(op.add</span><span class="s3">, </span><span class="s1">map(_parse_term</span><span class="s3">, </span><span class="s1">terms))</span>

  <span class="s3">def </span><span class="s1">_process_dim(i: int</span><span class="s3">, </span><span class="s1">dim_spec: Union[str</span><span class="s3">, </span><span class="s1">int]):</span>
    <span class="s3">if </span><span class="s1">isinstance(dim_spec</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s1">dim_spec = dim_spec.strip()</span>
    <span class="s1">dim_size = arg_shape[i]</span>
    <span class="s3">if </span><span class="s1">dim_size </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">def </span><span class="s1">need_dim_var_msg():</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">in axis </span><span class="s3">{</span><span class="s1">i</span><span class="s3">} </span><span class="s4">must contain a dimension variable &quot;</span>
               <span class="s4">f&quot;for unknown dimension in argument shape </span><span class="s3">{</span><span class="s1">arg_shape</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">spec </span><span class="s3">is None</span><span class="s1">:</span>
          <span class="s1">msg += </span><span class="s4">&quot;. Perhaps you forgot to add the polymorphic_shapes= parameter to jax2tf.convert?&quot;</span>
        <span class="s3">return </span><span class="s1">msg</span>

      <span class="s3">if </span><span class="s1">dim_spec == </span><span class="s4">&quot;_&quot;</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(need_dim_var_msg())</span>
      <span class="s1">dim_poly = _parse_dim(dim_spec)</span>
      <span class="s3">if not </span><span class="s1">is_poly_dim(dim_poly):</span>
        <span class="s3">raise </span><span class="s1">ValueError(need_dim_var_msg())</span>
      <span class="s3">return </span><span class="s1">dim_poly</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s0"># dim_size is known</span>
      <span class="s1">dim_size = int(dim_size)</span>
      <span class="s3">if </span><span class="s1">dim_spec == </span><span class="s4">&quot;_&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">dim_size</span>
      <span class="s1">dim_poly = _parse_dim(dim_spec)</span>
      <span class="s3">if not </span><span class="s1">is_poly_dim(dim_poly):</span>
        <span class="s3">if </span><span class="s1">dim_poly != dim_size:</span>
          <span class="s1">msg = (</span><span class="s4">f&quot;polymorphic shape </span><span class="s3">{</span><span class="s1">repr(spec)</span><span class="s3">} </span><span class="s4">in axis </span><span class="s3">{</span><span class="s1">i</span><span class="s3">} </span><span class="s4">must match the &quot;</span>
                 <span class="s4">f&quot;known dimension size </span><span class="s3">{</span><span class="s1">dim_size</span><span class="s3">} </span><span class="s4">for argument shape </span><span class="s3">{</span><span class="s1">arg_shape</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
          <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
        <span class="s3">return </span><span class="s1">dim_size</span>
      <span class="s3">return </span><span class="s1">dim_poly</span>

  <span class="s1">dims = tuple(_process_dim(i</span><span class="s3">, </span><span class="s1">ds) </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ds </span><span class="s3">in </span><span class="s1">enumerate(spec_tuple))</span>
  <span class="s3">return </span><span class="s1">dims</span>


<span class="s3">def </span><span class="s1">_evaluate_add(v1</span><span class="s3">, </span><span class="s1">v2):</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">op.index(v1) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">v2</span>
  <span class="s3">except</span><span class="s1">:</span>
    <span class="s3">pass</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">op.index(v2) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">v1</span>
  <span class="s3">except</span><span class="s1">:</span>
    <span class="s3">pass</span>
  <span class="s3">return </span><span class="s1">v1 + v2</span>

<span class="s3">def </span><span class="s1">_evaluate_multiply(v1</span><span class="s3">, </span><span class="s1">v2):</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">op.index(v1) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">v2</span>
  <span class="s3">except</span><span class="s1">:</span>
    <span class="s3">pass</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">op.index(v2) == </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">v1</span>
  <span class="s3">except</span><span class="s1">:</span>
    <span class="s3">pass</span>
  <span class="s3">return </span><span class="s1">v1 * v2</span>

<span class="s3">def </span><span class="s1">_is_known_constant(v) -&gt; Optional[int]:</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">int(v)</span>
  <span class="s3">except </span><span class="s1">Exception:</span>
    <span class="s0"># TODO(necula): added this so that in jax2tf, in Eager mode, we can tell</span>
    <span class="s0"># that a tensor is a constant. We should move this dependency into some</span>
    <span class="s0"># jax2tf-specific area.</span>
    <span class="s3">if </span><span class="s1">hasattr(v</span><span class="s3">, </span><span class="s4">&quot;val&quot;</span><span class="s1">):</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">vint = int(v.val)</span>
        <span class="s3">if </span><span class="s1">isinstance(vint</span><span class="s3">, </span><span class="s1">int):  </span><span class="s0"># In TF, int(tf.Tensor) is tf.Tensor!</span>
          <span class="s3">return </span><span class="s1">vint</span>
      <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">pass</span>
    <span class="s3">return None</span>

<span class="s0"># dimension_size(operand, dimension=i) get the operand.shape[i] as a</span>
<span class="s0"># value of type shape_poly.dim_as_value_dtype().</span>
<span class="s1">dimension_size_p = core.Primitive(</span><span class="s4">&quot;dimension_size&quot;</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">_dimension_size_abstract(aval: core.AbstractValue</span><span class="s3">, </span><span class="s1">**_) -&gt; core.AbstractValue:</span>
  <span class="s3">return </span><span class="s1">dim_as_value_abstract(aval)</span>

<span class="s1">dimension_size_p.def_abstract_eval(_dimension_size_abstract)</span>

<span class="s3">def </span><span class="s1">_dimension_size_impl(arg</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">dimension):</span>
  <span class="s3">return </span><span class="s1">dim_constant(arg.shape[dimension])</span>
<span class="s1">dimension_size_p.def_impl(_dimension_size_impl)</span>

<span class="s1">_JaxValue = Any</span>

<span class="s1">@dataclasses.dataclass</span>
<span class="s3">class </span><span class="s1">DimEquation:</span>
  <span class="s0"># Represents poly == _expr</span>
  <span class="s1">poly: _DimExpr</span>
  <span class="s1">dim_expr: _JaxValue  </span><span class="s0"># Of type dim_as_value_dtype()</span>


<span class="s3">def </span><span class="s1">get_shape_evaluator(dim_vars: Sequence[str]</span><span class="s3">, </span><span class="s1">shape: Sequence[DimSize]) -&gt;\</span>
  <span class="s1">Callable[...</span><span class="s3">, </span><span class="s1">TfVal]:</span>
  <span class="s2">&quot;&quot;&quot;Prepares a shape evaluator. 
 
  Returns a JAX function that given the values for the dimension variables 
  returns the values for the dimensions of `shape`. 
  &quot;&quot;&quot;</span>
  <span class="s3">def </span><span class="s1">eval_shape(*dim_values: Any) -&gt; Sequence[Any]:</span>
    <span class="s1">shape_env_jax = dict(zip(dim_vars</span><span class="s3">, </span><span class="s1">dim_values))</span>

    <span class="s3">def </span><span class="s1">eval_dim(d: DimSize):</span>
      <span class="s3">return </span><span class="s1">d.evaluate(shape_env_jax)  </span><span class="s0"># type: ignore[union-attr]</span>

    <span class="s3">return </span><span class="s1">tuple(eval_dim(d) </span><span class="s3">if </span><span class="s1">type(d) </span><span class="s3">is </span><span class="s1">_DimExpr </span><span class="s3">else </span><span class="s1">np.array(d</span><span class="s3">, </span><span class="s1">dtype=dim_as_value_dtype())  </span><span class="s0"># type: ignore</span>
                 <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">shape)</span>
  <span class="s3">return </span><span class="s1">eval_shape</span>

<span class="s3">def </span><span class="s1">arg_aval(</span>
    <span class="s1">arg_shape: Sequence[Optional[int]]</span><span class="s3">,</span>
    <span class="s1">arg_jax_dtype: DType</span><span class="s3">,</span>
    <span class="s1">polymorphic_shape: Optional[Union[str</span><span class="s3">, </span><span class="s1">PolyShape]]) -&gt; core.ShapedArray:</span>
  <span class="s2">&quot;&quot;&quot;Computes abstract values. 
 
  Args: 
    arg_shape: the shape for the argument, possibly having None dimensions. 
    arg_dtype: the inferred JAX dtype for the arg. 
    polymorphic_shape: the polymorphic specifications for the argument. 
  Returns: the JAX abstract value for the argument. 
  &quot;&quot;&quot;</span>
  <span class="s1">aval_shape = _parse_spec(polymorphic_shape</span><span class="s3">, </span><span class="s1">arg_shape)</span>
  <span class="s3">return </span><span class="s1">core.ShapedArray(aval_shape</span><span class="s3">, </span><span class="s1">arg_jax_dtype)</span>

<span class="s3">def </span><span class="s1">prepare_dim_var_env(args_avals: Sequence[core.AbstractValue]) -&gt; \</span>
    <span class="s1">Tuple[Sequence[str]</span><span class="s3">,</span>
          <span class="s1">Callable[...</span><span class="s3">, </span><span class="s1">Sequence[TfVal]]]:</span>
  <span class="s2">&quot;&quot;&quot;Get the dimension variables and the function to compute them. 
 
  Returns a tuple of dimension variables that appear in `args_avals` along 
  with a function that given the actual arguments of the top-level function 
  returns a tuple of dimension variable values, in the same order as the 
  dimension variables returned in the first component. 
  The dimension variables are TfVal with type dim_as_value_dtype(). 
  &quot;&quot;&quot;</span>
  <span class="s1">dim_vars: Set[str] = set()</span>
  <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args_avals:</span>
    <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">a.shape:</span>
      <span class="s3">if </span><span class="s1">is_poly_dim(d):</span>
        <span class="s1">dim_vars = dim_vars.union(d.get_vars())</span>

  <span class="s3">def </span><span class="s1">get_dim_var_values(*args: Any) -&gt; Sequence[Any]:</span>
    <span class="s1">dim_equations: List[DimEquation] = []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args:</span>
      <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate(a.shape):</span>
        <span class="s3">if </span><span class="s1">is_poly_dim(d):</span>
          <span class="s1">dim_equations.append(DimEquation(</span>
              <span class="s1">poly=d</span><span class="s3">, </span><span class="s1">dim_expr=dimension_size_p.bind(a</span><span class="s3">, </span><span class="s1">dimension=i)))</span>

    <span class="s1">dim_env = _solve_dim_equations(dim_equations)</span>
    <span class="s3">assert </span><span class="s1">all(dim_env[dv].dtype == dim_as_value_dtype() </span><span class="s3">for </span><span class="s1">dv </span><span class="s3">in </span><span class="s1">dim_vars)</span>
    <span class="s3">return </span><span class="s1">tuple(dim_env[dv] </span><span class="s3">for </span><span class="s1">dv </span><span class="s3">in </span><span class="s1">dim_vars)</span>
  <span class="s3">return </span><span class="s1">tuple(dim_vars)</span><span class="s3">, </span><span class="s1">get_dim_var_values</span>

<span class="s3">def </span><span class="s1">_solve_dim_equations(eqns: List[DimEquation]) -&gt; ShapeEnv:</span>
  <span class="s0"># Returns a shape environment if it can solve all dimension variables.</span>
  <span class="s0"># Raises an exception if it cannot.</span>
  <span class="s1">shapeenv: ShapeEnv = {}</span>

  <span class="s3">def </span><span class="s1">_shapeenv_to_str() -&gt; str:</span>
    <span class="s3">if </span><span class="s1">shapeenv:</span>
      <span class="s3">return </span><span class="s1">(</span><span class="s4">&quot; Partial solution: &quot; </span><span class="s1">+</span>
              <span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">var</span><span class="s3">} </span><span class="s4">= </span><span class="s3">{</span><span class="s1">val</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">var</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">shapeenv.items()]) + </span><span class="s4">&quot;.&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">process_one_eqn(eqn: DimEquation) -&gt; bool:</span>
    <span class="s0"># Try to rewrite the equation as &quot;var * factor_var = dim_expr&quot; (a linear</span>
    <span class="s0"># uni-variate equation. Return False if this rewrite fails.</span>
    <span class="s0"># Otherwise, add the variable to shapeenv and return True.</span>

    <span class="s0"># The invariant is: var * factor_var + rest_eqn_poly = dim_expr</span>
    <span class="s1">var</span><span class="s3">, </span><span class="s1">factor_var = </span><span class="s3">None, None</span>
    <span class="s1">dim_expr = eqn.dim_expr</span>

    <span class="s3">for </span><span class="s1">mon</span><span class="s3">, </span><span class="s1">factor </span><span class="s3">in </span><span class="s1">eqn.poly.monomials():</span>
      <span class="s0"># Perhaps we can already evaluate this monomial (all vars solved)</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">mon_value = mon.evaluate(shapeenv)</span>
        <span class="s1">dim_expr = dim_expr - _evaluate_multiply(mon_value</span><span class="s3">, </span><span class="s1">dim_constant(factor))</span>
        <span class="s3">continue</span>
      <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s0"># There are some indeterminate variables. We handle only the case of</span>
        <span class="s0"># linear remaining indeterminates.</span>
        <span class="s1">v = mon.to_var()</span>
        <span class="s3">if </span><span class="s1">v </span><span class="s3">is not None and </span><span class="s1">var </span><span class="s3">is None</span><span class="s1">:</span>
          <span class="s1">var = v</span>
          <span class="s1">factor_var = factor</span>
          <span class="s3">continue</span>
      <span class="s3">return False</span>

    <span class="s3">if </span><span class="s1">var </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">factor_var == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">var_value</span><span class="s3">, </span><span class="s1">var_remainder = dim_expr</span><span class="s3">, </span><span class="s1">dim_constant(</span><span class="s5">0</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">var_value = lax.div(dim_expr</span><span class="s3">, </span><span class="s1">dim_constant(factor_var))  </span><span class="s0"># type: ignore</span>
        <span class="s1">var_remainder = lax.rem(dim_expr</span><span class="s3">, </span><span class="s1">dim_constant(factor_var))  </span><span class="s0"># type: ignore</span>

      <span class="s0"># Check that the division is even. Works only in eager mode.</span>
      <span class="s1">var_remainder_int = _is_known_constant(var_remainder)</span>
      <span class="s3">if </span><span class="s1">var_remainder_int </span><span class="s3">is not None and </span><span class="s1">var_remainder_int != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s0"># TODO(necula): check even in graph mode, by embedding the checks in</span>
        <span class="s0"># the graph.</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;Dimension variable </span><span class="s3">{</span><span class="s1">var</span><span class="s3">} </span><span class="s4">must have integer value &gt;= 1. &quot;  </span><span class="s0"># type: ignore</span>
               <span class="s4">f&quot;Found value </span><span class="s3">{</span><span class="s1">int(_is_known_constant(dim_expr)) / factor_var</span><span class="s3">} </span><span class="s4">when solving &quot;  </span><span class="s0"># type: ignore</span>
               <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">eqn.poly</span><span class="s3">} </span><span class="s4">== </span><span class="s3">{</span><span class="s1">eqn.dim_expr</span><span class="s3">}</span><span class="s4">.</span><span class="s3">{</span><span class="s1">_shapeenv_to_str()</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
      <span class="s1">var_value_int = _is_known_constant(var_value)</span>
      <span class="s3">if </span><span class="s1">var_value_int </span><span class="s3">is not None and </span><span class="s1">var_value_int &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">msg = (</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">var_value_int</span><span class="s3">} </span><span class="s4">Dimension variable </span><span class="s3">{</span><span class="s1">var</span><span class="s3">} </span><span class="s4">must have integer value &gt;= 1. &quot;</span>
               <span class="s4">f&quot;Found value </span><span class="s3">{</span><span class="s1">int(var_value_int)</span><span class="s3">} </span><span class="s4">when solving &quot;</span>
               <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">eqn.poly</span><span class="s3">} </span><span class="s4">== </span><span class="s3">{</span><span class="s1">eqn.dim_expr</span><span class="s3">}</span><span class="s4">.</span><span class="s3">{</span><span class="s1">_shapeenv_to_str()</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg)</span>

      <span class="s1">shapeenv[var] = var_value</span>
      <span class="s3">return True</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># All variables are resolved for this equation</span>
      <span class="s1">dim_expr_int = _is_known_constant(dim_expr)</span>
      <span class="s3">if </span><span class="s1">dim_expr_int </span><span class="s3">is not None and </span><span class="s1">dim_expr_int != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">err_msg = (</span>
            <span class="s4">&quot;Found inconsistency when solving &quot;</span>
            <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">eqn.poly</span><span class="s3">} </span><span class="s4">== </span><span class="s3">{</span><span class="s1">eqn.dim_expr</span><span class="s3">}</span><span class="s4">.</span><span class="s3">{</span><span class="s1">_shapeenv_to_str()</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">raise </span><span class="s1">ValueError(err_msg)</span>
      <span class="s3">return True</span>

  <span class="s3">while True</span><span class="s1">:</span>
    <span class="s1">nr_eqns = len(eqns)</span>
    <span class="s1">eqns = [eqn </span><span class="s3">for </span><span class="s1">eqn </span><span class="s3">in </span><span class="s1">eqns </span><span class="s3">if not </span><span class="s1">process_one_eqn(eqn)]</span>
    <span class="s3">if not </span><span class="s1">eqns:</span>
      <span class="s3">return </span><span class="s1">shapeenv  </span><span class="s0"># SUCCESS</span>
    <span class="s3">elif </span><span class="s1">len(eqns) &gt;= nr_eqns:</span>
      <span class="s3">break</span>

  <span class="s0"># We have some equations that we cannot solve further</span>
  <span class="s1">unsolved_vars: Set[str] = set()</span>
  <span class="s1">unsolved_polys: List[_DimExpr] = []</span>
  <span class="s3">for </span><span class="s1">eqn </span><span class="s3">in </span><span class="s1">eqns:</span>
    <span class="s1">unsolved_vars = unsolved_vars.union(eqn.poly.get_vars())</span>
    <span class="s1">unsolved_polys.append(eqn.poly)</span>
  <span class="s1">unsolved_vars = unsolved_vars.difference(shapeenv.keys())</span>
  <span class="s1">eqns_str = </span><span class="s4">&quot;</span><span class="s3">\n  </span><span class="s4">&quot;</span><span class="s1">.join([str(eqn.poly) </span><span class="s3">for </span><span class="s1">eqn </span><span class="s3">in </span><span class="s1">eqns])</span>
  <span class="s1">err_msg = (</span>
      <span class="s4">f&quot;Cannot solve for values of dimension variables </span><span class="s3">{</span><span class="s1">unsolved_vars</span><span class="s3">} </span><span class="s4">from &quot;</span>
      <span class="s4">f&quot;the remaining dimension polynomials</span><span class="s3">\n  {</span><span class="s1">eqns_str</span><span class="s3">}</span><span class="s4">.</span><span class="s3">{</span><span class="s1">_shapeenv_to_str()</span><span class="s3">} </span><span class="s4">&quot;</span>
      <span class="s4">&quot;Dimension variables can be solved only from linear polynomials.</span><span class="s3">\n</span><span class="s4">&quot;</span>
      <span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span>
      <span class="s4">&quot;Please see https://github.com/google/jax/blob/main/jax/experimental/jax2tf/README.md#dimension-variables-must-be-solvable-from-the-input-shapes for more details.&quot;</span><span class="s1">)</span>
  <span class="s3">raise </span><span class="s1">ValueError(err_msg)</span>
</pre>
</body>
</html>