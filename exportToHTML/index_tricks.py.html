<html>
<head>
<title>index_tricks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index_tricks.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2022 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Iterable</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">jax</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src.numpy.util </span><span class="s2">import </span><span class="s1">promote_dtypes</span>
<span class="s2">from </span><span class="s1">jax._src.numpy.lax_numpy </span><span class="s2">import </span><span class="s1">(</span>
  <span class="s1">arange</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">concatenate</span><span class="s2">, </span><span class="s1">expand_dims</span><span class="s2">, </span><span class="s1">linspace</span><span class="s2">, </span><span class="s1">meshgrid</span><span class="s2">, </span><span class="s1">stack</span><span class="s2">, </span><span class="s1">transpose</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">jax._src.typing </span><span class="s2">import </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">ArrayLike</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>


<span class="s1">__all__ = [</span><span class="s3">&quot;c_&quot;</span><span class="s2">, </span><span class="s3">&quot;index_exp&quot;</span><span class="s2">, </span><span class="s3">&quot;mgrid&quot;</span><span class="s2">, </span><span class="s3">&quot;ogrid&quot;</span><span class="s2">, </span><span class="s3">&quot;r_&quot;</span><span class="s2">, </span><span class="s3">&quot;s_&quot;</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_make_1d_grid_from_slice(s: slice</span><span class="s2">, </span><span class="s1">op_name: str) -&gt; Array:</span>
  <span class="s1">start = core.concrete_or_error(</span><span class="s2">None, </span><span class="s1">s.start</span><span class="s2">,</span>
                                 <span class="s3">f&quot;slice start of jnp.</span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s4">0</span>
  <span class="s1">stop = core.concrete_or_error(</span><span class="s2">None, </span><span class="s1">s.stop</span><span class="s2">,</span>
                                <span class="s3">f&quot;slice stop of jnp.</span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
  <span class="s1">step = core.concrete_or_error(</span><span class="s2">None, </span><span class="s1">s.step</span><span class="s2">,</span>
                                <span class="s3">f&quot;slice step of jnp.</span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s4">1</span>
  <span class="s2">if </span><span class="s1">np.iscomplex(step):</span>
    <span class="s1">newobj = linspace(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">int(abs(step)))</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">newobj = arange(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step)</span>

  <span class="s2">return </span><span class="s1">newobj</span>


<span class="s2">class </span><span class="s1">_Mgrid:</span>
  <span class="s5">&quot;&quot;&quot;Return dense multi-dimensional &quot;meshgrid&quot;. 
 
  LAX-backend implementation of :obj:`numpy.mgrid`. This is a convenience wrapper for 
  functionality provided by :func:`jax.numpy.meshgrid` with ``sparse=False``. 
 
  See Also: 
    jnp.ogrid: open/sparse version of jnp.mgrid 
 
  Examples: 
    Pass ``[start:stop:step]`` to generate values similar to :func:`jax.numpy.arange`: 
 
    &gt;&gt;&gt; jnp.mgrid[0:4:1] 
    Array([0, 1, 2, 3], dtype=int32) 
 
    Passing an imaginary step generates values similar to :func:`jax.numpy.linspace`: 
 
    &gt;&gt;&gt; jnp.mgrid[0:1:4j] 
    Array([0.        , 0.33333334, 0.6666667 , 1.        ], dtype=float32) 
 
    Multiple slices can be used to create broadcasted grids of indices: 
 
    &gt;&gt;&gt; jnp.mgrid[:2, :3] 
    Array([[[0, 0, 0], 
            [1, 1, 1]], 
           [[0, 1, 2], 
            [0, 1, 2]]], dtype=int32) 
  &quot;&quot;&quot;</span>

  <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key: Union[slice</span><span class="s2">, </span><span class="s1">Tuple[slice</span><span class="s2">, </span><span class="s1">...]]) -&gt; Array:</span>
    <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">slice):</span>
      <span class="s2">return </span><span class="s1">_make_1d_grid_from_slice(key</span><span class="s2">, </span><span class="s1">op_name=</span><span class="s3">&quot;mgrid&quot;</span><span class="s1">)</span>
    <span class="s1">output: Iterable[Array] = (_make_1d_grid_from_slice(k</span><span class="s2">, </span><span class="s1">op_name=</span><span class="s3">&quot;mgrid&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">key)</span>
    <span class="s2">with </span><span class="s1">jax.numpy_dtype_promotion(</span><span class="s3">'standard'</span><span class="s1">):</span>
      <span class="s1">output = promote_dtypes(*output)</span>
    <span class="s1">output_arr = meshgrid(*output</span><span class="s2">, </span><span class="s1">indexing=</span><span class="s3">'ij'</span><span class="s2">, </span><span class="s1">sparse=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(output_arr) == </span><span class="s4">0</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">arange(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">stack(output_arr</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">mgrid = _Mgrid()</span>


<span class="s2">class </span><span class="s1">_Ogrid:</span>
  <span class="s5">&quot;&quot;&quot;Return open multi-dimensional &quot;meshgrid&quot;. 
 
  LAX-backend implementation of :obj:`numpy.ogrid`. This is a convenience wrapper for 
  functionality provided by :func:`jax.numpy.meshgrid` with ``sparse=True``. 
 
  See Also: 
    jnp.mgrid: dense version of jnp.ogrid 
 
  Examples: 
    Pass ``[start:stop:step]`` to generate values similar to :func:`jax.numpy.arange`: 
 
    &gt;&gt;&gt; jnp.ogrid[0:4:1] 
    Array([0, 1, 2, 3], dtype=int32) 
 
    Passing an imaginary step generates values similar to :func:`jax.numpy.linspace`: 
 
    &gt;&gt;&gt; jnp.ogrid[0:1:4j] 
    Array([0.        , 0.33333334, 0.6666667 , 1.        ], dtype=float32) 
 
    Multiple slices can be used to create sparse grids of indices: 
 
    &gt;&gt;&gt; jnp.ogrid[:2, :3] 
    [Array([[0], 
            [1]], dtype=int32), 
     Array([[0, 1, 2]], dtype=int32)] 
  &quot;&quot;&quot;</span>

  <span class="s2">def </span><span class="s1">__getitem__(</span>
      <span class="s1">self</span><span class="s2">, </span><span class="s1">key: Union[slice</span><span class="s2">, </span><span class="s1">Tuple[slice</span><span class="s2">, </span><span class="s1">...]]</span>
  <span class="s1">) -&gt; Union[Array</span><span class="s2">, </span><span class="s1">List[Array]]:</span>
    <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">slice):</span>
      <span class="s2">return </span><span class="s1">_make_1d_grid_from_slice(key</span><span class="s2">, </span><span class="s1">op_name=</span><span class="s3">&quot;ogrid&quot;</span><span class="s1">)</span>
    <span class="s1">output: Iterable[Array] = (_make_1d_grid_from_slice(k</span><span class="s2">, </span><span class="s1">op_name=</span><span class="s3">&quot;ogrid&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">key)</span>
    <span class="s2">with </span><span class="s1">jax.numpy_dtype_promotion(</span><span class="s3">'standard'</span><span class="s1">):</span>
      <span class="s1">output = promote_dtypes(*output)</span>
    <span class="s2">return </span><span class="s1">meshgrid(*output</span><span class="s2">, </span><span class="s1">indexing=</span><span class="s3">'ij'</span><span class="s2">, </span><span class="s1">sparse=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">ogrid = _Ogrid()</span>


<span class="s1">_IndexType = Union[ArrayLike</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">slice]</span>


<span class="s2">class </span><span class="s1">_AxisConcat(abc.ABC):</span>
  <span class="s5">&quot;&quot;&quot;Concatenates slices, scalars and array-like objects along a given axis.&quot;&quot;&quot;</span>
  <span class="s1">axis: int</span>
  <span class="s1">ndmin: int</span>
  <span class="s1">trans1d: int</span>
  <span class="s1">op_name: str</span>

  <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key: Union[_IndexType</span><span class="s2">, </span><span class="s1">Tuple[_IndexType</span><span class="s2">, </span><span class="s1">...]]) -&gt; Array:</span>
    <span class="s1">key_tup: Tuple[_IndexType</span><span class="s2">, </span><span class="s1">...] = key </span><span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">else </span><span class="s1">(key</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s1">params = [self.axis</span><span class="s2">, </span><span class="s1">self.ndmin</span><span class="s2">, </span><span class="s1">self.trans1d</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">directive = key_tup[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">isinstance(directive</span><span class="s2">, </span><span class="s1">str):</span>
      <span class="s1">key_tup = key_tup[</span><span class="s4">1</span><span class="s1">:]</span>
      <span class="s0"># check two special cases: matrix directives</span>
      <span class="s2">if </span><span class="s1">directive == </span><span class="s3">&quot;r&quot;</span><span class="s1">:</span>
        <span class="s1">params[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">0</span>
      <span class="s2">elif </span><span class="s1">directive == </span><span class="s3">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s1">params[-</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">vec: List[Any] = directive.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
        <span class="s1">k = len(vec)</span>
        <span class="s2">if </span><span class="s1">k &lt; </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s1">vec += params[k:]</span>
        <span class="s2">else</span><span class="s1">:</span>
          <span class="s0"># ignore everything after the first three comma-separated ints</span>
          <span class="s1">vec = vec[:</span><span class="s4">3</span><span class="s1">] + [params[-</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s2">try</span><span class="s1">:</span>
          <span class="s1">params = list(map(int</span><span class="s2">, </span><span class="s1">vec))</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
          <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">f&quot;could not understand directive </span><span class="s2">{</span><span class="s1">directive</span><span class="s2">!r}</span><span class="s3">&quot;</span>
          <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s1">axis</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">, </span><span class="s1">trans1d</span><span class="s2">, </span><span class="s1">matrix = params</span>

    <span class="s1">output = []</span>
    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">key_tup:</span>
      <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">slice):</span>
        <span class="s1">newobj = _make_1d_grid_from_slice(item</span><span class="s2">, </span><span class="s1">op_name=self.op_name)</span>
        <span class="s1">item_ndim = </span><span class="s4">0</span>
      <span class="s2">elif </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;string directive must be placed at the beginning&quot;</span><span class="s1">)</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">newobj = array(item</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">item_ndim = newobj.ndim</span>

      <span class="s1">newobj = array(newobj</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">ndmin=ndmin)</span>

      <span class="s2">if </span><span class="s1">trans1d != -</span><span class="s4">1 </span><span class="s2">and </span><span class="s1">ndmin - item_ndim &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">shape_obj = tuple(range(ndmin))</span>
        <span class="s0"># Calculate number of left shifts, with overflow protection by mod</span>
        <span class="s1">num_lshifts = ndmin - abs(ndmin + trans1d + </span><span class="s4">1</span><span class="s1">) % ndmin</span>
        <span class="s1">shape_obj = tuple(shape_obj[num_lshifts:] + shape_obj[:num_lshifts])</span>

        <span class="s1">newobj = transpose(newobj</span><span class="s2">, </span><span class="s1">shape_obj)</span>

      <span class="s1">output.append(newobj)</span>

    <span class="s1">res = concatenate(tuple(output)</span><span class="s2">, </span><span class="s1">axis=axis)</span>

    <span class="s2">if </span><span class="s1">matrix != -</span><span class="s4">1 </span><span class="s2">and </span><span class="s1">res.ndim == </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s0"># insert 2nd dim at axis 0 or 1</span>
      <span class="s1">res = expand_dims(res</span><span class="s2">, </span><span class="s1">matrix)</span>

    <span class="s2">return </span><span class="s1">res</span>

  <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
    <span class="s2">return </span><span class="s4">0</span>


<span class="s2">class </span><span class="s1">RClass(_AxisConcat):</span>
  <span class="s5">&quot;&quot;&quot;Concatenate slices, scalars and array-like objects along the first axis. 
 
  LAX-backend implementation of :obj:`numpy.r_`. 
 
  See Also: 
    ``jnp.c_``: Concatenates slices, scalars and array-like objects along the last axis. 
 
  Examples: 
    Passing slices in the form ``[start:stop:step]`` generates ``jnp.arange`` objects: 
 
    &gt;&gt;&gt; jnp.r_[-1:5:1, 0, 0, jnp.array([1,2,3])] 
    Array([-1,  0,  1,  2,  3,  4,  0,  0,  1,  2,  3], dtype=int32) 
 
    An imaginary value for ``step`` will create a ``jnp.linspace`` object instead, 
    which includes the right endpoint: 
 
    &gt;&gt;&gt; jnp.r_[-1:1:6j, 0, jnp.array([1,2,3])] 
    Array([-1.        , -0.6       , -0.20000002,  0.20000005, 
           0.6       ,  1.        ,  0.        ,  1.        , 
           2.        ,  3.        ], dtype=float32) 
 
    Use a string directive of the form ``&quot;axis,dims,trans1d&quot;`` as the first argument to 
    specify concatenation axis, minimum number of dimensions, and the position of the 
    upgraded array's original dimensions in the resulting array's shape tuple: 
 
    &gt;&gt;&gt; jnp.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, 2D output 
    Array([[1, 2, 3], 
           [4, 5, 6]], dtype=int32) 
 
    &gt;&gt;&gt; jnp.r_['0,2,0', [1,2,3], [4,5,6]] # push last input axis to the front 
    Array([[1], 
           [2], 
           [3], 
           [4], 
           [5], 
           [6]], dtype=int32) 
 
    Negative values for ``trans1d`` offset the last axis towards the start 
    of the shape tuple: 
 
    &gt;&gt;&gt; jnp.r_['0,2,-2', [1,2,3], [4,5,6]] 
    Array([[1], 
           [2], 
           [3], 
           [4], 
           [5], 
           [6]], dtype=int32) 
 
    Use the special directives ``&quot;r&quot;`` or ``&quot;c&quot;`` as the first argument on flat inputs 
    to create an array with an extra row or column axis, respectively: 
 
    &gt;&gt;&gt; jnp.r_['r',[1,2,3], [4,5,6]] 
    Array([[1, 2, 3, 4, 5, 6]], dtype=int32) 
 
    &gt;&gt;&gt; jnp.r_['c',[1,2,3], [4,5,6]] 
    Array([[1], 
           [2], 
           [3], 
           [4], 
           [5], 
           [6]], dtype=int32) 
 
    For higher-dimensional inputs (``dim &gt;= 2``), both directives ``&quot;r&quot;`` and ``&quot;c&quot;`` 
    give the same result. 
  &quot;&quot;&quot;</span>
  <span class="s1">axis = </span><span class="s4">0</span>
  <span class="s1">ndmin = </span><span class="s4">1</span>
  <span class="s1">trans1d = -</span><span class="s4">1</span>
  <span class="s1">op_name = </span><span class="s3">&quot;r_&quot;</span>


<span class="s1">r_ = RClass()</span>


<span class="s2">class </span><span class="s1">CClass(_AxisConcat):</span>
  <span class="s5">&quot;&quot;&quot;Concatenate slices, scalars and array-like objects along the last axis. 
 
  LAX-backend implementation of :obj:`numpy.c_`. 
 
  See Also: 
    ``jnp.r_``: Concatenates slices, scalars and array-like objects along the first axis. 
 
  Examples: 
 
    &gt;&gt;&gt; a = jnp.arange(6).reshape((2,3)) 
    &gt;&gt;&gt; jnp.c_[a,a] 
    Array([[0, 1, 2, 0, 1, 2], 
           [3, 4, 5, 3, 4, 5]], dtype=int32) 
 
    Use a string directive of the form ``&quot;axis:dims:trans1d&quot;`` as the first argument to specify 
    concatenation axis, minimum number of dimensions, and the position of the upgraded array's 
    original dimensions in the resulting array's shape tuple: 
 
    &gt;&gt;&gt; jnp.c_['0,2', [1,2,3], [4,5,6]] 
    Array([[1], 
           [2], 
           [3], 
           [4], 
           [5], 
           [6]], dtype=int32) 
 
    &gt;&gt;&gt; jnp.c_['0,2,-1', [1,2,3], [4,5,6]] 
    Array([[1, 2, 3], 
           [4, 5, 6]], dtype=int32) 
 
    Use the special directives ``&quot;r&quot;`` or ``&quot;c&quot;`` as the first argument on flat inputs 
    to create an array with inputs stacked along the last axis: 
 
    &gt;&gt;&gt; jnp.c_['r',[1,2,3], [4,5,6]] 
    Array([[1, 4], 
           [2, 5], 
           [3, 6]], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s1">axis = -</span><span class="s4">1</span>
  <span class="s1">ndmin = </span><span class="s4">2</span>
  <span class="s1">trans1d = </span><span class="s4">0</span>
  <span class="s1">op_name = </span><span class="s3">&quot;c_&quot;</span>


<span class="s1">c_ = CClass()</span>

<span class="s1">s_ = np.s_</span>

<span class="s1">index_exp = np.index_exp</span>
</pre>
</body>
</html>