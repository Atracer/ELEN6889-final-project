<html>
<head>
<title>scatter.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scatter.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2019 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s0"># Helpers for indexed updates.</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">lax</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">dtypes</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">jax._src.lax </span><span class="s2">import </span><span class="s1">lax </span><span class="s2">as </span><span class="s1">lax_internal</span>
<span class="s2">from </span><span class="s1">jax._src.numpy </span><span class="s2">import </span><span class="s1">lax_numpy </span><span class="s2">as </span><span class="s1">jnp</span>
<span class="s2">from </span><span class="s1">jax._src.numpy </span><span class="s2">import </span><span class="s1">reductions</span>
<span class="s2">from </span><span class="s1">jax._src.numpy.util </span><span class="s2">import </span><span class="s1">check_arraylike</span><span class="s2">, </span><span class="s1">promote_dtypes</span>


<span class="s1">Array = Any</span>
<span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">10</span><span class="s1">):</span>
    <span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">EllipsisType</span>
    <span class="s1">SingleIndex = Union[</span><span class="s2">None, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">Sequence[int]</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">EllipsisType]</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">SingleIndex = Union[</span><span class="s2">None, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">Sequence[int]</span><span class="s2">, </span><span class="s1">Array]</span>
<span class="s1">Index = Union[SingleIndex</span><span class="s2">, </span><span class="s1">Tuple[SingleIndex</span><span class="s2">, </span><span class="s1">...]]</span>
<span class="s1">Scalar = Union[complex</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">np.number]</span>
<span class="s1">Numeric = Union[Array</span><span class="s2">, </span><span class="s1">Scalar]</span>


<span class="s2">def </span><span class="s1">_scatter_update(x</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">scatter_op</span><span class="s2">, </span><span class="s1">indices_are_sorted</span><span class="s2">,</span>
                    <span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">mode=</span><span class="s2">None, </span><span class="s1">normalize_indices=</span><span class="s2">True</span><span class="s1">):</span>
  <span class="s4">&quot;&quot;&quot;Helper for indexed updates. 
 
  Computes the value of x that would result from computing:: 
    x[idx] op= y 
  except in a pure functional way, with no in-place updating. 
 
  Args: 
    x: ndarray to be updated. 
    idx: None, an integer, a slice, an ellipsis, an ndarray with integer dtype, 
      or a tuple of those indicating the locations of `x` into which to scatter- 
      update the values in `y`. 
    y: values to be scattered. 
    scatter_op: callable, one of lax.scatter, lax.scatter_add, lax.scatter_min, 
      or lax_scatter_max. 
    indices_are_sorted: whether `idx` is known to be sorted 
    unique_indices: whether `idx` is known to be free of duplicates 
 
  Returns: 
    An ndarray representing an updated `x` after performing the scatter-update. 
  &quot;&quot;&quot;</span>

  <span class="s1">x = jnp.asarray(x)</span>
  <span class="s1">y = jnp.asarray(y)</span>
  <span class="s0"># XLA gathers and scatters are very similar in structure; the scatter logic</span>
  <span class="s0"># is more or less a transpose of the gather equivalent.</span>
  <span class="s1">treedef</span><span class="s2">, </span><span class="s1">static_idx</span><span class="s2">, </span><span class="s1">dynamic_idx = jnp._split_index_for_jit(idx</span><span class="s2">, </span><span class="s1">x.shape)</span>
  <span class="s2">return </span><span class="s1">_scatter_impl(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">scatter_op</span><span class="s2">, </span><span class="s1">treedef</span><span class="s2">, </span><span class="s1">static_idx</span><span class="s2">, </span><span class="s1">dynamic_idx</span><span class="s2">,</span>
                       <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">,</span>
                       <span class="s1">normalize_indices)</span>


<span class="s0"># TODO(phawkins): re-enable jit after fixing excessive recompilation for</span>
<span class="s0"># slice indexes (e.g., slice(0, 5, None), slice(10, 15, None), etc.).</span>
<span class="s0"># @partial(jit, static_argnums=(2, 3, 4))</span>
<span class="s2">def </span><span class="s1">_scatter_impl(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">scatter_op</span><span class="s2">, </span><span class="s1">treedef</span><span class="s2">, </span><span class="s1">static_idx</span><span class="s2">, </span><span class="s1">dynamic_idx</span><span class="s2">,</span>
                  <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">,</span>
                  <span class="s1">normalize_indices):</span>
  <span class="s1">dtype = lax.dtype(x)</span>
  <span class="s1">weak_type = dtypes.is_weakly_typed(x)</span>

  <span class="s2">if </span><span class="s1">dtype != lax.dtype(y) </span><span class="s2">and </span><span class="s1">dtype != dtypes.result_type(x</span><span class="s2">, </span><span class="s1">y):</span>
    <span class="s0"># TODO(jakevdp): change this to an error after the deprecation period.</span>
    <span class="s1">warnings.warn(</span><span class="s5">&quot;scatter inputs have incompatible types: cannot safely cast &quot;</span>
                  <span class="s5">f&quot;value from dtype=</span><span class="s2">{</span><span class="s1">lax.dtype(y)</span><span class="s2">} </span><span class="s5">to dtype=</span><span class="s2">{</span><span class="s1">lax.dtype(x)</span><span class="s2">}</span><span class="s5">. &quot;</span>
                  <span class="s5">&quot;In future JAX releases this will result in an error.&quot;</span><span class="s2">,</span>
                  <span class="s1">FutureWarning)</span>

  <span class="s1">idx = jnp._merge_static_and_dynamic_indices(treedef</span><span class="s2">, </span><span class="s1">static_idx</span><span class="s2">, </span><span class="s1">dynamic_idx)</span>
  <span class="s1">indexer = jnp._index_to_gather(jnp.shape(x)</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">,</span>
                                 <span class="s1">normalize_indices=normalize_indices)</span>

  <span class="s0"># Avoid calling scatter if the slice shape is empty, both as a fast path and</span>
  <span class="s0"># to handle cases like zeros(0)[array([], int32)].</span>
  <span class="s2">if </span><span class="s1">core.is_empty_shape(indexer.slice_shape):</span>
    <span class="s2">return </span><span class="s1">x</span>

  <span class="s1">x</span><span class="s2">, </span><span class="s1">y = promote_dtypes(x</span><span class="s2">, </span><span class="s1">y)</span>

  <span class="s0"># Broadcast `y` to the slice output shape.</span>
  <span class="s1">y = jnp.broadcast_to(y</span><span class="s2">, </span><span class="s1">tuple(indexer.slice_shape))</span>
  <span class="s0"># Collapse any `None`/`jnp.newaxis` dimensions.</span>
  <span class="s1">y = jnp.squeeze(y</span><span class="s2">, </span><span class="s1">axis=indexer.newaxis_dims)</span>
  <span class="s2">if </span><span class="s1">indexer.reversed_y_dims:</span>
    <span class="s1">y = lax.rev(y</span><span class="s2">, </span><span class="s1">indexer.reversed_y_dims)</span>

  <span class="s0"># Transpose the gather dimensions into scatter dimensions (cf.</span>
  <span class="s0"># lax._gather_transpose_rule)</span>
  <span class="s1">dnums = lax.ScatterDimensionNumbers(</span>
    <span class="s1">update_window_dims=indexer.dnums.offset_dims</span><span class="s2">,</span>
    <span class="s1">inserted_window_dims=indexer.dnums.collapsed_slice_dims</span><span class="s2">,</span>
    <span class="s1">scatter_dims_to_operand_dims=indexer.dnums.start_index_map</span>
  <span class="s1">)</span>
  <span class="s1">out = scatter_op(</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">indexer.gather_indices</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">dnums</span><span class="s2">,</span>
    <span class="s1">indices_are_sorted=indexer.indices_are_sorted </span><span class="s2">or </span><span class="s1">indices_are_sorted</span><span class="s2">,</span>
    <span class="s1">unique_indices=indexer.unique_indices </span><span class="s2">or </span><span class="s1">unique_indices</span><span class="s2">,</span>
    <span class="s1">mode=mode)</span>
  <span class="s2">return </span><span class="s1">lax_internal._convert_element_type(out</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">weak_type)</span>



<span class="s2">def </span><span class="s1">_get_identity(op</span><span class="s2">, </span><span class="s1">dtype):</span>
  <span class="s4">&quot;&quot;&quot;Get an appropriate identity for a given operation in a given dtype.&quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">op </span><span class="s2">is </span><span class="s1">lax.scatter_add:</span>
    <span class="s2">return </span><span class="s3">0</span>
  <span class="s2">elif </span><span class="s1">op </span><span class="s2">is </span><span class="s1">lax.scatter_mul:</span>
    <span class="s2">return </span><span class="s3">1</span>
  <span class="s2">elif </span><span class="s1">op </span><span class="s2">is </span><span class="s1">lax.scatter_min:</span>
    <span class="s2">if </span><span class="s1">dtype == dtypes.bool_:</span>
      <span class="s2">return True</span>
    <span class="s2">elif </span><span class="s1">jnp.issubdtype(dtype</span><span class="s2">, </span><span class="s1">jnp.integer):</span>
      <span class="s2">return </span><span class="s1">jnp.iinfo(dtype).max</span>
    <span class="s2">return </span><span class="s1">float(</span><span class="s5">'inf'</span><span class="s1">)</span>
  <span class="s2">elif </span><span class="s1">op </span><span class="s2">is </span><span class="s1">lax.scatter_max:</span>
    <span class="s2">if </span><span class="s1">dtype == dtypes.bool_:</span>
      <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">jnp.issubdtype(dtype</span><span class="s2">, </span><span class="s1">jnp.integer):</span>
      <span class="s2">return </span><span class="s1">jnp.iinfo(dtype).min</span>
    <span class="s2">return </span><span class="s1">-float(</span><span class="s5">'inf'</span><span class="s1">)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Unrecognized op: </span><span class="s2">{</span><span class="s1">op</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_segment_update(name: str</span><span class="s2">,</span>
                    <span class="s1">data: Array</span><span class="s2">,</span>
                    <span class="s1">segment_ids: Array</span><span class="s2">,</span>
                    <span class="s1">scatter_op: Callable</span><span class="s2">,</span>
                    <span class="s1">num_segments: Optional[int] = </span><span class="s2">None,</span>
                    <span class="s1">indices_are_sorted: bool = </span><span class="s2">False,</span>
                    <span class="s1">unique_indices: bool = </span><span class="s2">False,</span>
                    <span class="s1">bucket_size: Optional[int] = </span><span class="s2">None,</span>
                    <span class="s1">reducer: Optional[Callable] = </span><span class="s2">None,</span>
                    <span class="s1">mode: Optional[lax.GatherScatterMode] = </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s1">check_arraylike(name</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">segment_ids)</span>
  <span class="s1">mode = lax.GatherScatterMode.FILL_OR_DROP </span><span class="s2">if </span><span class="s1">mode </span><span class="s2">is None else </span><span class="s1">mode</span>
  <span class="s1">data = jnp.asarray(data)</span>
  <span class="s1">segment_ids = jnp.asarray(segment_ids)</span>
  <span class="s1">dtype = data.dtype</span>
  <span class="s2">if </span><span class="s1">num_segments </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">num_segments = np.max(segment_ids) + </span><span class="s3">1</span>
  <span class="s1">num_segments = core.concrete_or_error(int</span><span class="s2">, </span><span class="s1">num_segments</span><span class="s2">, </span><span class="s5">&quot;segment_sum() `num_segments` argument.&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">num_segments </span><span class="s2">is not None and </span><span class="s1">num_segments &lt; </span><span class="s3">0</span><span class="s1">:</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;num_segments must be non-negative.&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">bucket_size </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">out = jnp.full((num_segments</span><span class="s2">,</span><span class="s1">) + data.shape[</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">,</span>
                   <span class="s1">_get_identity(scatter_op</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">_scatter_update(</span>
      <span class="s1">out</span><span class="s2">, </span><span class="s1">segment_ids</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">scatter_op</span><span class="s2">, </span><span class="s1">indices_are_sorted</span><span class="s2">,</span>
      <span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">normalize_indices=</span><span class="s2">False, </span><span class="s1">mode=mode)</span>

  <span class="s0"># Bucketize indices and perform segment_update on each bucket to improve</span>
  <span class="s0"># numerical stability for operations like product and sum.</span>
  <span class="s2">assert </span><span class="s1">reducer </span><span class="s2">is not None</span>
  <span class="s1">num_buckets = util.ceil_of_ratio(segment_ids.size</span><span class="s2">, </span><span class="s1">bucket_size)</span>
  <span class="s1">out = jnp.full((num_buckets</span><span class="s2">, </span><span class="s1">num_segments) + data.shape[</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">,</span>
                 <span class="s1">_get_identity(scatter_op</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
  <span class="s1">out = _scatter_update(</span>
    <span class="s1">out</span><span class="s2">, </span><span class="s1">np.index_exp[jnp.arange(segment_ids.shape[</span><span class="s3">0</span><span class="s1">]) // bucket_size</span><span class="s2">,</span>
                      <span class="s1">segment_ids[</span><span class="s2">None, </span><span class="s1">:]]</span><span class="s2">,</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">scatter_op</span><span class="s2">, </span><span class="s1">indices_are_sorted</span><span class="s2">,</span>
    <span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">normalize_indices=</span><span class="s2">False, </span><span class="s1">mode=mode)</span>
  <span class="s2">return </span><span class="s1">reducer(out</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">).astype(dtype)</span>


<span class="s2">def </span><span class="s1">segment_sum(data: Array</span><span class="s2">,</span>
                <span class="s1">segment_ids: Array</span><span class="s2">,</span>
                <span class="s1">num_segments: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">indices_are_sorted: bool = </span><span class="s2">False,</span>
                <span class="s1">unique_indices: bool = </span><span class="s2">False,</span>
                <span class="s1">bucket_size: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">mode: Optional[lax.GatherScatterMode] = </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s4">&quot;&quot;&quot;Computes the sum within segments of an array. 
 
  Similar to TensorFlow's `segment_sum 
  &lt;https://www.tensorflow.org/api_docs/python/tf/math/segment_sum&gt;`_ 
 
  Args: 
    data: an array with the values to be summed. 
    segment_ids: an array with integer dtype that indicates the segments of 
      `data` (along its leading axis) to be summed. Values can be repeated and 
      need not be sorted. 
    num_segments: optional, an int with nonnegative value indicating the number 
      of segments. The default is set to be the minimum number of segments that 
      would support all indices in ``segment_ids``, calculated as 
      ``max(segment_ids) + 1``. 
      Since `num_segments` determines the size of the output, a static value 
      must be provided to use ``segment_sum`` in a JIT-compiled function. 
    indices_are_sorted: whether ``segment_ids`` is known to be sorted. 
    unique_indices: whether `segment_ids` is known to be free of duplicates. 
    bucket_size: size of bucket to group indices into. ``segment_sum`` is 
      performed on each bucket separately to improve numerical stability of 
      addition. Default ``None`` means no bucketing. 
    mode: a :class:`jax.lax.GatherScatterMode` value describing how 
      out-of-bounds indices should be handled. By default, values outside of the 
      range [0, num_segments) are dropped and do not contribute to the sum. 
 
  Returns: 
    An array with shape :code:`(num_segments,) + data.shape[1:]` representing the 
    segment sums. 
 
  Examples: 
    Simple 1D segment sum: 
 
    &gt;&gt;&gt; data = jnp.arange(5) 
    &gt;&gt;&gt; segment_ids = jnp.array([0, 0, 1, 1, 2]) 
    &gt;&gt;&gt; segment_sum(data, segment_ids) 
    Array([1, 5, 4], dtype=int32) 
 
    Using JIT requires static `num_segments`: 
 
    &gt;&gt;&gt; from jax import jit 
    &gt;&gt;&gt; jit(segment_sum, static_argnums=2)(data, segment_ids, 3) 
    Array([1, 5, 4], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_segment_update(</span>
      <span class="s5">&quot;segment_sum&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">segment_ids</span><span class="s2">, </span><span class="s1">lax.scatter_add</span><span class="s2">, </span><span class="s1">num_segments</span><span class="s2">,</span>
      <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">bucket_size</span><span class="s2">, </span><span class="s1">reductions.sum</span><span class="s2">, </span><span class="s1">mode=mode)</span>


<span class="s2">def </span><span class="s1">segment_prod(data: Array</span><span class="s2">,</span>
                 <span class="s1">segment_ids: Array</span><span class="s2">,</span>
                 <span class="s1">num_segments: Optional[int] = </span><span class="s2">None,</span>
                 <span class="s1">indices_are_sorted: bool = </span><span class="s2">False,</span>
                 <span class="s1">unique_indices: bool = </span><span class="s2">False,</span>
                 <span class="s1">bucket_size: Optional[int] = </span><span class="s2">None,</span>
                 <span class="s1">mode: Optional[lax.GatherScatterMode] = </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s4">&quot;&quot;&quot;Computes the product within segments of an array. 
 
  Similar to TensorFlow's `segment_prod 
  &lt;https://www.tensorflow.org/api_docs/python/tf/math/segment_prod&gt;`_ 
 
  Args: 
    data: an array with the values to be reduced. 
    segment_ids: an array with integer dtype that indicates the segments of 
      `data` (along its leading axis) to be reduced. Values can be repeated and 
      need not be sorted. Values outside of the range [0, num_segments) are 
      dropped and do not contribute to the result. 
    num_segments: optional, an int with nonnegative value indicating the number 
      of segments. The default is set to be the minimum number of segments that 
      would support all indices in ``segment_ids``, calculated as 
      ``max(segment_ids) + 1``. 
      Since `num_segments` determines the size of the output, a static value 
      must be provided to use ``segment_prod`` in a JIT-compiled function. 
    indices_are_sorted: whether ``segment_ids`` is known to be sorted. 
    unique_indices: whether `segment_ids` is known to be free of duplicates. 
    bucket_size: size of bucket to group indices into. ``segment_prod`` is 
      performed on each bucket separately to improve numerical stability of 
      addition. Default ``None`` means no bucketing. 
    mode: a :class:`jax.lax.GatherScatterMode` value describing how 
      out-of-bounds indices should be handled. By default, values outside of the 
      range [0, num_segments) are dropped and do not contribute to the sum. 
 
  Returns: 
    An array with shape :code:`(num_segments,) + data.shape[1:]` representing the 
    segment products. 
 
  Examples: 
    Simple 1D segment product: 
 
    &gt;&gt;&gt; data = jnp.arange(6) 
    &gt;&gt;&gt; segment_ids = jnp.array([0, 0, 1, 1, 2, 2]) 
    &gt;&gt;&gt; segment_prod(data, segment_ids) 
    Array([ 0,  6, 20], dtype=int32) 
 
    Using JIT requires static `num_segments`: 
 
    &gt;&gt;&gt; from jax import jit 
    &gt;&gt;&gt; jit(segment_prod, static_argnums=2)(data, segment_ids, 3) 
    Array([ 0,  6, 20], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_segment_update(</span>
      <span class="s5">&quot;segment_prod&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">segment_ids</span><span class="s2">, </span><span class="s1">lax.scatter_mul</span><span class="s2">, </span><span class="s1">num_segments</span><span class="s2">,</span>
      <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">bucket_size</span><span class="s2">, </span><span class="s1">reductions.prod</span><span class="s2">, </span><span class="s1">mode=mode)</span>


<span class="s2">def </span><span class="s1">segment_max(data: Array</span><span class="s2">,</span>
                <span class="s1">segment_ids: Array</span><span class="s2">,</span>
                <span class="s1">num_segments: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">indices_are_sorted: bool = </span><span class="s2">False,</span>
                <span class="s1">unique_indices: bool = </span><span class="s2">False,</span>
                <span class="s1">bucket_size: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">mode: Optional[lax.GatherScatterMode] = </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s4">&quot;&quot;&quot;Computes the maximum within segments of an array. 
 
  Similar to TensorFlow's `segment_max 
  &lt;https://www.tensorflow.org/api_docs/python/tf/math/segment_max&gt;`_ 
 
  Args: 
    data: an array with the values to be reduced. 
    segment_ids: an array with integer dtype that indicates the segments of 
      `data` (along its leading axis) to be reduced. Values can be repeated and 
      need not be sorted. Values outside of the range [0, num_segments) are 
      dropped and do not contribute to the result. 
    num_segments: optional, an int with nonnegative value indicating the number 
      of segments. The default is set to be the minimum number of segments that 
      would support all indices in ``segment_ids``, calculated as 
      ``max(segment_ids) + 1``. 
      Since `num_segments` determines the size of the output, a static value 
      must be provided to use ``segment_max`` in a JIT-compiled function. 
    indices_are_sorted: whether ``segment_ids`` is known to be sorted. 
    unique_indices: whether `segment_ids` is known to be free of duplicates. 
    bucket_size: size of bucket to group indices into. ``segment_max`` is 
      performed on each bucket separately. Default ``None`` means no bucketing. 
    mode: a :class:`jax.lax.GatherScatterMode` value describing how 
      out-of-bounds indices should be handled. By default, values outside of the 
      range [0, num_segments) are dropped and do not contribute to the sum. 
 
  Returns: 
    An array with shape :code:`(num_segments,) + data.shape[1:]` representing the 
    segment maximums. 
 
  Examples: 
    Simple 1D segment max: 
 
    &gt;&gt;&gt; data = jnp.arange(6) 
    &gt;&gt;&gt; segment_ids = jnp.array([0, 0, 1, 1, 2, 2]) 
    &gt;&gt;&gt; segment_max(data, segment_ids) 
    Array([1, 3, 5], dtype=int32) 
 
    Using JIT requires static `num_segments`: 
 
    &gt;&gt;&gt; from jax import jit 
    &gt;&gt;&gt; jit(segment_max, static_argnums=2)(data, segment_ids, 3) 
    Array([1, 3, 5], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_segment_update(</span>
      <span class="s5">&quot;segment_max&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">segment_ids</span><span class="s2">, </span><span class="s1">lax.scatter_max</span><span class="s2">, </span><span class="s1">num_segments</span><span class="s2">,</span>
      <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">bucket_size</span><span class="s2">, </span><span class="s1">reductions.max</span><span class="s2">, </span><span class="s1">mode=mode)</span>


<span class="s2">def </span><span class="s1">segment_min(data: Array</span><span class="s2">,</span>
                <span class="s1">segment_ids: Array</span><span class="s2">,</span>
                <span class="s1">num_segments: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">indices_are_sorted: bool = </span><span class="s2">False,</span>
                <span class="s1">unique_indices: bool = </span><span class="s2">False,</span>
                <span class="s1">bucket_size: Optional[int] = </span><span class="s2">None,</span>
                <span class="s1">mode: Optional[lax.GatherScatterMode] = </span><span class="s2">None</span><span class="s1">) -&gt; Array:</span>
  <span class="s4">&quot;&quot;&quot;Computes the minimum within segments of an array. 
 
  Similar to TensorFlow's `segment_min 
  &lt;https://www.tensorflow.org/api_docs/python/tf/math/segment_min&gt;`_ 
 
  Args: 
    data: an array with the values to be reduced. 
    segment_ids: an array with integer dtype that indicates the segments of 
      `data` (along its leading axis) to be reduced. Values can be repeated and 
      need not be sorted. Values outside of the range [0, num_segments) are 
      dropped and do not contribute to the result. 
    num_segments: optional, an int with nonnegative value indicating the number 
      of segments. The default is set to be the minimum number of segments that 
      would support all indices in ``segment_ids``, calculated as 
      ``max(segment_ids) + 1``. 
      Since `num_segments` determines the size of the output, a static value 
      must be provided to use ``segment_min`` in a JIT-compiled function. 
    indices_are_sorted: whether ``segment_ids`` is known to be sorted. 
    unique_indices: whether `segment_ids` is known to be free of duplicates. 
    bucket_size: size of bucket to group indices into. ``segment_min`` is 
      performed on each bucket separately. Default ``None`` means no bucketing. 
    mode: a :class:`jax.lax.GatherScatterMode` value describing how 
      out-of-bounds indices should be handled. By default, values outside of the 
      range [0, num_segments) are dropped and do not contribute to the sum. 
 
  Returns: 
    An array with shape :code:`(num_segments,) + data.shape[1:]` representing the 
    segment minimums. 
 
  Examples: 
    Simple 1D segment min: 
 
    &gt;&gt;&gt; data = jnp.arange(6) 
    &gt;&gt;&gt; segment_ids = jnp.array([0, 0, 1, 1, 2, 2]) 
    &gt;&gt;&gt; segment_min(data, segment_ids) 
    Array([0, 2, 4], dtype=int32) 
 
    Using JIT requires static `num_segments`: 
 
    &gt;&gt;&gt; from jax import jit 
    &gt;&gt;&gt; jit(segment_min, static_argnums=2)(data, segment_ids, 3) 
    Array([0, 2, 4], dtype=int32) 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_segment_update(</span>
      <span class="s5">&quot;segment_min&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">segment_ids</span><span class="s2">, </span><span class="s1">lax.scatter_min</span><span class="s2">, </span><span class="s1">num_segments</span><span class="s2">,</span>
      <span class="s1">indices_are_sorted</span><span class="s2">, </span><span class="s1">unique_indices</span><span class="s2">, </span><span class="s1">bucket_size</span><span class="s2">, </span><span class="s1">reductions.min</span><span class="s2">, </span><span class="s1">mode=mode)</span>
</pre>
</body>
</html>