<html>
<head>
<title>scale.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scale.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">jit</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">lax</span>
<span class="s2">from </span><span class="s1">jax </span><span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">jnp</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">canonicalize_axis</span>
<span class="s2">from </span><span class="s1">jax._src.numpy.util </span><span class="s2">import </span><span class="s1">promote_dtypes_inexact</span>


<span class="s2">def </span><span class="s1">_fill_lanczos_kernel(radius</span><span class="s2">, </span><span class="s1">x):</span>
  <span class="s1">y = radius * jnp.sin(np.pi * x) * jnp.sin(np.pi * x / radius)</span>
  <span class="s0">#  out = y / (np.pi ** 2 * x ** 2) where x &gt;1e-3, 1 otherwise</span>
  <span class="s1">out = jnp.where(x &gt; </span><span class="s3">1e-3</span><span class="s2">, </span><span class="s1">jnp.divide(y</span><span class="s2">, </span><span class="s1">jnp.where(x != </span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.pi**</span><span class="s3">2 </span><span class="s1">* x**</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
  <span class="s2">return </span><span class="s1">jnp.where(x &gt; radius</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s1">out)</span>


<span class="s2">def </span><span class="s1">_fill_keys_cubic_kernel(x):</span>
  <span class="s0"># http://ieeexplore.ieee.org/document/1163711/</span>
  <span class="s0"># R. G. Keys. Cubic convolution interpolation for digital image processing.</span>
  <span class="s0"># IEEE Transactions on Acoustics, Speech, and Signal Processing,</span>
  <span class="s0"># 29(6):1153â€“1160, 1981.</span>
  <span class="s1">out = ((</span><span class="s3">1.5 </span><span class="s1">* x - </span><span class="s3">2.5</span><span class="s1">) * x) * x + </span><span class="s3">1.</span>
  <span class="s1">out = jnp.where(x &gt;= </span><span class="s3">1.</span><span class="s2">, </span><span class="s1">((-</span><span class="s3">0.5 </span><span class="s1">* x + </span><span class="s3">2.5</span><span class="s1">) * x - </span><span class="s3">4.</span><span class="s1">) * x + </span><span class="s3">2.</span><span class="s2">, </span><span class="s1">out)</span>
  <span class="s2">return </span><span class="s1">jnp.where(x &gt;= </span><span class="s3">2.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s1">out)</span>


<span class="s2">def </span><span class="s1">_fill_triangle_kernel(x):</span>
  <span class="s2">return </span><span class="s1">jnp.maximum(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1 </span><span class="s1">- jnp.abs(x))</span>


<span class="s2">def </span><span class="s1">compute_weight_mat(input_size: core.DimSize</span><span class="s2">,</span>
                       <span class="s1">output_size: core.DimSize</span><span class="s2">,</span>
                       <span class="s1">scale</span><span class="s2">,</span>
                       <span class="s1">translation</span><span class="s2">,</span>
                       <span class="s1">kernel: Callable</span><span class="s2">,</span>
                       <span class="s1">antialias: bool):</span>
  <span class="s1">dtype = jnp.result_type(scale</span><span class="s2">, </span><span class="s1">translation)</span>
  <span class="s1">inv_scale = </span><span class="s3">1. </span><span class="s1">/ scale</span>
  <span class="s0"># When downsampling the kernel should be scaled since we want to low pass</span>
  <span class="s0"># filter and interpolate, but when upsampling it should not be since we only</span>
  <span class="s0"># want to interpolate.</span>
  <span class="s1">kernel_scale = jnp.maximum(inv_scale</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">) </span><span class="s2">if </span><span class="s1">antialias </span><span class="s2">else </span><span class="s3">1.</span>
  <span class="s1">sample_f = ((jnp.arange(output_size</span><span class="s2">, </span><span class="s1">dtype=dtype) + </span><span class="s3">0.5</span><span class="s1">) * inv_scale -</span>
              <span class="s1">translation * inv_scale - </span><span class="s3">0.5</span><span class="s1">)</span>
  <span class="s1">x = (</span>
      <span class="s1">jnp.abs(sample_f[jnp.newaxis</span><span class="s2">, </span><span class="s1">:] -</span>
              <span class="s1">jnp.arange(input_size</span><span class="s2">, </span><span class="s1">dtype=dtype)[:</span><span class="s2">, </span><span class="s1">jnp.newaxis]) /</span>
      <span class="s1">kernel_scale)</span>
  <span class="s1">weights = kernel(x)</span>

  <span class="s1">total_weight_sum = jnp.sum(weights</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>
  <span class="s1">weights = jnp.where(</span>
      <span class="s1">jnp.abs(total_weight_sum) &gt; </span><span class="s3">1000. </span><span class="s1">* float(np.finfo(np.float32).eps)</span><span class="s2">,</span>
      <span class="s1">jnp.divide(weights</span><span class="s2">, </span><span class="s1">jnp.where(total_weight_sum != </span><span class="s3">0</span><span class="s2">,  </span><span class="s1">total_weight_sum</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span><span class="s2">,</span>
      <span class="s3">0</span><span class="s1">)</span>
  <span class="s0"># Zero out weights where the sample location is completely outside the input</span>
  <span class="s0"># range.</span>
  <span class="s0"># Note sample_f has already had the 0.5 removed, hence the weird range below.</span>
  <span class="s1">input_size_minus_0_5 = core.dimension_as_value(input_size) - </span><span class="s3">0.5</span>
  <span class="s2">return </span><span class="s1">jnp.where(</span>
      <span class="s1">jnp.logical_and(sample_f &gt;= -</span><span class="s3">0.5</span><span class="s2">,</span>
                      <span class="s1">sample_f &lt;= input_size_minus_0_5)[jnp.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_scale_and_translate(x</span><span class="s2">, </span><span class="s1">output_shape: core.Shape</span><span class="s2">,</span>
                         <span class="s1">spatial_dims: Sequence[int]</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">translation</span><span class="s2">,</span>
                         <span class="s1">kernel</span><span class="s2">, </span><span class="s1">antialias: bool</span><span class="s2">, </span><span class="s1">precision):</span>
  <span class="s1">input_shape = x.shape</span>
  <span class="s2">assert </span><span class="s1">len(input_shape) == len(output_shape)</span>
  <span class="s2">assert </span><span class="s1">len(spatial_dims) == len(scale)</span>
  <span class="s2">assert </span><span class="s1">len(spatial_dims) == len(translation)</span>
  <span class="s2">if </span><span class="s1">len(spatial_dims) == </span><span class="s3">0</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">x</span>
  <span class="s1">contractions = []</span>
  <span class="s1">in_indices = list(range(len(output_shape)))</span>
  <span class="s1">out_indices = list(range(len(output_shape)))</span>
  <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">enumerate(spatial_dims):</span>
    <span class="s1">d = canonicalize_axis(d</span><span class="s2">, </span><span class="s1">x.ndim)</span>
    <span class="s1">m = input_shape[d]</span>
    <span class="s1">n = output_shape[d]</span>
    <span class="s1">w = compute_weight_mat(m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">scale[i]</span><span class="s2">, </span><span class="s1">translation[i]</span><span class="s2">,</span>
                           <span class="s1">kernel</span><span class="s2">, </span><span class="s1">antialias).astype(x.dtype)</span>
    <span class="s1">contractions.append(w)</span>
    <span class="s1">contractions.append([d</span><span class="s2">, </span><span class="s1">len(output_shape) + i])</span>
    <span class="s1">out_indices[d] = len(output_shape) + i</span>
  <span class="s1">contractions.append(out_indices)</span>
  <span class="s2">return </span><span class="s1">jnp.einsum(x</span><span class="s2">, </span><span class="s1">in_indices</span><span class="s2">, </span><span class="s1">*contractions</span><span class="s2">, </span><span class="s1">precision=precision)</span>


<span class="s2">class </span><span class="s1">ResizeMethod(enum.Enum):</span>
  <span class="s4">&quot;&quot;&quot;Image resize method. 
 
  Possible values are: 
 
  NEAREST: 
    Nearest-neighbor interpolation. 
 
  LINEAR: 
    `Linear interpolation`_. 
 
  LANCZOS3: 
    `Lanczos resampling`_, using a kernel of radius 3. 
 
  LANCZOS5: 
    `Lanczos resampling`_, using a kernel of radius 5. 
 
  CUBIC: 
    `Cubic interpolation`_, using the Keys cubic kernel. 
 
  .. _Linear interpolation: https://en.wikipedia.org/wiki/Bilinear_interpolation 
  .. _Cubic interpolation: https://en.wikipedia.org/wiki/Bicubic_interpolation 
  .. _Lanczos resampling: https://en.wikipedia.org/wiki/Lanczos_resampling 
  &quot;&quot;&quot;</span>

  <span class="s1">NEAREST = </span><span class="s3">0</span>
  <span class="s1">LINEAR = </span><span class="s3">1</span>
  <span class="s1">LANCZOS3 = </span><span class="s3">2</span>
  <span class="s1">LANCZOS5 = </span><span class="s3">3</span>
  <span class="s1">CUBIC = </span><span class="s3">4</span>

  <span class="s0"># Caution: The current resize implementation assumes that the resize kernels</span>
  <span class="s0"># are interpolating, i.e. for the identity warp the output equals the input.</span>
  <span class="s0"># This is not true for, e.g. a Gaussian kernel, so if such kernels are added</span>
  <span class="s0"># the implementation will need to be changed.</span>

  <span class="s1">@staticmethod</span>
  <span class="s2">def </span><span class="s1">from_string(s: str):</span>
    <span class="s2">if </span><span class="s1">s == </span><span class="s5">'nearest'</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">ResizeMethod.NEAREST</span>
    <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'linear'</span><span class="s2">, </span><span class="s5">'bilinear'</span><span class="s2">, </span><span class="s5">'trilinear'</span><span class="s2">, </span><span class="s5">'triangle'</span><span class="s1">]:</span>
      <span class="s2">return </span><span class="s1">ResizeMethod.LINEAR</span>
    <span class="s2">elif </span><span class="s1">s == </span><span class="s5">'lanczos3'</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">ResizeMethod.LANCZOS3</span>
    <span class="s2">elif </span><span class="s1">s == </span><span class="s5">'lanczos5'</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">ResizeMethod.LANCZOS5</span>
    <span class="s2">elif </span><span class="s1">s </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'cubic'</span><span class="s2">, </span><span class="s5">'bicubic'</span><span class="s2">, </span><span class="s5">'tricubic'</span><span class="s1">]:</span>
      <span class="s2">return </span><span class="s1">ResizeMethod.CUBIC</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'Unknown resize method &quot;</span><span class="s2">{</span><span class="s1">s</span><span class="s2">}</span><span class="s5">&quot;'</span><span class="s1">)</span>

<span class="s1">_kernels = {</span>
    <span class="s1">ResizeMethod.LINEAR: _fill_triangle_kernel</span><span class="s2">,</span>
    <span class="s1">ResizeMethod.LANCZOS3: </span><span class="s2">lambda </span><span class="s1">x: _fill_lanczos_kernel(</span><span class="s3">3.</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
    <span class="s1">ResizeMethod.LANCZOS5: </span><span class="s2">lambda </span><span class="s1">x: _fill_lanczos_kernel(</span><span class="s3">5.</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">,</span>
    <span class="s1">ResizeMethod.CUBIC: _fill_keys_cubic_kernel</span>
<span class="s1">}</span>


<span class="s0"># scale and translation here are scalar elements of an np.array, what is the</span>
<span class="s0"># correct type annotation?</span>
<span class="s2">def </span><span class="s1">scale_and_translate(image</span><span class="s2">, </span><span class="s1">shape: core.Shape</span><span class="s2">,</span>
                        <span class="s1">spatial_dims: Sequence[int]</span><span class="s2">,</span>
                        <span class="s1">scale</span><span class="s2">, </span><span class="s1">translation</span><span class="s2">,</span>
                        <span class="s1">method: Union[str</span><span class="s2">, </span><span class="s1">ResizeMethod]</span><span class="s2">,</span>
                        <span class="s1">antialias: bool = </span><span class="s2">True,</span>
                        <span class="s1">precision=lax.Precision.HIGHEST):</span>
  <span class="s4">&quot;&quot;&quot;Apply a scale and translation to an image. 
 
  Generates a new image of shape 'shape' by resampling from the input image 
  using the sampling method corresponding to method. For 2D images, this 
  operation transforms a location in the input images, (x, y), to a location 
  in the output image according to:: 
 
    (x * scale[1] + translation[1], y * scale[0] + translation[0]) 
 
  (Note the *inverse* warp is used to generate the sample locations.) 
  Assumes half-centered pixels, i.e the pixel at integer location ``row, col`` 
  has coordinates ``y, x = row + 0.5, col + 0.5``, and similarly for other input 
  image dimensions. 
 
  If an output location(pixel) maps to an input sample location that is outside 
  the input boundaries then the value for the output location will be set to 
  zero. 
 
  The ``method`` argument expects one of the following resize methods: 
 
  ``ResizeMethod.LINEAR``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;trilinear&quot;``, 
    ``&quot;triangle&quot;`` `Linear interpolation`_. If ``antialias`` is ``True``, uses a 
    triangular filter when downsampling. 
 
  ``ResizeMethod.CUBIC``, ``&quot;cubic&quot;``, ``&quot;bicubic&quot;``, ``&quot;tricubic&quot;`` 
    `Cubic interpolation`_, using the Keys cubic kernel. 
 
  ``ResizeMethod.LANCZOS3``, ``&quot;lanczos3&quot;`` 
    `Lanczos resampling`_, using a kernel of radius 3. 
 
  ``ResizeMethod.LANCZOS5``, ``&quot;lanczos5&quot;`` 
    `Lanczos resampling`_, using a kernel of radius 5. 
 
  .. _Linear interpolation: https://en.wikipedia.org/wiki/Bilinear_interpolation 
  .. _Cubic interpolation: https://en.wikipedia.org/wiki/Bicubic_interpolation 
  .. _Lanczos resampling: https://en.wikipedia.org/wiki/Lanczos_resampling 
 
  Args: 
    image: a JAX array. 
    shape: the output shape, as a sequence of integers with length equal to the 
      number of dimensions of `image`. 
    spatial_dims: A length K tuple specifying the spatial dimensions that the 
      passed scale and translation should be applied to. 
    scale: A [K] array with the same number of dimensions as image, containing 
      the scale to apply in each dimension. 
    translation: A [K] array with the same number of dimensions as image, 
      containing the translation to apply in each dimension. 
    method: the resizing method to use; either a ``ResizeMethod`` instance or a 
      string. Available methods are: LINEAR, LANCZOS3, LANCZOS5, CUBIC. 
    antialias: Should an antialiasing filter be used when downsampling? Defaults 
      to ``True``. Has no effect when upsampling. 
 
  Returns: 
    The scale and translated image. 
  &quot;&quot;&quot;</span>
  <span class="s1">shape = core.canonicalize_shape(shape)</span>
  <span class="s2">if </span><span class="s1">len(shape) != image.ndim:</span>
    <span class="s1">msg = (</span><span class="s5">'shape must have length equal to the number of dimensions of x; '</span>
           <span class="s5">f' </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">} </span><span class="s5">vs </span><span class="s2">{</span><span class="s1">image.shape</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
  <span class="s2">if </span><span class="s1">isinstance(method</span><span class="s2">, </span><span class="s1">str):</span>
    <span class="s1">method = ResizeMethod.from_string(method)</span>
  <span class="s2">if </span><span class="s1">method == ResizeMethod.NEAREST:</span>
    <span class="s0"># Nearest neighbor is currently special-cased for straight resize, so skip</span>
    <span class="s0"># for now.</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Nearest neighbor resampling is not currently supported '</span>
                     <span class="s5">'for scale_and_translate.'</span><span class="s1">)</span>
  <span class="s2">assert </span><span class="s1">isinstance(method</span><span class="s2">, </span><span class="s1">ResizeMethod)</span>

  <span class="s1">kernel = _kernels[method]</span>
  <span class="s1">image</span><span class="s2">, </span><span class="s1">= promote_dtypes_inexact(image)</span>
  <span class="s1">scale</span><span class="s2">, </span><span class="s1">translation = promote_dtypes_inexact(scale</span><span class="s2">, </span><span class="s1">translation)</span>
  <span class="s2">return </span><span class="s1">_scale_and_translate(image</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">spatial_dims</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">translation</span><span class="s2">,</span>
                              <span class="s1">kernel</span><span class="s2">, </span><span class="s1">antialias</span><span class="s2">, </span><span class="s1">precision)</span>


<span class="s2">def </span><span class="s1">_resize_nearest(x</span><span class="s2">, </span><span class="s1">output_shape: core.Shape):</span>
  <span class="s1">input_shape = x.shape</span>
  <span class="s2">assert </span><span class="s1">len(input_shape) == len(output_shape)</span>
  <span class="s1">spatial_dims = tuple(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(input_shape))</span>
                       <span class="s2">if not </span><span class="s1">core.symbolic_equal_dim(input_shape[i]</span><span class="s2">, </span><span class="s1">output_shape[i]))</span>
  <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">spatial_dims:</span>
    <span class="s1">m = input_shape[d]</span>
    <span class="s1">n = output_shape[d]</span>
    <span class="s1">offsets = (jnp.arange(n</span><span class="s2">, </span><span class="s1">dtype=np.float32) + </span><span class="s3">0.5</span><span class="s1">) * core.dimension_as_value(m) / core.dimension_as_value(n)</span>
    <span class="s0"># TODO(b/206898375): this computation produces the wrong result on</span>
    <span class="s0"># CPU and GPU when using float64. Use float32 until the bug is fixed.</span>
    <span class="s1">offsets = jnp.floor(offsets.astype(np.float32)).astype(np.int32)</span>
    <span class="s1">indices = [slice(</span><span class="s2">None</span><span class="s1">)] * len(input_shape)</span>
    <span class="s1">indices[d] = offsets</span>
    <span class="s1">x = x[tuple(indices)]</span>
  <span class="s2">return </span><span class="s1">x</span>


<span class="s1">@partial(jit</span><span class="s2">, </span><span class="s1">static_argnums=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">_resize(image</span><span class="s2">, </span><span class="s1">shape: core.Shape</span><span class="s2">, </span><span class="s1">method: Union[str</span><span class="s2">, </span><span class="s1">ResizeMethod]</span><span class="s2">,</span>
            <span class="s1">antialias: bool</span><span class="s2">, </span><span class="s1">precision):</span>
  <span class="s2">if </span><span class="s1">len(shape) != image.ndim:</span>
    <span class="s1">msg = (</span><span class="s5">'shape must have length equal to the number of dimensions of x; '</span>
           <span class="s5">f' </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">} </span><span class="s5">vs </span><span class="s2">{</span><span class="s1">image.shape</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
  <span class="s2">if </span><span class="s1">isinstance(method</span><span class="s2">, </span><span class="s1">str):</span>
    <span class="s1">method = ResizeMethod.from_string(method)</span>
  <span class="s2">if </span><span class="s1">method == ResizeMethod.NEAREST:</span>
    <span class="s2">return </span><span class="s1">_resize_nearest(image</span><span class="s2">, </span><span class="s1">shape)</span>
  <span class="s2">assert </span><span class="s1">isinstance(method</span><span class="s2">, </span><span class="s1">ResizeMethod)</span>
  <span class="s1">kernel = _kernels[method]</span>

  <span class="s1">image</span><span class="s2">, </span><span class="s1">= promote_dtypes_inexact(image)</span>
  <span class="s0"># Skip dimensions that have scale=1 and translation=0, this is only possible</span>
  <span class="s0"># since all of the current resize methods (kernels) are interpolating, so the</span>
  <span class="s0"># output = input under an identity warp.</span>
  <span class="s1">spatial_dims = tuple(i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(shape))</span>
                       <span class="s2">if not </span><span class="s1">core.symbolic_equal_dim(image.shape[i]</span><span class="s2">, </span><span class="s1">shape[i]))</span>
  <span class="s1">scale = [</span><span class="s3">1.0 </span><span class="s2">if </span><span class="s1">core.symbolic_equal_dim(shape[d]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">) </span><span class="s2">else </span><span class="s1">core.dimension_as_value(shape[d]) / core.dimension_as_value(image.shape[d])</span>
           <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">spatial_dims]</span>
  <span class="s2">return </span><span class="s1">_scale_and_translate(image</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">spatial_dims</span><span class="s2">,</span>
                              <span class="s1">scale</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s1">] * len(spatial_dims)</span><span class="s2">, </span><span class="s1">kernel</span><span class="s2">,</span>
                              <span class="s1">antialias</span><span class="s2">, </span><span class="s1">precision)</span>


<span class="s2">def </span><span class="s1">resize(image</span><span class="s2">, </span><span class="s1">shape: core.Shape</span><span class="s2">, </span><span class="s1">method: Union[str</span><span class="s2">, </span><span class="s1">ResizeMethod]</span><span class="s2">,</span>
           <span class="s1">antialias: bool = </span><span class="s2">True,</span>
           <span class="s1">precision = lax.Precision.HIGHEST):</span>
  <span class="s4">&quot;&quot;&quot;Image resize. 
 
  The ``method`` argument expects one of the following resize methods: 
 
  ``ResizeMethod.NEAREST``, ``&quot;nearest&quot;`` 
    `Nearest neighbor interpolation`_. The values of ``antialias`` and 
    ``precision`` are ignored. 
 
  ``ResizeMethod.LINEAR``, ``&quot;linear&quot;``, ``&quot;bilinear&quot;``, ``&quot;trilinear&quot;``, ``&quot;triangle&quot;`` 
    `Linear interpolation`_. If ``antialias`` is ``True``, uses a triangular 
    filter when downsampling. 
 
  ``ResizeMethod.CUBIC``, ``&quot;cubic&quot;``, ``&quot;bicubic&quot;``, ``&quot;tricubic&quot;`` 
    `Cubic interpolation`_, using the Keys cubic kernel. 
 
  ``ResizeMethod.LANCZOS3``, ``&quot;lanczos3&quot;`` 
    `Lanczos resampling`_, using a kernel of radius 3. 
 
  ``ResizeMethod.LANCZOS5``, ``&quot;lanczos5&quot;`` 
    `Lanczos resampling`_, using a kernel of radius 5. 
 
  .. _Nearest neighbor interpolation: https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation 
  .. _Linear interpolation: https://en.wikipedia.org/wiki/Bilinear_interpolation 
  .. _Cubic interpolation: https://en.wikipedia.org/wiki/Bicubic_interpolation 
  .. _Lanczos resampling: https://en.wikipedia.org/wiki/Lanczos_resampling 
 
  Args: 
    image: a JAX array. 
    shape: the output shape, as a sequence of integers with length equal to 
      the number of dimensions of `image`. Note that :func:`resize` does not 
      distinguish spatial dimensions from batch or channel dimensions, so this 
      includes all dimensions of the image. To represent a batch or a channel 
      dimension, simply leave that element of the shape unchanged. 
    method: the resizing method to use; either a ``ResizeMethod`` instance or a 
      string. Available methods are: LINEAR, LANCZOS3, LANCZOS5, CUBIC. 
    antialias: should an antialiasing filter be used when downsampling? Defaults 
      to ``True``. Has no effect when upsampling. 
  Returns: 
    The resized image. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_resize(image</span><span class="s2">, </span><span class="s1">core.canonicalize_shape(shape)</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">antialias</span><span class="s2">,</span>
                 <span class="s1">precision)</span>
</pre>
</body>
</html>