<html>
<head>
<title>api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">&quot;&quot;&quot;JAX primitives related to sparse operations. 
 
This is experimental work to explore sparse support in JAX. 
 
The primitives defined here are deliberately low-level: each primitive implements 
a common sparse operation (sparse to dense, dense to sparse, sparse matrix/vector 
product, sparse matrix/matrix product) for two common sparse representations 
(CSR and COO). 
 
These routines have reference implementations defined via XLA scatter/gather 
operations that will work on any backend, although they are not particularly 
performant. On GPU runtimes built against CUDA 11.0/ROCm 5.0 or newer, each operation is 
computed efficiently via cusparse/hipsparse. 
 
Further down are some examples of potential high-level wrappers for sparse objects. 
(API should be considered unstable and subject to change). 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">jax</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">tree_util</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse._base </span><span class="s3">import </span><span class="s1">JAXSparse</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse.bcoo </span><span class="s3">import </span><span class="s1">BCOO</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse.bcsr </span><span class="s3">import </span><span class="s1">BCSR</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse.coo </span><span class="s3">import </span><span class="s1">COO</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse.csr </span><span class="s3">import </span><span class="s1">CSR</span><span class="s3">, </span><span class="s1">CSC</span>
<span class="s3">from </span><span class="s1">jax.experimental.sparse.util </span><span class="s3">import </span><span class="s1">_coo_extract</span>
<span class="s3">from </span><span class="s1">jax.interpreters </span><span class="s3">import </span><span class="s1">mlir</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">ad</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">batching</span>
<span class="s3">from </span><span class="s1">jax._src.typing </span><span class="s3">import </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">DTypeLike</span><span class="s3">, </span><span class="s1">Shape</span>


<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0"># todense â€“ function to convert sparse matrices to dense while letting</span>
<span class="s0">#           dense matrices pass through.</span>
<span class="s1">todense_p = core.Primitive(</span><span class="s4">'todense'</span><span class="s1">)</span>
<span class="s1">todense_p.multiple_results = </span><span class="s3">False</span>

<span class="s3">def </span><span class="s1">todense(arr: Union[JAXSparse</span><span class="s3">, </span><span class="s1">Array]) -&gt; Array:</span>
  <span class="s2">&quot;&quot;&quot;Convert input to a dense matrix. If input is already dense, pass through.&quot;&quot;&quot;</span>
  <span class="s1">bufs</span><span class="s3">, </span><span class="s1">tree = tree_util.tree_flatten(arr)</span>
  <span class="s3">return </span><span class="s1">todense_p.bind(*bufs</span><span class="s3">, </span><span class="s1">tree=tree)</span>

<span class="s1">@todense_p.def_impl</span>
<span class="s3">def </span><span class="s1">_todense_impl(*bufs</span><span class="s3">, </span><span class="s1">tree):</span>
  <span class="s1">arr = tree_util.tree_unflatten(tree</span><span class="s3">, </span><span class="s1">bufs)</span>
  <span class="s3">return </span><span class="s1">arr.todense() </span><span class="s3">if </span><span class="s1">isinstance(arr</span><span class="s3">, </span><span class="s1">JAXSparse) </span><span class="s3">else </span><span class="s1">arr</span>

<span class="s1">@todense_p.def_abstract_eval</span>
<span class="s3">def </span><span class="s1">_todense_abstract_eval(*bufs</span><span class="s3">, </span><span class="s1">tree):</span>
  <span class="s1">arr = tree_util.tree_unflatten(tree</span><span class="s3">, </span><span class="s1">bufs)</span>
  <span class="s3">if </span><span class="s1">isinstance(arr</span><span class="s3">, </span><span class="s1">core.ShapedArray):</span>
    <span class="s3">return </span><span class="s1">arr</span>
  <span class="s3">return </span><span class="s1">core.ShapedArray(arr.shape</span><span class="s3">, </span><span class="s1">arr.dtype</span><span class="s3">, </span><span class="s1">weak_type=dtypes.is_weakly_typed(arr.data))</span>

<span class="s3">def </span><span class="s1">_todense_jvp(primals</span><span class="s3">, </span><span class="s1">tangents</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">tree):</span>
  <span class="s3">assert not </span><span class="s1">isinstance(tangents[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ad.Zero)</span>
  <span class="s3">assert </span><span class="s1">all(isinstance(t</span><span class="s3">, </span><span class="s1">ad.Zero) </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tangents[</span><span class="s5">1</span><span class="s1">:])</span>
  <span class="s1">primals_out = todense_p.bind(*primals</span><span class="s3">, </span><span class="s1">tree=tree)</span>
  <span class="s1">tangents_out = todense_p.bind(tangents[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">*primals[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">tree=tree)</span>
  <span class="s3">return </span><span class="s1">primals_out</span><span class="s3">, </span><span class="s1">tangents_out</span>

<span class="s3">def </span><span class="s1">_todense_transpose(ct</span><span class="s3">, </span><span class="s1">*bufs</span><span class="s3">, </span><span class="s1">tree):</span>
  <span class="s3">assert </span><span class="s1">ad.is_undefined_primal(bufs[</span><span class="s5">0</span><span class="s1">])</span>
  <span class="s3">assert not </span><span class="s1">any(ad.is_undefined_primal(buf) </span><span class="s3">for </span><span class="s1">buf </span><span class="s3">in </span><span class="s1">bufs[</span><span class="s5">1</span><span class="s1">:])</span>

  <span class="s1">standin = object()</span>
  <span class="s1">obj = tree_util.tree_unflatten(tree</span><span class="s3">, </span><span class="s1">[standin] * len(bufs))</span>
  <span class="s3">from </span><span class="s1">jax.experimental.sparse </span><span class="s3">import </span><span class="s1">BCOO</span><span class="s3">, </span><span class="s1">BCSR</span>
  <span class="s3">from </span><span class="s1">jax.experimental.sparse.bcoo </span><span class="s3">import </span><span class="s1">_bcoo_extract</span>
  <span class="s3">from </span><span class="s1">jax.experimental.sparse.bcsr </span><span class="s3">import </span><span class="s1">bcsr_extract</span>
  <span class="s3">if </span><span class="s1">obj </span><span class="s3">is </span><span class="s1">standin:</span>
    <span class="s3">return </span><span class="s1">(ct</span><span class="s3">,</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">BCOO):</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">indices = bufs</span>
    <span class="s3">return </span><span class="s1">_bcoo_extract(indices</span><span class="s3">, </span><span class="s1">ct)</span><span class="s3">, </span><span class="s1">indices</span>
  <span class="s3">elif </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">BCSR):</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr = bufs</span>
    <span class="s3">return </span><span class="s1">bcsr_extract(indices</span><span class="s3">, </span><span class="s1">indptr</span><span class="s3">, </span><span class="s1">ct)</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr</span>
  <span class="s3">elif </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">COO):</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col = bufs</span>
    <span class="s3">return </span><span class="s1">_coo_extract(row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">ct)</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">f&quot;todense_transpose for </span><span class="s3">{</span><span class="s1">type(obj)</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_todense_batching_rule(batched_args</span><span class="s3">, </span><span class="s1">batch_dims</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">tree):</span>
  <span class="s3">return </span><span class="s1">jax.vmap(partial(_todense_impl</span><span class="s3">, </span><span class="s1">tree=tree)</span><span class="s3">, </span><span class="s1">batch_dims)(*batched_args)</span><span class="s3">, </span><span class="s5">0</span>

<span class="s1">ad.primitive_jvps[todense_p] = _todense_jvp</span>
<span class="s1">ad.primitive_transposes[todense_p] = _todense_transpose</span>
<span class="s1">batching.primitive_batchers[todense_p] = _todense_batching_rule</span>
<span class="s1">mlir.register_lowering(todense_p</span><span class="s3">, </span><span class="s1">mlir.lower_fun(</span>
    <span class="s1">_todense_impl</span><span class="s3">, </span><span class="s1">multiple_results=</span><span class="s3">False</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">empty(shape: Shape</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike]=</span><span class="s3">None, </span><span class="s1">index_dtype: DTypeLike = </span><span class="s4">'int32'</span><span class="s3">,</span>
          <span class="s1">sparse_format: str = </span><span class="s4">'bcoo'</span><span class="s3">, </span><span class="s1">**kwds) -&gt; JAXSparse:</span>
  <span class="s2">&quot;&quot;&quot;Create an empty sparse array. 
 
  Args: 
    shape: sequence of integers giving the array shape. 
    dtype: (optional) dtype of the array. 
    index_dtype: (optional) dtype of the index arrays. 
    format: string specifying the matrix format (e.g. ['bcoo']). 
    **kwds: additional keywords passed to the format-specific _empty constructor. 
  Returns: 
    mat: empty sparse matrix. 
  &quot;&quot;&quot;</span>
  <span class="s1">formats = {</span><span class="s4">'bcsr'</span><span class="s1">: BCSR</span><span class="s3">, </span><span class="s4">'bcoo'</span><span class="s1">: BCOO</span><span class="s3">, </span><span class="s4">'coo'</span><span class="s1">: COO</span><span class="s3">, </span><span class="s4">'csr'</span><span class="s1">: CSR</span><span class="s3">, </span><span class="s4">'csc'</span><span class="s1">: CSC}</span>
  <span class="s3">if </span><span class="s1">sparse_format </span><span class="s3">not in </span><span class="s1">formats:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;sparse_format=</span><span class="s3">{</span><span class="s1">sparse_format</span><span class="s3">!r} </span><span class="s4">not recognized; &quot;</span>
                     <span class="s4">f&quot;must be one of </span><span class="s3">{</span><span class="s1">list(formats.keys())</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s1">cls = formats[sparse_format]</span>
  <span class="s3">return </span><span class="s1">cls._empty(shape</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">index_dtype=index_dtype</span><span class="s3">, </span><span class="s1">**kwds)</span>


<span class="s3">def </span><span class="s1">eye(N: int</span><span class="s3">, </span><span class="s1">M: Optional[int] = </span><span class="s3">None, </span><span class="s1">k: int = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype: Optional[DTypeLike] = </span><span class="s3">None,</span>
        <span class="s1">index_dtype: DTypeLike = </span><span class="s4">'int32'</span><span class="s3">, </span><span class="s1">sparse_format: str = </span><span class="s4">'bcoo'</span><span class="s3">, </span><span class="s1">**kwds) -&gt; JAXSparse:</span>
  <span class="s2">&quot;&quot;&quot;Create 2D sparse identity matrix. 
 
  Args: 
    N: int. Number of rows in the output. 
    M: int, optional. Number of columns in the output. If None, defaults to `N`. 
    k: int, optional. Index of the diagonal: 0 (the default) refers to the main 
       diagonal, a positive value refers to an upper diagonal, and a negative value 
       to a lower diagonal. 
    dtype: data-type, optional. Data-type of the returned array. 
    index_dtype: (optional) dtype of the index arrays. 
    format: string specifying the matrix format (e.g. ['bcoo']). 
    **kwds: additional keywords passed to the format-specific _empty constructor. 
 
  Returns: 
    I: two-dimensional sparse matrix with ones along the k-th diagonal. 
  &quot;&quot;&quot;</span>
  <span class="s1">formats = {</span><span class="s4">'bcoo'</span><span class="s1">: BCOO</span><span class="s3">, </span><span class="s4">'coo'</span><span class="s1">: COO</span><span class="s3">, </span><span class="s4">'csr'</span><span class="s1">: CSR</span><span class="s3">, </span><span class="s4">'csc'</span><span class="s1">: CSC}</span>
  <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">M = N</span>
  <span class="s1">N = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">N)</span>
  <span class="s1">M = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">M)</span>
  <span class="s1">k = core.concrete_or_error(operator.index</span><span class="s3">, </span><span class="s1">k)</span>

  <span class="s1">cls = formats[sparse_format]</span>
  <span class="s3">return </span><span class="s1">cls._eye(M=M</span><span class="s3">, </span><span class="s1">N=N</span><span class="s3">, </span><span class="s1">k=k</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">index_dtype=index_dtype</span><span class="s3">, </span><span class="s1">**kwds)</span>
</pre>
</body>
</html>