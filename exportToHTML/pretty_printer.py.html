<html>
<head>
<title>pretty_printer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pretty_printer.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2021 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s0">#</span>
<span class="s0"># Wadler-Lindig pretty printer.</span>
<span class="s0">#</span>
<span class="s0"># References:</span>
<span class="s0"># Wadler, P., 1998. A prettier printer. Journal of Functional Programming,</span>
<span class="s0"># pp.223-244.</span>
<span class="s0">#</span>
<span class="s0"># Lindig, C. 2000. Strictly Pretty.</span>
<span class="s0"># https://lindig.github.io/papers/strictly-pretty-2000.pdf</span>
<span class="s0">#</span>
<span class="s0"># Hafiz, A. 2021. Strictly Annotated: A Pretty-Printer With Support for</span>
<span class="s0"># Annotations. https://ayazhafiz.com/articles/21/strictly-annotated</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span><span class="s2">, </span><span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span>

<span class="s2">try</span><span class="s1">:</span>
  <span class="s2">import </span><span class="s1">colorama  </span><span class="s0"># pytype: disable=import-error</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
  <span class="s1">colorama = </span><span class="s2">None</span>

<span class="s2">def </span><span class="s1">_can_use_color() -&gt; bool:</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s0"># Check if we're in IPython or Colab</span>
    <span class="s1">ipython = get_ipython()  </span><span class="s0"># type: ignore[name-defined]</span>
    <span class="s1">shell = ipython.__class__.__name__</span>
    <span class="s2">if </span><span class="s1">shell == </span><span class="s3">&quot;ZMQInteractiveShell&quot;</span><span class="s1">:</span>
      <span class="s0"># Jupyter Notebook</span>
      <span class="s2">return True</span>
    <span class="s2">elif </span><span class="s3">&quot;colab&quot; </span><span class="s2">in </span><span class="s1">str(ipython.__class__):</span>
      <span class="s0"># Google Colab (external or internal)</span>
      <span class="s2">return True</span>
  <span class="s2">except </span><span class="s1">NameError:</span>
    <span class="s2">pass</span>
  <span class="s0"># Otherwise check if we're in a terminal</span>
  <span class="s2">return </span><span class="s1">hasattr(sys.stdout</span><span class="s2">, </span><span class="s3">'isatty'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">sys.stdout.isatty()</span>

<span class="s1">CAN_USE_COLOR = _can_use_color()</span>

<span class="s2">class </span><span class="s1">Doc(abc.ABC):</span>
  <span class="s1">__slots__ = ()</span>

  <span class="s2">def </span><span class="s1">format(self</span><span class="s2">, </span><span class="s1">width: int = </span><span class="s4">80</span><span class="s2">, </span><span class="s1">use_color: Optional[bool] = </span><span class="s2">None,</span>
             <span class="s1">annotation_prefix=</span><span class="s3">&quot; # &quot;</span><span class="s1">) -&gt; str:</span>
    <span class="s2">if </span><span class="s1">use_color </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s1">use_color = CAN_USE_COLOR </span><span class="s2">and </span><span class="s1">config.FLAGS.jax_pprint_use_color</span>
    <span class="s2">return </span><span class="s1">_format(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">use_color=use_color</span><span class="s2">,</span>
                   <span class="s1">annotation_prefix=annotation_prefix)</span>

  <span class="s2">def </span><span class="s1">__str__(self):</span>
    <span class="s2">return </span><span class="s1">self.format()</span>

  <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other: </span><span class="s3">'Doc'</span><span class="s1">) -&gt; </span><span class="s3">'Doc'</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">concat([self</span><span class="s2">, </span><span class="s1">other])</span>

<span class="s2">class </span><span class="s1">_NilDoc(Doc):</span>
  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">&quot;nil&quot;</span>

<span class="s1">_nil = _NilDoc()</span>

<span class="s2">class </span><span class="s1">_TextDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;text&quot;</span><span class="s2">, </span><span class="s3">&quot;annotation&quot;</span><span class="s1">)</span>
  <span class="s1">text: str</span>
  <span class="s1">annotation: Optional[str]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">text: str</span><span class="s2">, </span><span class="s1">annotation: Optional[str] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">assert </span><span class="s1">isinstance(text</span><span class="s2">, </span><span class="s1">str)</span><span class="s2">, </span><span class="s1">text</span>
    <span class="s2">assert </span><span class="s1">annotation </span><span class="s2">is None or </span><span class="s1">isinstance(annotation</span><span class="s2">, </span><span class="s1">str)</span><span class="s2">, </span><span class="s1">annotation</span>
    <span class="s1">self.text = text</span>
    <span class="s1">self.annotation = annotation</span>

  <span class="s2">def </span><span class="s1">__repr__(self):</span>
    <span class="s2">if </span><span class="s1">self.annotation </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s3">f&quot;text(</span><span class="s2">\&quot;{</span><span class="s1">self.text</span><span class="s2">}\&quot;</span><span class="s3">, annotation=</span><span class="s2">\&quot;{</span><span class="s1">self.annotation</span><span class="s2">}\&quot;</span><span class="s3">)&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s3">f&quot;text(</span><span class="s2">\&quot;{</span><span class="s1">self.text</span><span class="s2">}\&quot;</span><span class="s3">)&quot;</span>

<span class="s2">class </span><span class="s1">_ConcatDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;children&quot;</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">children: List[Doc]</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">children: Sequence[Doc]):</span>
    <span class="s1">self.children = list(children)</span>
    <span class="s2">assert </span><span class="s1">all(isinstance(doc</span><span class="s2">, </span><span class="s1">Doc) </span><span class="s2">for </span><span class="s1">doc </span><span class="s2">in </span><span class="s1">self.children)</span><span class="s2">, </span><span class="s1">self.children</span>

  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">f&quot;concat(</span><span class="s2">{</span><span class="s1">self.children</span><span class="s2">}</span><span class="s3">)&quot;</span>

<span class="s2">class </span><span class="s1">_BreakDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;text&quot;</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">text: str</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">text: str):</span>
    <span class="s2">assert </span><span class="s1">isinstance(text</span><span class="s2">, </span><span class="s1">str)</span><span class="s2">, </span><span class="s1">text</span>
    <span class="s1">self.text = text</span>

  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">f&quot;break(</span><span class="s2">{</span><span class="s1">self.text</span><span class="s2">}</span><span class="s3">)&quot;</span>

<span class="s2">class </span><span class="s1">_GroupDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;child&quot;</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">child: Doc</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">child: Doc):</span>
    <span class="s2">assert </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">Doc)</span><span class="s2">, </span><span class="s1">child</span>
    <span class="s1">self.child = child</span>

  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">f&quot;group(</span><span class="s2">{</span><span class="s1">self.child</span><span class="s2">}</span><span class="s3">)&quot;</span>

<span class="s2">class </span><span class="s1">_NestDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;n&quot;</span><span class="s2">, </span><span class="s3">&quot;child&quot;</span><span class="s2">,</span><span class="s1">)</span>
  <span class="s1">n: int</span>
  <span class="s1">child: Doc</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">n: int</span><span class="s2">, </span><span class="s1">child: Doc):</span>
    <span class="s2">assert </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">Doc)</span><span class="s2">, </span><span class="s1">child</span>
    <span class="s1">self.n = n</span>
    <span class="s1">self.child = child</span>

  <span class="s2">def </span><span class="s1">__repr__(self): </span><span class="s2">return </span><span class="s3">f&quot;nest(</span><span class="s2">{</span><span class="s1">self.n</span><span class="s2">, </span><span class="s1">self.child</span><span class="s2">}</span><span class="s3">)&quot;</span>


<span class="s1">Color = enum.Enum(</span><span class="s3">&quot;_Color&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;BLACK&quot;</span><span class="s2">, </span><span class="s3">&quot;RED&quot;</span><span class="s2">, </span><span class="s3">&quot;GREEN&quot;</span><span class="s2">, </span><span class="s3">&quot;YELLOW&quot;</span><span class="s2">, </span><span class="s3">&quot;BLUE&quot;</span><span class="s2">,</span>
                             <span class="s3">&quot;MAGENTA&quot;</span><span class="s2">, </span><span class="s3">&quot;CYAN&quot;</span><span class="s2">, </span><span class="s3">&quot;WHITE&quot;</span><span class="s2">, </span><span class="s3">&quot;RESET&quot;</span><span class="s1">])</span>
<span class="s1">Intensity = enum.Enum(</span><span class="s3">&quot;_Intensity&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;DIM&quot;</span><span class="s2">, </span><span class="s3">&quot;NORMAL&quot;</span><span class="s2">, </span><span class="s3">&quot;BRIGHT&quot;</span><span class="s1">])</span>

<span class="s2">class </span><span class="s1">_ColorDoc(Doc):</span>
  <span class="s1">__slots__ = (</span><span class="s3">&quot;foreground&quot;</span><span class="s2">, </span><span class="s3">&quot;background&quot;</span><span class="s2">, </span><span class="s3">&quot;intensity&quot;</span><span class="s2">, </span><span class="s3">&quot;child&quot;</span><span class="s1">)</span>
  <span class="s1">foreground: Optional[Color]</span>
  <span class="s1">background: Optional[Color]</span>
  <span class="s1">intensity: Optional[Intensity]</span>
  <span class="s1">child: Doc</span>

  <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">child: Doc</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">foreground: Optional[Color] = </span><span class="s2">None,</span>
               <span class="s1">background: Optional[Color] = </span><span class="s2">None,</span>
               <span class="s1">intensity: Optional[Intensity] = </span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">assert </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">Doc)</span><span class="s2">, </span><span class="s1">child</span>
    <span class="s1">self.child = child</span>
    <span class="s1">self.foreground = foreground</span>
    <span class="s1">self.background = background</span>
    <span class="s1">self.intensity = intensity</span>


<span class="s1">_BreakMode = enum.Enum(</span><span class="s3">&quot;_BreakMode&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;FLAT&quot;</span><span class="s2">, </span><span class="s3">&quot;BREAK&quot;</span><span class="s1">])</span>


<span class="s0"># In Lindig's paper fits() and format() are defined recursively. This is a</span>
<span class="s0"># non-recursive formulation using an explicit stack, necessary because Python</span>
<span class="s0"># doesn't have a tail recursion optimization.</span>

<span class="s2">def </span><span class="s1">_fits(doc: Doc</span><span class="s2">, </span><span class="s1">width: int</span><span class="s2">, </span><span class="s1">agenda: List[Tuple[int</span><span class="s2">, </span><span class="s1">_BreakMode</span><span class="s2">, </span><span class="s1">Doc]]</span>
         <span class="s1">) -&gt; bool:</span>
  <span class="s2">while </span><span class="s1">width &gt;= </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">len(agenda) &gt; </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc = agenda.pop()</span>
    <span class="s2">if </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NilDoc):</span>
      <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_TextDoc):</span>
      <span class="s1">width -= len(doc.text)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ConcatDoc):</span>
      <span class="s1">agenda.extend((i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">d) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">reversed(doc.children))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_BreakDoc):</span>
      <span class="s2">if </span><span class="s1">m == _BreakMode.BREAK:</span>
        <span class="s2">return True</span>
      <span class="s1">width -= len(doc.text)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NestDoc):</span>
      <span class="s1">agenda.append((i + doc.n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc.child))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_GroupDoc):</span>
      <span class="s1">agenda.append((i</span><span class="s2">, </span><span class="s1">_BreakMode.FLAT</span><span class="s2">, </span><span class="s1">doc.child))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ColorDoc):</span>
      <span class="s1">agenda.append((i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc.child))</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid document &quot;</span><span class="s2">, </span><span class="s1">doc)</span>

  <span class="s2">return </span><span class="s1">width &gt;= </span><span class="s4">0</span>


<span class="s0"># Annotation layout: A flat group is sparse if there are no breaks between</span>
<span class="s0"># annotations.</span>
<span class="s2">def </span><span class="s1">_sparse(doc: Doc) -&gt; bool:</span>
  <span class="s1">agenda = [doc]</span>
  <span class="s1">num_annotations = </span><span class="s4">0</span>
  <span class="s1">seen_break = </span><span class="s2">False</span>
  <span class="s2">while </span><span class="s1">len(agenda) &gt; </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">doc = agenda.pop()</span>
    <span class="s2">if </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NilDoc):</span>
      <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_TextDoc):</span>
      <span class="s2">if </span><span class="s1">doc.annotation </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">num_annotations &gt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">seen_break:</span>
          <span class="s2">return False</span>
        <span class="s1">num_annotations += </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ConcatDoc):</span>
      <span class="s1">agenda.extend(reversed(doc.children))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_BreakDoc):</span>
      <span class="s1">seen_break = </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NestDoc):</span>
      <span class="s1">agenda.append(doc.child)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_GroupDoc):</span>
      <span class="s1">agenda.append(doc.child)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ColorDoc):</span>
      <span class="s1">agenda.append(doc.child)</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid document &quot;</span><span class="s2">, </span><span class="s1">doc)</span>

  <span class="s2">return True</span>

<span class="s2">class </span><span class="s1">_ColorState(NamedTuple):</span>
  <span class="s1">foreground: Color</span>
  <span class="s1">background: Color</span>
  <span class="s1">intensity: Intensity</span>

<span class="s2">class </span><span class="s1">_State(NamedTuple):</span>
  <span class="s1">indent: int</span>
  <span class="s1">mode: _BreakMode</span>
  <span class="s1">doc: Doc</span>
  <span class="s1">color: _ColorState</span>

<span class="s2">class </span><span class="s1">_Line(NamedTuple):</span>
  <span class="s1">text: str</span>
  <span class="s1">width: int</span>
  <span class="s1">annotations: Union[Optional[str]</span><span class="s2">, </span><span class="s1">List[str]]</span>


<span class="s2">def </span><span class="s1">_update_color(use_color: bool</span><span class="s2">, </span><span class="s1">state: _ColorState</span><span class="s2">, </span><span class="s1">update: _ColorState</span>
                 <span class="s1">) -&gt; Tuple[_ColorState</span><span class="s2">, </span><span class="s1">str]:</span>
  <span class="s2">if not </span><span class="s1">use_color </span><span class="s2">or </span><span class="s1">colorama </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">update</span><span class="s2">, </span><span class="s3">&quot;&quot;</span>
  <span class="s1">color_str = </span><span class="s3">&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">state.foreground != update.foreground:</span>
    <span class="s1">color_str += getattr(colorama.Fore</span><span class="s2">, </span><span class="s1">str(update.foreground.name))</span>
  <span class="s2">if </span><span class="s1">state.background != update.background:</span>
    <span class="s1">color_str += getattr(colorama.Back</span><span class="s2">, </span><span class="s1">str(update.background.name))</span>
  <span class="s2">if </span><span class="s1">state.intensity != update.intensity:</span>
    <span class="s1">color_str += colorama.Style.NORMAL</span>
    <span class="s1">color_str += getattr(colorama.Style</span><span class="s2">, </span><span class="s1">str(update.intensity.name))</span>
  <span class="s2">return </span><span class="s1">update</span><span class="s2">, </span><span class="s1">color_str</span>


<span class="s2">def </span><span class="s1">_align_annotations(lines):</span>
  <span class="s0"># TODO: Hafiz also implements a local alignment mode, where groups of lines</span>
  <span class="s0"># with annotations are aligned together.</span>
  <span class="s1">maxlen = max(l.width </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines)</span>
  <span class="s1">out = []</span>
  <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines:</span>
    <span class="s2">if </span><span class="s1">len(l.annotations) == </span><span class="s4">0</span><span class="s1">:</span>
      <span class="s1">out.append(l._replace(annotations=</span><span class="s2">None</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">len(l.annotations) == </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">out.append(l._replace(text=l.text + </span><span class="s3">&quot; &quot; </span><span class="s1">* (maxlen - l.width)</span><span class="s2">,</span>
                            <span class="s1">annotations=l.annotations[</span><span class="s4">0</span><span class="s1">]))</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">out.append(l._replace(text=l.text + </span><span class="s3">&quot; &quot; </span><span class="s1">* (maxlen - l.width)</span><span class="s2">,</span>
                            <span class="s1">annotations=l.annotations[</span><span class="s4">0</span><span class="s1">]))</span>
      <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">l.annotations[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s1">out.append(_Line(text=</span><span class="s3">&quot; &quot; </span><span class="s1">* maxlen</span><span class="s2">, </span><span class="s1">width=l.width</span><span class="s2">, </span><span class="s1">annotations=a))</span>
  <span class="s2">return </span><span class="s1">out</span>



<span class="s2">def </span><span class="s1">_format(doc: Doc</span><span class="s2">, </span><span class="s1">width: int</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">use_color</span><span class="s2">, </span><span class="s1">annotation_prefix) -&gt; str:</span>
  <span class="s1">lines = []</span>
  <span class="s1">default_colors = _ColorState(Color.RESET</span><span class="s2">, </span><span class="s1">Color.RESET</span><span class="s2">, </span><span class="s1">Intensity.NORMAL)</span>
  <span class="s1">annotation_colors = _ColorState(Color.RESET</span><span class="s2">, </span><span class="s1">Color.RESET</span><span class="s2">, </span><span class="s1">Intensity.DIM)</span>
  <span class="s1">color_state = default_colors</span>
  <span class="s1">agenda = [_State(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">_BreakMode.BREAK</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">default_colors)]</span>
  <span class="s1">k = </span><span class="s4">0</span>
  <span class="s1">line_text = </span><span class="s3">&quot;&quot;</span>
  <span class="s1">line_annotations = []</span>
  <span class="s2">while </span><span class="s1">len(agenda) &gt; </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">color = agenda.pop()</span>
    <span class="s2">if </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NilDoc):</span>
      <span class="s2">pass</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_TextDoc):</span>
      <span class="s1">color_state</span><span class="s2">, </span><span class="s1">color_str = _update_color(use_color</span><span class="s2">, </span><span class="s1">color_state</span><span class="s2">, </span><span class="s1">color)</span>
      <span class="s1">line_text += color_str</span>
      <span class="s1">line_text += doc.text</span>
      <span class="s2">if </span><span class="s1">doc.annotation </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">line_annotations.append(doc.annotation)</span>
      <span class="s1">k += len(doc.text)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ConcatDoc):</span>
      <span class="s1">agenda.extend(_State(i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">color)</span>
                    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">reversed(doc.children))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_BreakDoc):</span>
      <span class="s2">if </span><span class="s1">m == _BreakMode.BREAK:</span>
        <span class="s2">if </span><span class="s1">len(line_annotations) &gt; </span><span class="s4">0</span><span class="s1">:</span>
          <span class="s1">color_state</span><span class="s2">, </span><span class="s1">color_str = _update_color(use_color</span><span class="s2">, </span><span class="s1">color_state</span><span class="s2">,</span>
                                                 <span class="s1">annotation_colors)</span>
          <span class="s1">line_text += color_str</span>
        <span class="s1">lines.append(_Line(line_text</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">line_annotations))</span>
        <span class="s1">line_text = </span><span class="s3">&quot; &quot; </span><span class="s1">* i</span>
        <span class="s1">line_annotations = []</span>
        <span class="s1">k = i</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">color_state</span><span class="s2">, </span><span class="s1">color_str = _update_color(use_color</span><span class="s2">, </span><span class="s1">color_state</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s1">line_text += color_str</span>
        <span class="s1">line_text += doc.text</span>
        <span class="s1">k += len(doc.text)</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_NestDoc):</span>
      <span class="s1">agenda.append(_State(i + doc.n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc.child</span><span class="s2">, </span><span class="s1">color))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_GroupDoc):</span>
      <span class="s0"># In Lindig's paper, _fits is passed the remainder of the document.</span>
      <span class="s0"># I'm pretty sure that's a bug and we care only if the current group fits!</span>
      <span class="s2">if </span><span class="s1">(_sparse(doc)</span>
          <span class="s2">and </span><span class="s1">_fits(doc</span><span class="s2">, </span><span class="s1">width - k</span><span class="s2">, </span><span class="s1">[(i</span><span class="s2">, </span><span class="s1">_BreakMode.FLAT</span><span class="s2">, </span><span class="s1">doc.child)])):</span>
        <span class="s1">agenda.append(_State(i</span><span class="s2">, </span><span class="s1">_BreakMode.FLAT</span><span class="s2">, </span><span class="s1">doc.child</span><span class="s2">, </span><span class="s1">color))</span>
      <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">agenda.append(_State(i</span><span class="s2">, </span><span class="s1">_BreakMode.BREAK</span><span class="s2">, </span><span class="s1">doc.child</span><span class="s2">, </span><span class="s1">color))</span>
    <span class="s2">elif </span><span class="s1">isinstance(doc</span><span class="s2">, </span><span class="s1">_ColorDoc):</span>
      <span class="s1">color = _ColorState(doc.foreground </span><span class="s2">or </span><span class="s1">color.foreground</span><span class="s2">,</span>
                          <span class="s1">doc.background </span><span class="s2">or </span><span class="s1">color.background</span><span class="s2">,</span>
                          <span class="s1">doc.intensity </span><span class="s2">or </span><span class="s1">color.intensity)</span>
      <span class="s1">agenda.append(_State(i</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">doc.child</span><span class="s2">, </span><span class="s1">color))</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid document &quot;</span><span class="s2">, </span><span class="s1">doc)</span>

  <span class="s2">if </span><span class="s1">len(line_annotations) &gt; </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s1">color_state</span><span class="s2">, </span><span class="s1">color_str = _update_color(use_color</span><span class="s2">, </span><span class="s1">color_state</span><span class="s2">,</span>
                                           <span class="s1">annotation_colors)</span>
    <span class="s1">line_text += color_str</span>
  <span class="s1">lines.append(_Line(line_text</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">line_annotations))</span>
  <span class="s1">lines = _align_annotations(lines)</span>
  <span class="s1">out = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(</span>
    <span class="s1">l.text </span><span class="s2">if </span><span class="s1">l.annotations </span><span class="s2">is None</span>
    <span class="s2">else </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">l.text</span><span class="s2">}{</span><span class="s1">annotation_prefix</span><span class="s2">}{</span><span class="s1">l.annotations</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines)</span>
  <span class="s1">color_state</span><span class="s2">, </span><span class="s1">color_str = _update_color(use_color</span><span class="s2">, </span><span class="s1">color_state</span><span class="s2">,</span>
                                         <span class="s1">default_colors)</span>
  <span class="s2">return </span><span class="s1">out + color_str</span>




<span class="s0"># Public API.</span>

<span class="s2">def </span><span class="s1">nil() -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;An empty document.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_nil</span>

<span class="s2">def </span><span class="s1">text(s: str</span><span class="s2">, </span><span class="s1">annotation: Optional[str] = </span><span class="s2">None</span><span class="s1">) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;Literal text.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_TextDoc(s</span><span class="s2">, </span><span class="s1">annotation)</span>

<span class="s2">def </span><span class="s1">concat(docs: Sequence[Doc]) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;Concatenation of documents.&quot;&quot;&quot;</span>
  <span class="s1">docs = list(docs)</span>
  <span class="s2">if </span><span class="s1">len(docs) == </span><span class="s4">1</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">docs[</span><span class="s4">0</span><span class="s1">]</span>
  <span class="s2">return </span><span class="s1">_ConcatDoc(docs)</span>

<span class="s2">def </span><span class="s1">brk(text: str = </span><span class="s3">&quot; &quot;</span><span class="s1">) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;A break. 
 
  Prints either as a newline or as `text`, depending on the enclosing group. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_BreakDoc(text)</span>

<span class="s2">def </span><span class="s1">group(doc: Doc) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;Layout alternative groups. 
 
  Prints the group with its breaks as their text (typically spaces) if the 
  entire group would fit on the line when printed that way. Otherwise, breaks 
  inside the group as printed as newlines. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_GroupDoc(doc)</span>

<span class="s2">def </span><span class="s1">nest(n: int</span><span class="s2">, </span><span class="s1">doc: Doc) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;Increases the indentation level by `n`.&quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_NestDoc(n</span><span class="s2">, </span><span class="s1">doc)</span>


<span class="s2">def </span><span class="s1">color(doc: Doc</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">foreground: Optional[Color] = </span><span class="s2">None,</span>
          <span class="s1">background: Optional[Color] = </span><span class="s2">None,</span>
          <span class="s1">intensity: Optional[Intensity] = </span><span class="s2">None</span><span class="s1">):</span>
  <span class="s5">&quot;&quot;&quot;ANSI colors. 
 
  Overrides the foreground/background/intensity of the text for the child doc. 
  Requires use_colors=True to be set when printing and the `colorama` package 
  to be installed; otherwise does nothing. 
  &quot;&quot;&quot;</span>
  <span class="s2">return </span><span class="s1">_ColorDoc(doc</span><span class="s2">, </span><span class="s1">foreground=foreground</span><span class="s2">, </span><span class="s1">background=background</span><span class="s2">,</span>
                   <span class="s1">intensity=intensity)</span>


<span class="s1">type_annotation = partial(color</span><span class="s2">, </span><span class="s1">intensity=Intensity.NORMAL</span><span class="s2">,</span>
                          <span class="s1">foreground=Color.MAGENTA)</span>
<span class="s1">keyword = partial(color</span><span class="s2">, </span><span class="s1">intensity=Intensity.BRIGHT</span><span class="s2">, </span><span class="s1">foreground=Color.BLUE)</span>


<span class="s2">def </span><span class="s1">join(sep: Doc</span><span class="s2">, </span><span class="s1">docs: Sequence[Doc]) -&gt; Doc:</span>
  <span class="s5">&quot;&quot;&quot;Concatenates `docs`, separated by `sep`.&quot;&quot;&quot;</span>
  <span class="s1">docs = list(docs)</span>
  <span class="s2">if </span><span class="s1">len(docs) == </span><span class="s4">0</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">nil()</span>
  <span class="s1">xs = [docs[</span><span class="s4">0</span><span class="s1">]]</span>
  <span class="s2">for </span><span class="s1">doc </span><span class="s2">in </span><span class="s1">docs[</span><span class="s4">1</span><span class="s1">:]:</span>
    <span class="s1">xs.append(sep)</span>
    <span class="s1">xs.append(doc)</span>
  <span class="s2">return </span><span class="s1">concat(xs)</span>
</pre>
</body>
</html>