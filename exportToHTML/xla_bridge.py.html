<html>
<head>
<title>xla_bridge.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
xla_bridge.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">&quot;&quot;&quot;Interface and utility functions to XLA. 
 
This module wraps the XLA client(s) and builders to standardize their interfaces 
and provide some automatic type mapping logic for converting between Numpy and 
XLA. There are also a handful of related casting utilities. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span><span class="s3">, </span><span class="s1">lru_cache</span>
<span class="s3">import </span><span class="s1">io</span>
<span class="s3">import </span><span class="s1">json</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">platform </span><span class="s3">as </span><span class="s1">py_platform</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">lib</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">distributed</span>
<span class="s3">from </span><span class="s1">jax._src.config </span><span class="s3">import </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">bool_env</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">int_env</span>
<span class="s3">from </span><span class="s1">jax._src.lib </span><span class="s3">import </span><span class="s1">xla_client</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">traceback_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">util</span>

<span class="s1">iree: Optional[Any]</span>

<span class="s3">try</span><span class="s1">:</span>
  <span class="s3">import </span><span class="s1">jax._src.iree </span><span class="s3">as </span><span class="s1">iree  </span><span class="s0"># type: ignore</span>
<span class="s3">except </span><span class="s1">(ModuleNotFoundError</span><span class="s3">, </span><span class="s1">ImportError):</span>
  <span class="s1">iree = </span><span class="s3">None</span>

<span class="s1">traceback_util.register_exclusion(__file__)</span>


<span class="s1">XlaBackend = xla_client.Client</span>

<span class="s1">FLAGS = flags.FLAGS</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s0"># TODO(phawkins): Remove jax_xla_backend.</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'jax_xla_backend'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">,</span>
    <span class="s4">'Deprecated, please use --jax_platforms instead.'</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'jax_backend_target'</span><span class="s3">,</span>
    <span class="s1">os.getenv(</span><span class="s4">'JAX_BACKEND_TARGET'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower()</span><span class="s3">,</span>
    <span class="s4">'Either &quot;local&quot; or &quot;rpc:address&quot; to connect to a remote service target.'</span><span class="s1">)</span>
<span class="s0"># TODO(skye): warn when this is used once we test out --jax_platforms a bit</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'jax_platform_name'</span><span class="s3">,</span>
    <span class="s1">os.getenv(</span><span class="s4">'JAX_PLATFORM_NAME'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower()</span><span class="s3">,</span>
    <span class="s4">'Deprecated, please use --jax_platforms instead.'</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_bool(</span>
    <span class="s4">'jax_disable_most_optimizations'</span><span class="s3">,</span>
    <span class="s1">bool_env(</span><span class="s4">'JAX_DISABLE_MOST_OPTIMIZATIONS'</span><span class="s3">, False</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'Try not to do much optimization work. This can be useful if the cost of '</span>
    <span class="s4">'optimization is greater than that of running a less-optimized program.'</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_integer(</span>
    <span class="s4">'jax_xla_profile_version'</span><span class="s3">, </span><span class="s1">int_env(</span><span class="s4">'JAX_XLA_PROFILE_VERSION'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s4">'Optional profile version for XLA compilation. '</span>
    <span class="s4">'This is meaningful only when XLA is configured to '</span>
    <span class="s4">'support the remote compilation profile feature.'</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'jax_cuda_visible_devices'</span><span class="s3">, </span><span class="s4">'all'</span><span class="s3">,</span>
    <span class="s4">'Restricts the set of CUDA devices that JAX will use. Either &quot;all&quot;, or a '</span>
    <span class="s4">'comma-separate list of integer device IDs.'</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'jax_rocm_visible_devices'</span><span class="s3">, </span><span class="s4">'all'</span><span class="s3">,</span>
    <span class="s4">'Restricts the set of ROCM devices that JAX will use. Either &quot;all&quot;, or a '</span>
    <span class="s4">'comma-separate list of integer device IDs.'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">get_compile_options(</span>
    <span class="s1">num_replicas: int</span><span class="s3">,</span>
    <span class="s1">num_partitions: int</span><span class="s3">,</span>
    <span class="s1">device_assignment=</span><span class="s3">None,</span>
    <span class="s1">use_spmd_partitioning: bool = </span><span class="s3">True,</span>
    <span class="s1">use_auto_spmd_partitioning: bool = </span><span class="s3">False,</span>
    <span class="s1">auto_spmd_partitioning_mesh_shape=[]</span><span class="s3">,</span>
    <span class="s1">auto_spmd_partitioning_mesh_ids=[]) -&gt; xla_client.CompileOptions:</span>
  <span class="s2">&quot;&quot;&quot;Returns the compile options to use, as derived from flag values. 
 
  Args: 
    num_replicas: Number of replicas for which to compile. 
    num_partitions: Number of partitions for which to compile. 
    device_assignment: Optional ndarray of jax devices indicating the assignment 
      of logical replicas to physical devices (default inherited from 
      xla_client.CompileOptions). Must be consistent with `num_replicas` and 
      `num_partitions`. 
    use_spmd_partitioning: boolean indicating whether to enable SPMD or MPMD 
      partitioning in XLA. 
    use_auto_spmd_partitioning: boolean indicating whether to automatically 
      generate XLA shardings for SPMD partitioner. 
    auto_spmd_partitioning_mesh_shape: device mesh shape used to create 
      auto_spmd_partitioning search space. 
    auto_spmd_partitioning_mesh_ids: device ids used to create 
      auto_spmd_partitioning search space. 
  &quot;&quot;&quot;</span>
  <span class="s1">compile_options = xla_client.CompileOptions()</span>
  <span class="s1">compile_options.num_replicas = num_replicas</span>
  <span class="s1">compile_options.num_partitions = num_partitions</span>
  <span class="s1">build_options = compile_options.executable_build_options</span>
  <span class="s1">build_options.use_spmd_partitioning = use_spmd_partitioning</span>
  <span class="s1">build_options.use_auto_spmd_partitioning = use_auto_spmd_partitioning</span>
  <span class="s3">if </span><span class="s1">use_auto_spmd_partitioning:</span>
    <span class="s1">build_options.auto_spmd_partitioning_mesh_shape = auto_spmd_partitioning_mesh_shape</span>
    <span class="s1">build_options.auto_spmd_partitioning_mesh_ids = auto_spmd_partitioning_mesh_ids</span>
  <span class="s3">if </span><span class="s1">device_assignment </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">logger.debug(</span>
        <span class="s4">'get_compile_options: num_replicas=%s num_partitions=%s device_assignment=%s'</span><span class="s3">,</span>
        <span class="s1">num_replicas</span><span class="s3">, </span><span class="s1">num_partitions</span><span class="s3">, </span><span class="s1">device_assignment)</span>
    <span class="s1">device_assignment = np.array(device_assignment)</span>

    <span class="s0"># Allow 1D device assignment if num_partitions is 1.</span>
    <span class="s3">if </span><span class="s1">(device_assignment.ndim == </span><span class="s5">1</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(num_partitions == </span><span class="s5">1</span><span class="s1">):</span>
      <span class="s1">device_assignment = device_assignment[:</span><span class="s3">, None</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">num_replicas != device_assignment.shape[</span><span class="s5">0</span><span class="s1">]:</span>
      <span class="s1">msg = </span><span class="s4">'device_assignment does not match num_replicas: {} vs {}.'</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(device_assignment</span><span class="s3">, </span><span class="s1">num_replicas))</span>

    <span class="s3">if </span><span class="s1">num_partitions != device_assignment.shape[</span><span class="s5">1</span><span class="s1">]:</span>
      <span class="s1">msg = </span><span class="s4">'device_assignment does not match num_partitions: {} vs {}.'</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(device_assignment</span><span class="s3">, </span><span class="s1">num_partitions))</span>

    <span class="s3">if </span><span class="s1">device_assignment.dtype == object:</span>
      <span class="s1">device_assignment = np.vectorize(</span><span class="s3">lambda </span><span class="s1">d: d.id</span><span class="s3">, </span><span class="s1">otypes=[int])(</span>
          <span class="s1">device_assignment)</span>
    <span class="s1">device_assignment = xla_client.DeviceAssignment.create(device_assignment)</span>
    <span class="s3">assert </span><span class="s1">device_assignment.replica_count() == num_replicas</span>
    <span class="s3">assert </span><span class="s1">device_assignment.computation_count() == num_partitions</span>
    <span class="s1">compile_options.device_assignment = device_assignment</span>

  <span class="s1">debug_options = compile_options.executable_build_options.debug_options</span>
  <span class="s3">if </span><span class="s1">lib.cuda_path </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">debug_options.xla_gpu_cuda_data_dir = lib.cuda_path</span>

  <span class="s3">if </span><span class="s1">FLAGS.jax_disable_most_optimizations:</span>

    <span class="s1">debug_options.xla_backend_optimization_level = </span><span class="s5">0</span>
    <span class="s1">debug_options.xla_llvm_disable_expensive_passes = </span><span class="s3">True</span>
    <span class="s1">debug_options.xla_test_all_input_layouts = </span><span class="s3">False</span>

  <span class="s1">compile_options.profile_version = FLAGS.jax_xla_profile_version</span>
  <span class="s3">return </span><span class="s1">compile_options</span>


<span class="s0"># Backends</span>

<span class="s3">def </span><span class="s1">tpu_client_timer_callback(timer_secs: float) -&gt; Optional[xla_client.Client]:</span>
  <span class="s3">def </span><span class="s1">_log_warning():</span>
    <span class="s1">warnings.warn(</span>
      <span class="s4">f'TPU backend initialization is taking more than </span><span class="s3">{</span><span class="s1">timer_secs</span><span class="s3">} </span><span class="s4">seconds. '</span>
      <span class="s4">'Did you run your code on all TPU hosts? '</span>
      <span class="s4">'See https://jax.readthedocs.io/en/latest/multi_process.html '</span>
      <span class="s4">'for more information.'</span><span class="s1">)</span>

  <span class="s0"># Will log a warning after `timer_secs`.</span>
  <span class="s1">t = threading.Timer(timer_secs</span><span class="s3">, </span><span class="s1">_log_warning)</span>
  <span class="s1">t.start()</span>

  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">client = xla_client.make_tpu_client()</span>
  <span class="s3">finally</span><span class="s1">:</span>
    <span class="s1">t.cancel()</span>

  <span class="s3">return </span><span class="s1">client</span>


<span class="s0"># Backends, in increasing order of preference.</span>
<span class="s0"># We have no particular opinion about how &quot;backends&quot; relate to &quot;devices&quot;. For</span>
<span class="s0"># example, there could be multiple backends that provide the same kind of</span>
<span class="s0"># device.</span>
<span class="s1">BackendFactory = Callable[[]</span><span class="s3">, </span><span class="s1">Optional[xla_client.Client]]</span>
<span class="s1">_backend_factories: Dict[str</span><span class="s3">, </span><span class="s1">Tuple[BackendFactory</span><span class="s3">, </span><span class="s1">int]] = {}</span>
<span class="s1">_default_backend: Optional[xla_client.Client] = </span><span class="s3">None</span>
<span class="s1">_backends : Dict[str</span><span class="s3">, </span><span class="s1">xla_client.Client] = {}</span>
<span class="s1">_backends_errors : Dict[str</span><span class="s3">, </span><span class="s1">str] = {}</span>
<span class="s1">_backend_lock = threading.Lock()</span>

<span class="s3">def </span><span class="s1">register_backend_factory(name: str</span><span class="s3">, </span><span class="s1">factory: BackendFactory</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
                             <span class="s1">priority: int = </span><span class="s5">0</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
  <span class="s3">with </span><span class="s1">_backend_lock:</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">_backends:</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Backend </span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s4">already initialized&quot;</span><span class="s1">)</span>
  <span class="s1">_backend_factories[name] = (factory</span><span class="s3">, </span><span class="s1">priority)</span>


<span class="s1">register_backend_factory(</span><span class="s4">'interpreter'</span><span class="s3">, </span><span class="s1">xla_client.make_interpreter_client</span><span class="s3">,</span>
                         <span class="s1">priority=-</span><span class="s5">100</span><span class="s1">)</span>
<span class="s1">register_backend_factory(</span><span class="s4">'cpu'</span><span class="s3">,</span>
                         <span class="s1">partial(xla_client.make_cpu_client</span><span class="s3">, </span><span class="s1">use_tfrt=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">priority=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">make_gpu_client(</span>
    <span class="s1">*</span><span class="s3">, </span><span class="s1">platform_name: str</span><span class="s3">, </span><span class="s1">visible_devices_flag: str</span>
<span class="s1">) -&gt; xla_client.Client:</span>
  <span class="s1">visible_devices = getattr(FLAGS</span><span class="s3">, </span><span class="s1">visible_devices_flag</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s1">)</span>
  <span class="s1">allowed_devices = </span><span class="s3">None</span>
  <span class="s3">if </span><span class="s1">visible_devices != </span><span class="s4">&quot;all&quot;</span><span class="s1">:</span>
    <span class="s1">allowed_devices = {int(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">visible_devices.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)}</span>
  <span class="s3">return </span><span class="s1">xla_client.make_gpu_client(</span>
    <span class="s1">distributed_client=distributed.global_state.client</span><span class="s3">,</span>
    <span class="s1">node_id=distributed.global_state.process_id</span><span class="s3">,</span>
    <span class="s1">platform_name=platform_name</span><span class="s3">,</span>
    <span class="s1">allowed_devices=allowed_devices)</span>


<span class="s3">if </span><span class="s1">hasattr(xla_client</span><span class="s3">, </span><span class="s4">&quot;make_gpu_client&quot;</span><span class="s1">):</span>
  <span class="s1">register_backend_factory(</span>
      <span class="s4">'cuda'</span><span class="s3">, </span><span class="s1">partial(make_gpu_client</span><span class="s3">, </span><span class="s1">platform_name=</span><span class="s4">'cuda'</span><span class="s3">,</span>
      <span class="s1">visible_devices_flag=</span><span class="s4">'jax_cuda_visible_devices'</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">priority=</span><span class="s5">200</span><span class="s1">)</span>
  <span class="s1">register_backend_factory(</span>
      <span class="s4">'rocm'</span><span class="s3">, </span><span class="s1">partial(make_gpu_client</span><span class="s3">, </span><span class="s1">platform_name=</span><span class="s4">'rocm'</span><span class="s3">,</span>
      <span class="s1">visible_devices_flag=</span><span class="s4">'jax_rocm_visible_devices'</span><span class="s1">)</span><span class="s3">,</span>
      <span class="s1">priority=</span><span class="s5">200</span><span class="s1">)</span>


<span class="s3">if </span><span class="s1">hasattr(xla_client</span><span class="s3">, </span><span class="s4">&quot;make_tpu_client&quot;</span><span class="s1">):</span>
  <span class="s1">register_backend_factory(</span>
    <span class="s4">'tpu'</span><span class="s3">, </span><span class="s1">partial(tpu_client_timer_callback</span><span class="s3">, </span><span class="s1">timer_secs=</span><span class="s5">60.0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">priority=</span><span class="s5">300</span><span class="s1">)</span>

<span class="s3">if </span><span class="s1">hasattr(xla_client</span><span class="s3">, </span><span class="s4">&quot;make_plugin_device_client&quot;</span><span class="s1">):</span>
  <span class="s0"># It is assumed that if jax has been built with a plugin client, then the</span>
  <span class="s0"># user wants to use the plugin client by default. Therefore, it gets the</span>
  <span class="s0"># highest priority.</span>
  <span class="s1">register_backend_factory(</span><span class="s4">&quot;plugin&quot;</span><span class="s3">, </span><span class="s1">xla_client.make_plugin_device_client</span><span class="s3">,</span>
      <span class="s1">priority=</span><span class="s5">400</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_get_pjrt_plugin_names_and_library_paths(</span>
    <span class="s1">plugins_from_env: str</span><span class="s3">,</span>
<span class="s1">) -&gt; Dict[str</span><span class="s3">, </span><span class="s1">str]:</span>
  <span class="s2">&quot;&quot;&quot;Gets the names and library paths of PJRT plugins to load from env var. 
 
  Args: 
    plugins_from_env: plugin name and pathes from env var. It is in the format 
      of 'name1:path1,name2:path2' ('name1;path1,name2;path2' for windows). 
 
  Returns: 
    A dict of {plugin_name: library path} for the PJRT plugins to load. 
  &quot;&quot;&quot;</span>
  <span class="s3">if not </span><span class="s1">plugins_from_env:</span>
    <span class="s3">return </span><span class="s1">{}</span>

  <span class="s1">pjrt_plugins = {}</span>
  <span class="s3">for </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">plugins_from_env.split(</span><span class="s4">','</span><span class="s1">):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">name</span><span class="s3">, </span><span class="s1">library_path = plugin.split(os.path.pathsep)</span>
      <span class="s1">pjrt_plugins[name] = library_path</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
      <span class="s1">logger.warning(</span>
          <span class="s4">'invalid value %s in env var PJRT_NAMES_AND_LIBRARY_PATHS %s'</span><span class="s3">,</span>
          <span class="s1">plugin</span><span class="s3">,</span>
          <span class="s1">plugins_from_env</span><span class="s3">,</span>
      <span class="s1">)</span>
  <span class="s3">return </span><span class="s1">pjrt_plugins</span>


<span class="s3">def </span><span class="s1">_get_pjrt_plugin_config(</span>
    <span class="s1">json_path: str</span><span class="s3">,</span>
<span class="s1">) -&gt; Tuple[str</span><span class="s3">, </span><span class="s1">Optional[Mapping[str</span><span class="s3">, </span><span class="s1">Union[str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">List[int]</span><span class="s3">, </span><span class="s1">float]]]]:</span>
  <span class="s2">&quot;&quot;&quot;Gets PJRT plugin configuration from a json file. 
 
  The json file needs to have a &quot;library_path&quot; field for the plugin library 
  path. It can have an optional &quot;create_option&quot; field for the options used when 
  creating a PJRT plugin client. The value of &quot;create_option&quot; is key-value 
  pairs. Please see xla_client._NameValueMapping for the supported types of 
  values. 
  &quot;&quot;&quot;</span>
  <span class="s3">with </span><span class="s1">io.open(json_path</span><span class="s3">, </span><span class="s4">'r'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
    <span class="s1">config = json.load(f)</span>
  <span class="s3">if </span><span class="s4">'library_path' </span><span class="s3">not in </span><span class="s1">config.keys():</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span>
        <span class="s4">'PJRT plugin config file should contain &quot;library_path&quot; field.'</span>
    <span class="s1">)</span>
  <span class="s3">return </span><span class="s1">(config[</span><span class="s4">'library_path'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">config.get(</span><span class="s4">'create_options'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">register_pjrt_plugin_factories(plugins_from_env: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
  <span class="s2">&quot;&quot;&quot;Registers backend factories for PJRT plugins. 
 
  A backend factory will be registered for every PJRT plugin in the input 
  string, in the format of 'name1:path1,name2:path2' ('name1;path1,name2;path2' 
  for windows). The path can be a path to the plugin library or a path to the 
  plugin configuration json file. The json file needs to have a &quot;library_path&quot; 
  field for the plugin library path. It can have an optional &quot;create_option&quot; 
  field for the options used when creating a PJRT plugin client. The value of 
  &quot;create_option&quot; is key-value pairs. Please see xla_client._NameValueMapping 
  for the supported types of values. 
 
  TPU PJRT plugin will be loaded and registered separately in make_tpu_client. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">make_factory(name: str</span><span class="s3">, </span><span class="s1">path: str):</span>
    <span class="s3">def </span><span class="s1">factory():</span>
      <span class="s3">if </span><span class="s1">path.endswith(</span><span class="s4">'.json'</span><span class="s1">):</span>
        <span class="s1">library_path</span><span class="s3">, </span><span class="s1">options = _get_pjrt_plugin_config(path)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">library_path = path</span>
        <span class="s1">options = </span><span class="s3">None</span>

      <span class="s1">xla_client.load_pjrt_plugin_dynamically(name</span><span class="s3">, </span><span class="s1">library_path)</span>
      <span class="s3">return </span><span class="s1">xla_client.make_c_api_client(name</span><span class="s3">, </span><span class="s1">options)</span>

    <span class="s3">return </span><span class="s1">factory</span>

  <span class="s1">pjrt_plugins = _get_pjrt_plugin_names_and_library_paths(plugins_from_env)</span>
  <span class="s3">for </span><span class="s1">plugin_name</span><span class="s3">, </span><span class="s1">library_path </span><span class="s3">in </span><span class="s1">pjrt_plugins.items():</span>
    <span class="s1">logger.debug(</span>
        <span class="s4">'registering PJRT plugin %s from %s'</span><span class="s3">, </span><span class="s1">plugin_name</span><span class="s3">, </span><span class="s1">library_path</span>
    <span class="s1">)</span>
    <span class="s0"># It is assumed that if a plugin is installed, then the user wants to use</span>
    <span class="s0"># the plugin by default. Therefore, plugins get the highest priority.</span>
    <span class="s0"># For a PJRT plugin, its plugin_name is the same as its platform_name.</span>
    <span class="s1">register_backend_factory(</span>
        <span class="s1">plugin_name</span><span class="s3">, </span><span class="s1">make_factory(plugin_name</span><span class="s3">, </span><span class="s1">library_path)</span><span class="s3">, </span><span class="s1">priority=</span><span class="s5">400</span>
    <span class="s1">)</span>


<span class="s0"># The plugin names and paths are set in env var PJRT_NAMES_AND_LIBRARY_PATHS,</span>
<span class="s0"># in the format of 'name1:path1,name2:path2' ('name1;path1,name2;path2' for</span>
<span class="s0"># windows).</span>
<span class="s1">register_pjrt_plugin_factories(os.getenv(</span><span class="s4">'PJRT_NAMES_AND_LIBRARY_PATHS'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">))</span>

<span class="s3">if </span><span class="s1">iree </span><span class="s3">is not None</span><span class="s1">:</span>
  <span class="s1">register_backend_factory(</span><span class="s4">&quot;iree&quot;</span><span class="s3">, </span><span class="s1">iree.iree_client_factory</span><span class="s3">, </span><span class="s1">priority=-</span><span class="s5">100</span><span class="s1">)</span>

<span class="s1">_platform_aliases = {</span>
  <span class="s4">&quot;cuda&quot;</span><span class="s1">: </span><span class="s4">&quot;gpu&quot;</span><span class="s3">,</span>
  <span class="s4">&quot;rocm&quot;</span><span class="s1">: </span><span class="s4">&quot;gpu&quot;</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">_alias_to_platforms: Dict[str</span><span class="s3">, </span><span class="s1">List[str]] = {}</span>
<span class="s3">for </span><span class="s1">_platform</span><span class="s3">, </span><span class="s1">_alias </span><span class="s3">in </span><span class="s1">_platform_aliases.items():</span>
  <span class="s1">_alias_to_platforms.setdefault(_alias</span><span class="s3">, </span><span class="s1">[]).append(_platform)</span>


<span class="s3">def </span><span class="s1">is_known_platform(platform: str) -&gt; bool:</span>
  <span class="s0"># A platform is valid if there is a registered factory for it. It does not</span>
  <span class="s0"># matter if we were unable to initialize that platform; we only care that</span>
  <span class="s0"># we've heard of it and it isn't, e.g., a typo.</span>
  <span class="s3">return </span><span class="s1">(platform </span><span class="s3">in </span><span class="s1">_backend_factories.keys() </span><span class="s3">or</span>
          <span class="s1">platform </span><span class="s3">in </span><span class="s1">_platform_aliases.keys())</span>


<span class="s3">def </span><span class="s1">canonicalize_platform(platform: str) -&gt; str:</span>
  <span class="s2">&quot;&quot;&quot;Replaces platform aliases with their concrete equivalent. 
 
  In particular, replaces &quot;gpu&quot; with either &quot;cuda&quot; or &quot;rocm&quot;, depending on which 
  hardware is actually present. We want to distinguish &quot;cuda&quot; and &quot;rocm&quot; for 
  purposes such as MLIR lowering rules, but in many cases we don't want to 
  force users to care. 
  &quot;&quot;&quot;</span>
  <span class="s1">platforms = _alias_to_platforms.get(platform</span><span class="s3">, None</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">platforms </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">platform</span>

  <span class="s1">b = backends()</span>
  <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">platforms:</span>
    <span class="s3">if </span><span class="s1">p </span><span class="s3">in </span><span class="s1">b.keys():</span>
      <span class="s3">return </span><span class="s1">p</span>
  <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Unknown backend: '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">' requested, but no &quot;</span>
                     <span class="s4">f&quot;platforms that are instances of </span><span class="s3">{</span><span class="s1">platform</span><span class="s3">} </span><span class="s4">are present. &quot;</span>
                     <span class="s4">&quot;Platforms present are: &quot; </span><span class="s1">+ </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(b.keys()))</span>


<span class="s3">def </span><span class="s1">expand_platform_alias(platform: str) -&gt; List[str]:</span>
  <span class="s2">&quot;&quot;&quot;Expands, e.g., &quot;gpu&quot; to [&quot;cuda&quot;, &quot;rocm&quot;]. 
 
  This is used for convenience reasons: we expect cuda and rocm to act similarly 
  in many respects since they share most of the same code. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">_alias_to_platforms.get(platform</span><span class="s3">, </span><span class="s1">[platform])</span>

<span class="s3">def </span><span class="s1">is_gpu(platform):</span>
  <span class="s3">return </span><span class="s1">platform </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;cuda&quot;</span><span class="s3">, </span><span class="s4">&quot;rocm&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">backends() -&gt; Dict[str</span><span class="s3">, </span><span class="s1">xla_client.Client]:</span>
  <span class="s3">global </span><span class="s1">_backends</span>
  <span class="s3">global </span><span class="s1">_backends_errors</span>
  <span class="s3">global </span><span class="s1">_default_backend</span>

  <span class="s3">with </span><span class="s1">_backend_lock:</span>
    <span class="s3">if </span><span class="s1">_backends:</span>
      <span class="s3">return </span><span class="s1">_backends</span>
    <span class="s3">if </span><span class="s1">config.jax_platforms:</span>
      <span class="s1">jax_platforms = config.jax_platforms.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>
      <span class="s1">platforms = []</span>
      <span class="s0"># Allow platform aliases in the list of platforms.</span>
      <span class="s3">for </span><span class="s1">platform </span><span class="s3">in </span><span class="s1">jax_platforms:</span>
        <span class="s1">platforms.extend(expand_platform_alias(platform))</span>
      <span class="s1">priorities = range(len(platforms)</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
      <span class="s1">platforms_and_priorities = list(zip(platforms</span><span class="s3">, </span><span class="s1">priorities))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">platforms_and_priorities = list(</span>
          <span class="s1">(platform</span><span class="s3">, </span><span class="s1">priority) </span><span class="s3">for </span><span class="s1">platform</span><span class="s3">, </span><span class="s1">(_</span><span class="s3">, </span><span class="s1">priority)</span>
          <span class="s3">in </span><span class="s1">_backend_factories.items())</span>
    <span class="s1">default_priority = -</span><span class="s5">1000</span>
    <span class="s3">for </span><span class="s1">platform</span><span class="s3">, </span><span class="s1">priority </span><span class="s3">in </span><span class="s1">platforms_and_priorities:</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">backend = _init_backend(platform)</span>
        <span class="s1">_backends[platform] = backend</span>

        <span class="s3">if </span><span class="s1">priority &gt; default_priority:</span>
          <span class="s1">_default_backend = backend</span>
          <span class="s1">default_priority = priority</span>
      <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">err:</span>
        <span class="s3">if </span><span class="s1">platform </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'cpu'</span><span class="s3">, </span><span class="s4">'interpreter'</span><span class="s1">):</span>
          <span class="s0"># We always expect the CPU and interpreter backends to initialize</span>
          <span class="s0"># successfully.</span>
          <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s0"># If the backend isn't built into the binary, or if it has no devices,</span>
          <span class="s0"># we expect a RuntimeError.</span>
          <span class="s1">err_msg = </span><span class="s4">f&quot;Unable to initialize backend '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">': </span><span class="s3">{</span><span class="s1">err</span><span class="s3">}</span><span class="s4">&quot;</span>
          <span class="s3">if </span><span class="s1">config.jax_platforms:</span>
            <span class="s1">err_msg += </span><span class="s4">&quot; (set JAX_PLATFORMS='' to automatically choose an available backend)&quot;</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(err_msg)</span>
          <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_backends_errors[platform] = str(err)</span>
            <span class="s1">logger.info(err_msg)</span>
            <span class="s3">continue</span>
    <span class="s3">assert </span><span class="s1">_default_backend </span><span class="s3">is not None</span>
    <span class="s0"># We don't warn about falling back to CPU on Mac OS, because we don't</span>
    <span class="s0"># support anything else there at the moment and warning would be pointless.</span>
    <span class="s3">if </span><span class="s1">(py_platform.system() != </span><span class="s4">&quot;Darwin&quot; </span><span class="s3">and</span>
        <span class="s1">_default_backend.platform == </span><span class="s4">&quot;cpu&quot; </span><span class="s3">and</span>
        <span class="s1">FLAGS.jax_platform_name != </span><span class="s4">'cpu'</span><span class="s1">):</span>
      <span class="s1">logger.warning(</span><span class="s4">'No GPU/TPU found, falling back to CPU. '</span>
                      <span class="s4">'(Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_backends</span>


<span class="s3">def </span><span class="s1">_clear_backends() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
  <span class="s3">global </span><span class="s1">_backends</span>
  <span class="s3">global </span><span class="s1">_backends_errors</span>
  <span class="s3">global </span><span class="s1">_default_backend</span>

  <span class="s1">logger.info(</span><span class="s4">&quot;Clearing JAX backend caches.&quot;</span><span class="s1">)</span>
  <span class="s3">with </span><span class="s1">_backend_lock:</span>
    <span class="s1">_backends = {}</span>
    <span class="s1">_backends_errors = {}</span>
    <span class="s1">_default_backend = </span><span class="s3">None</span>

  <span class="s1">get_backend.cache_clear()</span>


<span class="s3">def </span><span class="s1">_init_backend(platform: str) -&gt; xla_client.Client:</span>
  <span class="s1">factory</span><span class="s3">, </span><span class="s1">unused_priority = _backend_factories.get(platform</span><span class="s3">, </span><span class="s1">(</span><span class="s3">None, None</span><span class="s1">))</span>
  <span class="s3">if </span><span class="s1">factory </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Unknown backend '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">'&quot;</span><span class="s1">)</span>

  <span class="s1">logger.debug(</span><span class="s4">&quot;Initializing backend '%s'&quot;</span><span class="s3">, </span><span class="s1">platform)</span>
  <span class="s1">backend = factory()</span>
  <span class="s0"># TODO(skye): consider raising more descriptive errors directly from backend</span>
  <span class="s0"># factories instead of returning None.</span>
  <span class="s3">if </span><span class="s1">backend </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Could not initialize backend '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">'&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">backend.device_count() == </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Backend '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">' provides no devices.&quot;</span><span class="s1">)</span>
  <span class="s1">util.distributed_debug_log((</span><span class="s4">&quot;Initialized backend&quot;</span><span class="s3">, </span><span class="s1">backend.platform)</span><span class="s3">,</span>
                             <span class="s1">(</span><span class="s4">&quot;process_index&quot;</span><span class="s3">, </span><span class="s1">backend.process_index())</span><span class="s3">,</span>
                             <span class="s1">(</span><span class="s4">&quot;device_count&quot;</span><span class="s3">, </span><span class="s1">backend.device_count())</span><span class="s3">,</span>
                             <span class="s1">(</span><span class="s4">&quot;local_devices&quot;</span><span class="s3">, </span><span class="s1">backend.local_devices()))</span>
  <span class="s1">logger.debug(</span><span class="s4">&quot;Backend '%s' initialized&quot;</span><span class="s3">, </span><span class="s1">platform)</span>
  <span class="s3">return </span><span class="s1">backend</span>


<span class="s3">def </span><span class="s1">_get_backend_uncached(</span>
    <span class="s1">platform: Union[</span><span class="s3">None, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">xla_client.Client] = </span><span class="s3">None</span>
<span class="s1">) -&gt; xla_client.Client:</span>
  <span class="s0"># TODO(mattjj,skyewm): remove this input polymorphism after we clean up how</span>
  <span class="s0"># 'backend' values are handled</span>
  <span class="s3">if </span><span class="s1">platform </span><span class="s3">is not None and not </span><span class="s1">isinstance(platform</span><span class="s3">, </span><span class="s1">str):</span>
    <span class="s3">return </span><span class="s1">platform</span>

  <span class="s1">platform = (platform </span><span class="s3">or </span><span class="s1">FLAGS.jax_xla_backend </span><span class="s3">or </span><span class="s1">FLAGS.jax_platform_name</span>
              <span class="s3">or None</span><span class="s1">)</span>

  <span class="s1">bs = backends()</span>
  <span class="s3">if </span><span class="s1">platform </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">platform = canonicalize_platform(platform)</span>
    <span class="s1">backend = bs.get(platform</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">backend </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">platform </span><span class="s3">in </span><span class="s1">_backends_errors:</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Backend '</span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">' failed to initialize: &quot;</span>
                           <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">_backends_errors[platform]</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Unknown backend </span><span class="s3">{</span><span class="s1">platform</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">backend</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">assert </span><span class="s1">_default_backend </span><span class="s3">is not None</span>
    <span class="s3">return </span><span class="s1">_default_backend</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s3">None</span><span class="s1">)  </span><span class="s0"># don't use util.memoize because there is no X64 dependence.</span>
<span class="s3">def </span><span class="s1">get_backend(</span>
    <span class="s1">platform: Union[</span><span class="s3">None, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">xla_client.Client] = </span><span class="s3">None</span>
<span class="s1">) -&gt; xla_client.Client:</span>
  <span class="s3">return </span><span class="s1">_get_backend_uncached(platform)</span>


<span class="s3">def </span><span class="s1">get_device_backend(</span>
    <span class="s1">device: Optional[xla_client.Device] = </span><span class="s3">None,</span>
<span class="s1">) -&gt; xla_client.Client:</span>
  <span class="s2">&quot;&quot;&quot;Returns the Backend associated with `device`, or the default Backend.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">device </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">device.client</span>
  <span class="s3">return </span><span class="s1">get_backend()</span>


<span class="s3">def </span><span class="s1">device_count(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; int:</span>
  <span class="s2">&quot;&quot;&quot;Returns the total number of devices. 
 
  On most platforms, this is the same as :py:func:`jax.local_device_count`. 
  However, on multi-process platforms where different devices are associated 
  with different processes, this will return the total number of devices across 
  all processes. 
 
  Args: 
    backend: This is an experimental feature and the API is likely to change. 
      Optional, a string representing the xla backend: ``'cpu'``, ``'gpu'``, or 
      ``'tpu'``. 
 
  Returns: 
    Number of devices. 
 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">int(get_backend(backend).device_count())</span>


<span class="s3">def </span><span class="s1">local_device_count(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; int:</span>
  <span class="s2">&quot;&quot;&quot;Returns the number of devices addressable by this process.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">int(get_backend(backend).local_device_count())</span>


<span class="s3">def </span><span class="s1">devices(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; List[xla_client.Device]:</span>
  <span class="s2">&quot;&quot;&quot;Returns a list of all devices for a given backend. 
 
  .. currentmodule:: jaxlib.xla_extension 
 
  Each device is represented by a subclass of :class:`Device` (e.g. 
  :class:`CpuDevice`, :class:`GpuDevice`). The length of the returned list is 
  equal to ``device_count(backend)``. Local devices can be identified by 
  comparing :attr:`Device.process_index` to the value returned by 
  :py:func:`jax.process_index`. 
 
  If ``backend`` is ``None``, returns all the devices from the default backend. 
  The default backend is generally ``'gpu'`` or ``'tpu'`` if available, 
  otherwise ``'cpu'``. 
 
  Args: 
    backend: This is an experimental feature and the API is likely to change. 
      Optional, a string representing the xla backend: ``'cpu'``, ``'gpu'``, or 
      ``'tpu'``. 
 
  Returns: 
    List of Device subclasses. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">get_backend(backend).devices()</span>


<span class="s3">def </span><span class="s1">default_backend() -&gt; str:</span>
  <span class="s2">&quot;&quot;&quot;Returns the platform name of the default XLA backend.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">get_backend(</span><span class="s3">None</span><span class="s1">).platform</span>


<span class="s3">def </span><span class="s1">local_devices(process_index: Optional[int] = </span><span class="s3">None,</span>
                  <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None,</span>
                  <span class="s1">host_id: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; List[xla_client.Device]:</span>
  <span class="s2">&quot;&quot;&quot;Like :py:func:`jax.devices`, but only returns devices local to a given process. 
 
  If ``process_index`` is ``None``, returns devices local to this process. 
 
  Args: 
    process_index: the integer index of the process. Process indices can be 
      retrieved via ``len(jax.process_count())``. 
    backend: This is an experimental feature and the API is likely to change. 
      Optional, a string representing the xla backend: ``'cpu'``, ``'gpu'``, or 
      ``'tpu'``. 
 
  Returns: 
    List of Device subclasses. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">host_id </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;The argument to jax.local_devices has been renamed from `host_id` to &quot;</span>
        <span class="s4">&quot;`process_index`. This alias will eventually be removed; please update &quot;</span>
        <span class="s4">&quot;your code.&quot;</span><span class="s1">)</span>
    <span class="s1">process_index = host_id</span>
  <span class="s3">if </span><span class="s1">process_index </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">process_index = get_backend(backend).process_index()</span>
  <span class="s3">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= process_index &lt; process_count()):</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unknown process_index </span><span class="s3">{</span><span class="s1">process_index</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">[d </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">devices(backend) </span><span class="s3">if </span><span class="s1">d.process_index == process_index]</span>


<span class="s3">def </span><span class="s1">process_index(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; int:</span>
  <span class="s2">&quot;&quot;&quot;Returns the integer process index of this process. 
 
  On most platforms, this will always be 0. This will vary on multi-process 
  platforms though. 
 
  Args: 
    backend: This is an experimental feature and the API is likely to change. 
      Optional, a string representing the xla backend: ``'cpu'``, ``'gpu'``, or 
      ``'tpu'``. 
 
  Returns: 
    Integer process index. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">get_backend(backend).process_index()</span>


<span class="s0"># TODO: remove this sometime after jax 0.2.13 is released</span>
<span class="s3">def </span><span class="s1">host_id(backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span><span class="s1">) -&gt; int:</span>
  <span class="s1">warnings.warn(</span>
      <span class="s4">&quot;jax.host_id has been renamed to jax.process_index. This alias &quot;</span>
      <span class="s4">&quot;will eventually be removed; please update your code.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">process_index(backend)</span>


<span class="s3">def </span><span class="s1">process_count(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; int:</span>
  <span class="s2">&quot;&quot;&quot;Returns the number of JAX processes associated with the backend.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">max(d.process_index </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">devices(backend)) + </span><span class="s5">1</span>


<span class="s0"># TODO: remove this sometime after jax 0.2.13 is released</span>
<span class="s3">def </span><span class="s1">host_count(backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span><span class="s1">) -&gt; int:</span>
  <span class="s1">warnings.warn(</span>
      <span class="s4">&quot;jax.host_count has been renamed to jax.process_count. This alias &quot;</span>
      <span class="s4">&quot;will eventually be removed; please update your code.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">process_count(backend)</span>


<span class="s0"># TODO: remove this sometime after jax 0.2.13 is released</span>
<span class="s3">def </span><span class="s1">host_ids(</span>
    <span class="s1">backend: Optional[Union[str</span><span class="s3">, </span><span class="s1">xla_client.Client]] = </span><span class="s3">None</span>
<span class="s1">) -&gt; List[int]:</span>
  <span class="s1">warnings.warn(</span>
      <span class="s4">&quot;jax.host_ids has been deprecated; please use range(jax.process_count()) &quot;</span>
      <span class="s4">&quot;instead. jax.host_ids will eventually be removed; please update your &quot;</span>
      <span class="s4">&quot;code.&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">list(range(process_count(backend)))</span>


<span class="s3">def </span><span class="s1">using_pjrt_c_api(backend=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s3">return </span><span class="s4">&quot;PJRT C API&quot; </span><span class="s3">in </span><span class="s1">get_backend(backend).platform_version</span>
</pre>
</body>
</html>