<html>
<head>
<title>dispatch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dispatch.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2018 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s0"># Primitive dispatch and jit dispatch.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">atexit</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(Any</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Dict</span><span class="s2">, </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">,</span>
                    <span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Set</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">NamedTuple)</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">jax</span>
<span class="s2">from </span><span class="s1">jax.monitoring </span><span class="s2">import </span><span class="s1">record_event_duration_secs</span>

<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">array</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">core</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">dtypes</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">linear_util </span><span class="s2">as </span><span class="s1">lu</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">api_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">path</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">profiler</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">source_info_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">traceback_util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">xla_bridge </span><span class="s2">as </span><span class="s1">xb</span>
<span class="s2">from </span><span class="s1">jax._src.config </span><span class="s2">import </span><span class="s1">config</span><span class="s2">, </span><span class="s1">flags</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">ad</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">batching</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">mlir</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">partial_eval </span><span class="s2">as </span><span class="s1">pe</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">xla</span>
<span class="s2">from </span><span class="s1">jax._src.interpreters </span><span class="s2">import </span><span class="s1">pxla</span>
<span class="s2">from </span><span class="s1">jax._src.lib.mlir </span><span class="s2">import </span><span class="s1">ir</span>
<span class="s2">from </span><span class="s1">jax._src.lib </span><span class="s2">import </span><span class="s1">xla_client </span><span class="s2">as </span><span class="s1">xc</span>
<span class="s2">from </span><span class="s1">jax._src.sharding </span><span class="s2">import </span><span class="s1">Sharding</span>
<span class="s2">from </span><span class="s1">jax._src.sharding_impls </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">PmapSharding</span><span class="s2">, </span><span class="s1">SingleDeviceSharding</span><span class="s2">, </span><span class="s1">NamedSharding</span><span class="s2">,</span>
    <span class="s1">PartitionSpec</span><span class="s2">, </span><span class="s1">XLACompatibleSharding)</span>
<span class="s2">from </span><span class="s1">jax._src.util </span><span class="s2">import </span><span class="s1">flatten</span>


<span class="s1">JAXPR_TRACE_EVENT = </span><span class="s3">&quot;/jax/core/compile/jaxpr_trace_duration&quot;</span>
<span class="s1">BACKEND_COMPILE_EVENT = </span><span class="s3">&quot;/jax/core/compile/backend_compile_duration&quot;</span>

<span class="s1">FLAGS = flags.FLAGS</span>

<span class="s1">flags.DEFINE_string(</span>
    <span class="s3">'jax_dump_ir_to'</span><span class="s2">, </span><span class="s1">os.getenv(</span><span class="s3">'JAX_DUMP_IR_TO'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">help=</span><span class="s3">&quot;Path to which the IR that is emitted by JAX as input to the &quot;</span>
         <span class="s3">&quot;compiler should be dumped as text files. Optional. If omitted, JAX &quot;</span>
         <span class="s3">&quot;will not dump IR.&quot;</span><span class="s1">)</span>


<span class="s1">traceback_util.register_exclusion(__file__)</span>

<span class="s1">MYPY = </span><span class="s2">False  </span><span class="s0"># Are we currently type checking with mypy?</span>

<span class="s1">xe = xc._xla</span>

<span class="s1">Backend = xe.Client</span>
<span class="s1">Device = xc.Device</span>
<span class="s1">Buffer = xe.Buffer</span>

<span class="s1">CompileOptions = xc.CompileOptions</span>

<span class="s1">map</span><span class="s2">, </span><span class="s1">unsafe_map = util.safe_map</span><span class="s2">, </span><span class="s1">map</span>
<span class="s1">zip</span><span class="s2">, </span><span class="s1">unsafe_zip = util.safe_zip</span><span class="s2">, </span><span class="s1">zip</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s0"># This flag is set on exit; no logging should be attempted</span>
<span class="s1">_on_exit = </span><span class="s2">False</span>

<span class="s0">### op-by-op execution</span>

<span class="s1">ArgSpec = Tuple[core.AbstractValue</span><span class="s2">, </span><span class="s1">Optional[Device]]</span>

<span class="s2">def </span><span class="s1">arg_spec(x: Any) -&gt; ArgSpec:</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">pjit</span>

  <span class="s1">aval = xla.abstractify(x)</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">isinstance(x.sharding</span><span class="s2">, </span><span class="s1">PmapSharding):</span>
      <span class="s2">return </span><span class="s1">aval</span><span class="s2">, None</span>
    <span class="s2">return </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">(pjit.to_gspmd_sharding(x.sharding</span><span class="s2">, </span><span class="s1">x.ndim)  </span><span class="s0"># type: ignore</span>
                  <span class="s2">if </span><span class="s1">x._committed </span><span class="s2">else None</span><span class="s1">)</span>
  <span class="s2">except</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">aval</span><span class="s2">, None</span>


<span class="s2">def </span><span class="s1">apply_primitive(prim</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s4">&quot;&quot;&quot;Impl rule that compiles and runs a single primitive 'prim' using XLA.&quot;&quot;&quot;</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">pjit</span>

  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">compiled_fun = xla_primitive_callable(prim</span><span class="s2">, </span><span class="s1">*unsafe_map(arg_spec</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">,</span>
                                          <span class="s1">**params)</span>
  <span class="s2">except </span><span class="s1">pxla.DeviceAssignmentMismatchError </span><span class="s2">as </span><span class="s1">e:</span>
    <span class="s1">fails</span><span class="s2">, </span><span class="s1">= e.args</span>
    <span class="s0"># TODO(yashkatariya): Thread through a signature_fun via every primitive</span>
    <span class="s0"># using apply_primtive so that the error message has the right argument</span>
    <span class="s0"># name instead of `args[0]`, etc.</span>
    <span class="s1">arg_names = api_util._arg_names(prim.impl</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s1">msg = pjit._device_assignment_mismatch_error(</span>
        <span class="s1">prim.name</span><span class="s2">, </span><span class="s1">fails</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s3">'jit'</span><span class="s2">, </span><span class="s1">arg_names)</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from None</span>

  <span class="s2">return </span><span class="s1">compiled_fun(*args)</span>


<span class="s2">def </span><span class="s1">simple_impl(prim):</span>
  <span class="s1">prim.def_impl(partial(apply_primitive</span><span class="s2">, </span><span class="s1">prim))</span>

<span class="s1">RuntimeToken = Any</span>

<span class="s2">class </span><span class="s1">RuntimeTokenSet(threading.local):</span>
  <span class="s1">tokens: Dict[core.Effect</span><span class="s2">, </span><span class="s1">Tuple[RuntimeToken</span><span class="s2">, </span><span class="s1">Device]]</span>
  <span class="s1">output_tokens: Dict[Device</span><span class="s2">, </span><span class="s1">RuntimeToken]</span>
  <span class="s1">output_runtime_tokens: Dict[Device</span><span class="s2">, </span><span class="s1">RuntimeToken]</span>

  <span class="s2">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self.tokens = {}</span>
    <span class="s0"># TODO(sharadmv): remove redundant output token dictionary when minimum</span>
    <span class="s0"># jaxlib version is bumped to 0.3.16.</span>
    <span class="s1">self.output_tokens = {}</span>
    <span class="s1">self.output_runtime_tokens = {}</span>

  <span class="s2">def </span><span class="s1">get_token(self</span><span class="s2">, </span><span class="s1">eff: core.Effect</span><span class="s2">, </span><span class="s1">device: Device) -&gt; RuntimeToken:</span>
    <span class="s1">s = jax.sharding.SingleDeviceSharding(device)</span>
    <span class="s2">if </span><span class="s1">eff </span><span class="s2">not in </span><span class="s1">self.tokens:</span>
      <span class="s1">inp = np.zeros(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.bool_)</span>
      <span class="s1">indices = tuple(</span>
          <span class="s1">s.addressable_devices_indices_map(inp.shape).values())</span>
      <span class="s1">out = pxla.shard_args([device]</span><span class="s2">, </span><span class="s1">[indices]</span><span class="s2">, </span><span class="s1">[s]</span><span class="s2">, </span><span class="s1">[inp])</span>
      <span class="s1">self.tokens[eff] = out</span><span class="s2">, </span><span class="s1">device</span>
    <span class="s2">elif </span><span class="s1">self.tokens[eff][</span><span class="s5">1</span><span class="s1">] != device:</span>
      <span class="s1">(old_token</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.tokens[eff]</span>
      <span class="s1">indices = tuple(</span>
          <span class="s1">s.addressable_devices_indices_map((</span><span class="s5">0</span><span class="s2">,</span><span class="s1">)).values())</span>
      <span class="s1">out = pxla.shard_args([device]</span><span class="s2">, </span><span class="s1">[indices]</span><span class="s2">, </span><span class="s1">[s]</span><span class="s2">, </span><span class="s1">[old_token])</span>
      <span class="s1">self.tokens[eff] = out</span><span class="s2">, </span><span class="s1">device</span>
    <span class="s2">return </span><span class="s1">self.tokens[eff][</span><span class="s5">0</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">update_token(self</span><span class="s2">, </span><span class="s1">eff: core.Effect</span><span class="s2">, </span><span class="s1">token: RuntimeToken):</span>
    <span class="s1">self.tokens[eff] = token</span><span class="s2">, </span><span class="s1">self.tokens[eff][</span><span class="s5">1</span><span class="s1">]</span>

  <span class="s2">def </span><span class="s1">set_output_token(self</span><span class="s2">, </span><span class="s1">device: Device</span><span class="s2">, </span><span class="s1">token: RuntimeToken):</span>
    <span class="s0"># We're free to clobber the previous output token because on each</span>
    <span class="s0"># device we have a total ordering of computations. Only the token</span>
    <span class="s0"># from the latest computation matters. If this weren't the case</span>
    <span class="s0"># we'd need to store a set of output tokens.</span>
    <span class="s1">self.output_tokens[device] = token</span>

  <span class="s2">def </span><span class="s1">set_output_runtime_token(self</span><span class="s2">, </span><span class="s1">device: Device</span><span class="s2">, </span><span class="s1">token: RuntimeToken):</span>
    <span class="s0"># TODO(sharadmv): remove this method when minimum jaxlib version is bumped</span>
    <span class="s1">self.output_runtime_tokens[device] = token</span>

  <span class="s2">def </span><span class="s1">clear(self):</span>
    <span class="s1">self.tokens = {}</span>
    <span class="s1">self.output_tokens = {}</span>
    <span class="s1">self.output_runtime_tokens = {}</span>

  <span class="s2">def </span><span class="s1">block_until_ready(self):</span>
    <span class="s2">for </span><span class="s1">token</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.tokens.values():</span>
      <span class="s1">token[</span><span class="s5">0</span><span class="s1">].block_until_ready()</span>
    <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self.output_tokens.values():</span>
      <span class="s1">token[</span><span class="s5">0</span><span class="s1">].block_until_ready()</span>
    <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self.output_runtime_tokens.values():</span>
      <span class="s1">token.block_until_ready()</span>
    <span class="s1">self.clear()</span>

<span class="s1">runtime_tokens: RuntimeTokenSet = RuntimeTokenSet()</span>

<span class="s1">@atexit.register</span>
<span class="s2">def </span><span class="s1">wait_for_tokens():</span>
  <span class="s1">runtime_tokens.block_until_ready()</span>

<span class="s1">@util.cache()</span>
<span class="s2">def </span><span class="s1">xla_primitive_callable(prim</span><span class="s2">, </span><span class="s1">*arg_specs: ArgSpec</span><span class="s2">, </span><span class="s1">**params):</span>
  <span class="s1">donated_invars = (</span><span class="s2">False,</span><span class="s1">) * len(arg_specs)</span>
  <span class="s2">def </span><span class="s1">prim_fun(*args):</span>
    <span class="s1">out = prim.bind(*args</span><span class="s2">, </span><span class="s1">**params)</span>
    <span class="s2">if </span><span class="s1">prim.multiple_results:</span>
      <span class="s2">return </span><span class="s1">out</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">out</span><span class="s2">,</span>
  <span class="s1">compiled = _xla_callable_uncached(lu.wrap_init(prim_fun)</span><span class="s2">, </span><span class="s1">prim.name</span><span class="s2">,</span>
                                    <span class="s1">donated_invars</span><span class="s2">, False, </span><span class="s1">*arg_specs)</span>
  <span class="s2">if not </span><span class="s1">prim.multiple_results:</span>
    <span class="s2">return lambda </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw: compiled(*args</span><span class="s2">, </span><span class="s1">**kw)[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">compiled</span>


<span class="s2">def </span><span class="s1">_device_from_arg_devices(devices: Sequence[Optional[Device]]) -&gt; Optional[Device]:</span>
  <span class="s4">&quot;&quot;&quot;Given devices of inputs, determine where to perform a computation. 
 
  Args: 
    devices: list where each element is a either a `Device` instance or `None`. 
  Returns: 
    A `Device` instance or None. 
  Raises: 
    ValueError if input devices are inconsistent. 
  &quot;&quot;&quot;</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">device</span><span class="s2">, </span><span class="s1">= {d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">devices </span><span class="s2">if </span><span class="s1">d </span><span class="s2">is not None</span><span class="s1">} </span><span class="s2">or </span><span class="s1">(</span><span class="s2">None,</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">device</span>
  <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
    <span class="s1">msg = </span><span class="s3">&quot;primitive arguments must be colocated on the same device, got {}&quot;</span>
    <span class="s2">raise </span><span class="s1">ValueError(msg.format(</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">devices)))) </span><span class="s2">from </span><span class="s1">err</span>



<span class="s2">def </span><span class="s1">sharded_lowering(fun</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">,</span>
                     <span class="s1">*arg_specs</span><span class="s2">, </span><span class="s1">lowering_platform: Optional[str]):</span>
  <span class="s1">in_avals</span><span class="s2">, </span><span class="s1">in_shardings = util.unzip2(arg_specs)</span>
  <span class="s1">in_shardings = [pxla._UNSPECIFIED </span><span class="s2">if </span><span class="s1">i </span><span class="s2">is None else </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">in_shardings]  </span><span class="s0"># type: ignore</span>

  <span class="s0"># Pass in a singleton `_UNSPECIFIED` for out_shardings because we don't know</span>
  <span class="s0"># the number of output avals at this stage. lower_sharding_computation will</span>
  <span class="s0"># apply it to all out_avals.</span>
  <span class="s2">return </span><span class="s1">pxla.lower_sharding_computation(</span>
      <span class="s1">fun</span><span class="s2">, </span><span class="s3">'jit'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">in_shardings</span><span class="s2">, </span><span class="s1">pxla._UNSPECIFIED</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
      <span class="s1">in_avals</span><span class="s2">, </span><span class="s1">keep_unused=keep_unused</span><span class="s2">, </span><span class="s1">always_lower=</span><span class="s2">False,</span>
      <span class="s1">devices_from_context=</span><span class="s2">None, </span><span class="s1">lowering_platform=lowering_platform)</span>


<span class="s2">def </span><span class="s1">_xla_callable_uncached(fun: lu.WrappedFun</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">,</span>
                           <span class="s1">keep_unused</span><span class="s2">, </span><span class="s1">*arg_specs):</span>
  <span class="s1">computation = sharded_lowering(fun</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">donated_invars</span><span class="s2">, </span><span class="s1">keep_unused</span><span class="s2">,</span>
                                 <span class="s1">*arg_specs</span><span class="s2">, </span><span class="s1">lowering_platform=</span><span class="s2">None</span><span class="s1">)</span>
  <span class="s1">allow_prop = [</span><span class="s2">True</span><span class="s1">] * len(computation.compile_args[</span><span class="s3">'global_out_avals'</span><span class="s1">])</span>
  <span class="s2">return </span><span class="s1">computation.compile(_allow_propagation_to_outputs=allow_prop).unsafe_call</span>


<span class="s2">def </span><span class="s1">is_single_device_sharding(sharding) -&gt; bool:</span>
  <span class="s0"># Special case PmapSharding here because PmapSharding maps away an axis</span>
  <span class="s0"># and needs to be handled separately.test_pjit_single_device_sharding_add</span>
  <span class="s2">return </span><span class="s1">len(sharding.device_set) == </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">isinstance(sharding</span><span class="s2">, </span><span class="s1">PmapSharding)</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">log_elapsed_time(fmt: str</span><span class="s2">, </span><span class="s1">event: Optional[str] = </span><span class="s2">None</span><span class="s1">):</span>
  <span class="s2">if </span><span class="s1">_on_exit:</span>
    <span class="s2">yield</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">log_priority = logging.WARNING </span><span class="s2">if </span><span class="s1">config.jax_log_compiles </span><span class="s2">else </span><span class="s1">logging.DEBUG</span>
    <span class="s1">start_time = time.time()</span>
    <span class="s2">yield</span>
    <span class="s1">elapsed_time = time.time() - start_time</span>
    <span class="s1">logger.log(log_priority</span><span class="s2">, </span><span class="s1">fmt.format(elapsed_time=elapsed_time))</span>
    <span class="s2">if </span><span class="s1">event </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">record_event_duration_secs(event</span><span class="s2">, </span><span class="s1">elapsed_time)</span>


<span class="s2">def </span><span class="s1">should_tuple_args(num_args: int</span><span class="s2">, </span><span class="s1">platform: str):</span>
  <span class="s0"># CPU and GPU do not need tuples as they use host-side data structures that</span>
  <span class="s0"># do not have small bounds.</span>
  <span class="s0"># TPU only needs a tuple for very long lists</span>
  <span class="s2">if </span><span class="s1">platform == </span><span class="s3">&quot;tpu&quot;</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">num_args &gt; </span><span class="s5">2000</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">raise_warnings_or_errors_for_jit_of_pmap(nreps</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">jaxpr):</span>
  <span class="s2">if </span><span class="s1">nreps &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">f&quot;The jitted function </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">includes a pmap. Using &quot;</span>
         <span class="s3">&quot;jit-of-pmap can lead to inefficient data movement, as the outer jit &quot;</span>
         <span class="s3">&quot;does not preserve sharded data representations and instead collects &quot;</span>
         <span class="s3">&quot;input and output arrays onto a single device. &quot;</span>
         <span class="s3">&quot;Consider removing the outer jit unless you know what you're doing. &quot;</span>
         <span class="s3">&quot;See https://github.com/google/jax/issues/2926.&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">nreps &gt; xb.device_count(backend):</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span>
        <span class="s3">f&quot;compiling computation `</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">` that requires </span><span class="s2">{</span><span class="s1">nreps</span><span class="s2">} </span><span class="s3">replicas, but &quot;</span>
        <span class="s3">f&quot;only </span><span class="s2">{</span><span class="s1">xb.device_count(backend)</span><span class="s2">} </span><span class="s3">XLA devices are available.&quot;</span><span class="s1">)</span>

  <span class="s2">if </span><span class="s1">xb.process_count() &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">(nreps &gt; </span><span class="s5">1 </span><span class="s2">or</span>
                                 <span class="s1">jaxpr_has_primitive(jaxpr</span><span class="s2">, </span><span class="s3">&quot;xla_pmap&quot;</span><span class="s1">)):</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
        <span class="s3">&quot;jit of multi-host pmap not implemented (and jit-of-pmap can cause &quot;</span>
        <span class="s3">&quot;extra data movement anyway, so maybe you don't want it after all).&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">jaxpr_has_primitive(jaxpr</span><span class="s2">, </span><span class="s1">prim_name: str):</span>
  <span class="s4">&quot;&quot;&quot;Whether there is a primitive given by user anywhere inside a Jaxpr.&quot;&quot;&quot;</span>
  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s2">if </span><span class="s1">prim_name </span><span class="s2">in </span><span class="s1">eqn.primitive.name:</span>
      <span class="s2">return True</span>
  <span class="s2">for </span><span class="s1">subjaxpr </span><span class="s2">in </span><span class="s1">core.subjaxprs(jaxpr):</span>
    <span class="s2">if </span><span class="s1">jaxpr_has_primitive(subjaxpr</span><span class="s2">, </span><span class="s1">prim_name):</span>
      <span class="s2">return True</span>
  <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">SourceInfo(NamedTuple):</span>
  <span class="s1">source_info: str</span>
  <span class="s1">eqn_name: str</span>


<span class="s2">def </span><span class="s1">jaxpr_shardings(</span>
    <span class="s1">jaxpr) -&gt; Iterator[Tuple[jax.sharding.XLACompatibleSharding</span><span class="s2">, </span><span class="s1">SourceInfo]]:</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">pjit</span>
  <span class="s2">from </span><span class="s1">jax.experimental </span><span class="s2">import </span><span class="s1">shard_map</span>

  <span class="s2">for </span><span class="s1">eqn </span><span class="s2">in </span><span class="s1">jaxpr.eqns:</span>
    <span class="s2">if </span><span class="s1">eqn.primitive </span><span class="s2">is </span><span class="s1">pjit.sharding_constraint_p:</span>
      <span class="s1">source_info = SourceInfo(source_info_util.summarize(eqn.source_info)</span><span class="s2">,</span>
                                <span class="s1">eqn.primitive.name)</span>
      <span class="s2">yield </span><span class="s1">(eqn.params[</span><span class="s3">'sharding'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">source_info)</span>
    <span class="s2">elif </span><span class="s1">eqn.primitive </span><span class="s2">is </span><span class="s1">pjit.pjit_p:</span>
      <span class="s1">source_info = SourceInfo(source_info_util.summarize(eqn.source_info)</span><span class="s2">,</span>
                                <span class="s1">eqn.primitive.name)</span>
      <span class="s2">yield from </span><span class="s1">((i</span><span class="s2">, </span><span class="s1">source_info) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">eqn.params[</span><span class="s3">'in_shardings'</span><span class="s1">])</span>
      <span class="s2">yield from </span><span class="s1">((o</span><span class="s2">, </span><span class="s1">source_info) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">eqn.params[</span><span class="s3">'out_shardings'</span><span class="s1">])</span>
    <span class="s2">elif </span><span class="s1">eqn.primitive </span><span class="s2">is </span><span class="s1">shard_map.shard_map_p:</span>
      <span class="s1">source_info = SourceInfo(source_info_util.summarize(eqn.source_info)</span><span class="s2">,</span>
                                <span class="s1">eqn.primitive.name)</span>
      <span class="s2">def </span><span class="s1">_names_to_pspec(names):</span>
        <span class="s1">ndmin = max(names) + </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">names </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">PartitionSpec(*(names.get(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ndmin)))</span>
      <span class="s2">yield from </span><span class="s1">((NamedSharding(eqn.params[</span><span class="s3">'mesh'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_names_to_pspec(names))</span><span class="s2">, </span><span class="s1">source_info)</span>
                  <span class="s2">for </span><span class="s1">names </span><span class="s2">in </span><span class="s1">eqn.params[</span><span class="s3">'in_names'</span><span class="s1">])</span>
  <span class="s2">for </span><span class="s1">subjaxpr </span><span class="s2">in </span><span class="s1">core.subjaxprs(jaxpr):</span>
    <span class="s2">yield from </span><span class="s1">jaxpr_shardings(subjaxpr)</span>


<span class="s2">def </span><span class="s1">jaxpr_has_bints(jaxpr: core.Jaxpr) -&gt; bool:</span>
  <span class="s2">return </span><span class="s1">(any(type(v.aval.dtype) </span><span class="s2">is </span><span class="s1">core.bint </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">jaxpr.invars</span>
              <span class="s2">if </span><span class="s1">isinstance(v.aval</span><span class="s2">, </span><span class="s1">core.UnshapedArray)) </span><span class="s2">or</span>
          <span class="s1">any(_is_bint_axis_size(d)</span>
              <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">itertools.chain([jaxpr]</span><span class="s2">, </span><span class="s1">core.subjaxprs(jaxpr))</span>
              <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">j.eqns </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">e.outvars</span>
              <span class="s2">if </span><span class="s1">isinstance(v.aval</span><span class="s2">, </span><span class="s1">core.DShapedArray) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">v.aval.shape))</span>

<span class="s2">def </span><span class="s1">_is_bint_axis_size(d: core.AxisSize) -&gt; bool:</span>
  <span class="s2">if </span><span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">core.DArray):</span>
    <span class="s2">assert not </span><span class="s1">d.shape</span>
    <span class="s2">return </span><span class="s1">type(d.dtype) </span><span class="s2">is </span><span class="s1">core.bint</span>
  <span class="s2">elif </span><span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">core.Var):</span>
    <span class="s2">return </span><span class="s1">(isinstance(d.aval</span><span class="s2">, </span><span class="s1">core.DShapedArray) </span><span class="s2">and</span>
            <span class="s1">type(d.aval.dtype) </span><span class="s2">is </span><span class="s1">core.bint)</span>
  <span class="s2">return False</span>

<span class="s2">def </span><span class="s1">_prune_unused_inputs(</span>
    <span class="s1">jaxpr: core.Jaxpr) -&gt; Tuple[core.Jaxpr</span><span class="s2">, </span><span class="s1">Set[int]</span><span class="s2">, </span><span class="s1">Set[int]]:</span>
  <span class="s1">used_outputs = [</span><span class="s2">True</span><span class="s1">] * len(jaxpr.outvars)</span>
  <span class="s1">new_jaxpr</span><span class="s2">, </span><span class="s1">used_consts</span><span class="s2">, </span><span class="s1">used_inputs = pe.dce_jaxpr_consts(jaxpr</span><span class="s2">, </span><span class="s1">used_outputs)</span>
  <span class="s1">kept_const_idx = {i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">enumerate(used_consts) </span><span class="s2">if </span><span class="s1">b}</span>
  <span class="s1">kept_var_idx = {i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">enumerate(used_inputs) </span><span class="s2">if </span><span class="s1">b}</span>
  <span class="s2">return </span><span class="s1">new_jaxpr</span><span class="s2">, </span><span class="s1">kept_const_idx</span><span class="s2">, </span><span class="s1">kept_var_idx</span>


<span class="s0"># We can optionally set a Jaxpr rewriter that can be applied just before</span>
<span class="s0"># compilation. This mechanism is used for compiling id_tap, we can</span>
<span class="s0"># remove it once we bring the id_tap implementation into the core.</span>
<span class="s1">outfeed_rewriter: Optional[Callable[[core.Jaxpr]</span><span class="s2">, </span><span class="s1">core.Jaxpr]] = </span><span class="s2">None</span>
<span class="s2">def </span><span class="s1">apply_outfeed_rewriter(jaxpr: core.Jaxpr) -&gt; core.Jaxpr:</span>
  <span class="s2">if </span><span class="s1">outfeed_rewriter </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">outfeed_rewriter(jaxpr)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">jaxpr</span>


<span class="s0"># TODO(mattjj,necula): this duplicates code in core.valid_jaxtype, but one</span>
<span class="s0"># internal user relies on it for duck-typing. must fix downstream user!</span>
<span class="s2">def </span><span class="s1">_valid_jaxtype(arg):</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">xla.abstractify(arg)  </span><span class="s0"># faster than core.get_aval</span>
  <span class="s2">except </span><span class="s1">TypeError:</span>
    <span class="s2">return </span><span class="s1">core.valid_jaxtype(arg)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">check_arg(arg):</span>
  <span class="s2">if not </span><span class="s1">(isinstance(arg</span><span class="s2">, </span><span class="s1">core.Tracer) </span><span class="s2">or </span><span class="s1">_valid_jaxtype(arg)):</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">f&quot;Argument '</span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s3">' of type </span><span class="s2">{</span><span class="s1">type(arg)</span><span class="s2">} </span><span class="s3">is not a valid &quot;</span>
                    <span class="s3">&quot;JAX type.&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">jaxpr_replicas(jaxpr) -&gt; int:</span>
  <span class="s4">&quot;&quot;&quot;The number of replicas needed for a jaxpr. 
 
  For a eqn, multiply the `axis_size` with the `jaxpr_replicas` of the 
  subjaxprs. For a list of eqns, take the maximum number of replicas. 
  &quot;&quot;&quot;</span>
  <span class="s2">if </span><span class="s1">isinstance(jaxpr</span><span class="s2">, </span><span class="s1">core.ClosedJaxpr):</span>
    <span class="s1">jaxpr = jaxpr.jaxpr</span>
  <span class="s2">return </span><span class="s1">max(unsafe_map(eqn_replicas</span><span class="s2">, </span><span class="s1">jaxpr.eqns)</span><span class="s2">, </span><span class="s1">default=</span><span class="s5">1</span><span class="s1">)</span>

<span class="s0"># TODO(mattjj): this function assumes that only pmap has a parameter named</span>
<span class="s0"># axis_size, and that it corresponds to cross-replica mapping</span>
<span class="s2">def </span><span class="s1">eqn_replicas(eqn):</span>
  <span class="s1">call_jaxpr = eqn.params.get(</span><span class="s3">&quot;call_jaxpr&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">call_jaxpr:</span>
    <span class="s2">return </span><span class="s1">eqn.params.get(</span><span class="s3">'axis_size'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) * jaxpr_replicas(call_jaxpr)</span>
  <span class="s2">elif </span><span class="s1">eqn.primitive </span><span class="s2">in </span><span class="s1">xla.initial_style_primitives:</span>
    <span class="s2">return </span><span class="s1">initial_style_primitive_replicas(eqn.params)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s5">1</span>

<span class="s2">def </span><span class="s1">initial_style_primitive_replicas(params):</span>
  <span class="s2">return </span><span class="s1">max(core.traverse_jaxpr_params(jaxpr_replicas</span><span class="s2">, </span><span class="s1">params).values()</span><span class="s2">, </span><span class="s1">default=</span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">needs_check_special():</span>
  <span class="s2">return </span><span class="s1">config.jax_debug_infs </span><span class="s2">or </span><span class="s1">config.jax_debug_nans</span>

<span class="s2">def </span><span class="s1">check_special(name</span><span class="s2">, </span><span class="s1">bufs):</span>
  <span class="s2">if </span><span class="s1">needs_check_special():</span>
    <span class="s2">for </span><span class="s1">buf </span><span class="s2">in </span><span class="s1">bufs:</span>
      <span class="s1">_check_special(name</span><span class="s2">, </span><span class="s1">buf.dtype</span><span class="s2">, </span><span class="s1">buf)</span>

<span class="s2">def </span><span class="s1">_check_special(name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">buf):</span>
  <span class="s2">if </span><span class="s1">dtypes.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.inexact):</span>
    <span class="s2">if </span><span class="s1">config.jax_debug_nans </span><span class="s2">and </span><span class="s1">np.any(np.isnan(np.asarray(buf))):</span>
      <span class="s2">raise </span><span class="s1">FloatingPointError(</span><span class="s3">f&quot;invalid value (nan) encountered in </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">config.jax_debug_infs </span><span class="s2">and </span><span class="s1">np.any(np.isinf(np.asarray(buf))):</span>
      <span class="s2">raise </span><span class="s1">FloatingPointError(</span><span class="s3">f&quot;invalid value (inf) encountered in </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">_add_tokens(has_unordered_effects: bool</span><span class="s2">, </span><span class="s1">ordered_effects: List[core.Effect]</span><span class="s2">,</span>
                <span class="s1">has_host_callbacks: bool</span><span class="s2">, </span><span class="s1">device: Device</span><span class="s2">, </span><span class="s1">input_bufs):</span>
  <span class="s1">tokens = [runtime_tokens.get_token(eff</span><span class="s2">, </span><span class="s1">device) </span><span class="s2">for </span><span class="s1">eff </span><span class="s2">in </span><span class="s1">ordered_effects]</span>
  <span class="s1">tokens_flat = flatten(tokens)</span>
  <span class="s1">input_bufs = [*tokens_flat</span><span class="s2">, </span><span class="s1">*input_bufs]</span>
  <span class="s2">def </span><span class="s1">_remove_tokens(output_bufs</span><span class="s2">, </span><span class="s1">runtime_token):</span>
    <span class="s1">num_output_tokens = len(ordered_effects)</span>
    <span class="s1">token_bufs</span><span class="s2">, </span><span class="s1">output_bufs = util.split_list(output_bufs</span><span class="s2">, </span><span class="s1">[num_output_tokens])</span>
    <span class="s2">if </span><span class="s1">has_unordered_effects </span><span class="s2">or </span><span class="s1">has_host_callbacks:</span>
      <span class="s1">runtime_tokens.set_output_runtime_token(device</span><span class="s2">, </span><span class="s1">runtime_token)</span>
    <span class="s2">for </span><span class="s1">eff</span><span class="s2">, </span><span class="s1">token_buf </span><span class="s2">in </span><span class="s1">zip(ordered_effects</span><span class="s2">, </span><span class="s1">token_bufs):</span>
      <span class="s1">runtime_tokens.update_token(eff</span><span class="s2">, </span><span class="s1">token_buf)</span>
    <span class="s2">return </span><span class="s1">output_bufs</span>
  <span class="s2">return </span><span class="s1">input_bufs</span><span class="s2">, </span><span class="s1">_remove_tokens</span>


<span class="s1">@profiler.annotate_function</span>
<span class="s2">def </span><span class="s1">backend_compile(backend</span><span class="s2">, </span><span class="s1">built_c</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">host_callbacks):</span>
  <span class="s0"># we use a separate function call to ensure that XLA compilation appears</span>
  <span class="s0"># separately in Python profiling results</span>
  <span class="s2">if </span><span class="s1">host_callbacks:</span>
    <span class="s2">return </span><span class="s1">backend.compile(built_c</span><span class="s2">, </span><span class="s1">compile_options=options</span><span class="s2">,</span>
                           <span class="s1">host_callbacks=host_callbacks)</span>
  <span class="s0"># Some backends don't have `host_callbacks` option yet</span>
  <span class="s0"># TODO(sharadmv): remove this fallback when all backends allow `compile`</span>
  <span class="s0"># to take in `host_callbacks`</span>
  <span class="s2">return </span><span class="s1">backend.compile(built_c</span><span class="s2">, </span><span class="s1">compile_options=options)</span>

<span class="s1">_ir_dump_counter = itertools.count()</span>

<span class="s2">def </span><span class="s1">_make_string_safe_for_filename(s: str) -&gt; str:</span>
  <span class="s2">return </span><span class="s1">re.sub(</span><span class="s3">r'[^\w.)( -]'</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">s)</span>

<span class="s2">def </span><span class="s1">_dump_ir_to_file(name: str</span><span class="s2">, </span><span class="s1">ir: str):</span>
  <span class="s1">id = next(_ir_dump_counter)</span>
  <span class="s1">name = </span><span class="s3">f&quot;jax_ir</span><span class="s2">{</span><span class="s1">id</span><span class="s2">}</span><span class="s3">_</span><span class="s2">{</span><span class="s1">_make_string_safe_for_filename(name)</span><span class="s2">}</span><span class="s3">.mlir&quot;</span>
  <span class="s1">name = path.Path(FLAGS.jax_dump_ir_to) / name</span>
  <span class="s1">name.write_text(ir)</span>


<span class="s2">def </span><span class="s1">compile_or_get_cached(backend</span><span class="s2">, </span><span class="s1">computation: ir.Module</span><span class="s2">, </span><span class="s1">compile_options</span><span class="s2">,</span>
                          <span class="s1">host_callbacks):</span>
  <span class="s0"># Avoid import cycle between jax and jax.experimental</span>
  <span class="s2">from </span><span class="s1">jax.experimental.compilation_cache </span><span class="s2">import </span><span class="s1">compilation_cache </span><span class="s2">as </span><span class="s1">cc</span>

  <span class="s1">sym_name = computation.operation.attributes[</span><span class="s3">'sym_name'</span><span class="s1">]</span>
  <span class="s1">module_name = ir.StringAttr(sym_name).value</span>

  <span class="s2">if </span><span class="s1">FLAGS.jax_dump_ir_to:</span>
    <span class="s1">_dump_ir_to_file(module_name</span><span class="s2">, </span><span class="s1">mlir.module_to_string(computation))</span>

  <span class="s0"># Convert ir.Module to a string representation, unless the</span>
  <span class="s0"># back-end expliclity flags the ability to handle a module directly</span>
  <span class="s0"># (avoiding the overhead of back and forth conversions)</span>
  <span class="s1">serialized_computation: Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">ir.Module]</span>
  <span class="s2">if </span><span class="s1">getattr(backend</span><span class="s2">, </span><span class="s3">&quot;needs_str_ir&quot;</span><span class="s2">, True</span><span class="s1">):</span>
    <span class="s1">serialized_computation = mlir.module_to_bytecode(computation)</span>
  <span class="s2">else</span><span class="s1">:</span>
    <span class="s1">serialized_computation = computation</span>

  <span class="s0"># Persistent compilation cache only implemented on TPU and GPU.</span>
  <span class="s0"># TODO(skye): add warning when initializing cache on unsupported default platform</span>
  <span class="s1">supported_platforms = [</span><span class="s3">&quot;tpu&quot;</span><span class="s2">, </span><span class="s3">&quot;gpu&quot;</span><span class="s1">]</span>
  <span class="s0"># (b/233850967) CPU caching can be enabled if XLA Runtime is enabled.</span>
  <span class="s2">if </span><span class="s3">&quot;--xla_cpu_use_xla_runtime=true&quot; </span><span class="s2">in </span><span class="s1">os.environ.get(</span><span class="s3">&quot;XLA_FLAGS&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">):</span>
    <span class="s1">supported_platforms.append(</span><span class="s3">&quot;cpu&quot;</span><span class="s1">)</span>
  <span class="s2">if </span><span class="s1">cc.is_initialized() </span><span class="s2">and </span><span class="s1">backend.platform </span><span class="s2">in </span><span class="s1">supported_platforms:</span>
    <span class="s1">cached_executable = _cache_read(serialized_computation</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">,</span>
                                    <span class="s1">compile_options</span><span class="s2">, </span><span class="s1">backend)</span>
    <span class="s2">if </span><span class="s1">cached_executable </span><span class="s2">is not None</span><span class="s1">:</span>
      <span class="s1">logger.info(</span><span class="s3">&quot;Persistent compilation cache hit for '%s'&quot;</span><span class="s2">, </span><span class="s1">module_name)</span>
      <span class="s2">return </span><span class="s1">cached_executable</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">start_time = time.monotonic()</span>
      <span class="s1">compiled = backend_compile(backend</span><span class="s2">, </span><span class="s1">serialized_computation</span><span class="s2">,</span>
                                 <span class="s1">compile_options</span><span class="s2">, </span><span class="s1">host_callbacks)</span>
      <span class="s1">compile_time = time.monotonic() - start_time</span>
      <span class="s1">_cache_write(serialized_computation</span><span class="s2">, </span><span class="s1">compile_time</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">,</span>
                   <span class="s1">compile_options</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">compiled</span><span class="s2">, </span><span class="s1">host_callbacks)</span>
      <span class="s2">return </span><span class="s1">compiled</span>

  <span class="s2">return </span><span class="s1">backend_compile(backend</span><span class="s2">, </span><span class="s1">serialized_computation</span><span class="s2">, </span><span class="s1">compile_options</span><span class="s2">,</span>
                         <span class="s1">host_callbacks)</span>


<span class="s2">def </span><span class="s1">_cache_read(computation: Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">ir.Module]</span><span class="s2">, </span><span class="s1">module_name: str</span><span class="s2">,</span>
                <span class="s1">compile_options: CompileOptions</span><span class="s2">,</span>
                <span class="s1">backend: Backend) -&gt; Optional[xc.LoadedExecutable]:</span>
  <span class="s4">&quot;&quot;&quot;Looks up `computation` in the persistent compilation cache.&quot;&quot;&quot;</span>
  <span class="s0"># Avoid import cycle between jax and jax.experimental</span>
  <span class="s2">from </span><span class="s1">jax.experimental.compilation_cache </span><span class="s2">import </span><span class="s1">compilation_cache </span><span class="s2">as </span><span class="s1">cc</span>

  <span class="s2">try</span><span class="s1">:</span>
    <span class="s2">return </span><span class="s1">cc.get_executable(computation</span><span class="s2">, </span><span class="s1">compile_options</span><span class="s2">, </span><span class="s1">backend)</span>
  <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
    <span class="s2">if </span><span class="s1">config.jax_raise_persistent_cache_errors:</span>
      <span class="s2">raise</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">f&quot;Error reading persistent compilation cache entry for &quot;</span>
        <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">module_name</span><span class="s2">}</span><span class="s3">': </span><span class="s2">{</span><span class="s1">type(ex).__name__</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_cache_write(serialized_computation: Union[str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">ir.Module]</span><span class="s2">,</span>
                 <span class="s1">compile_time_secs: float</span><span class="s2">,</span>
                 <span class="s1">module_name: str</span><span class="s2">, </span><span class="s1">compile_options: CompileOptions</span><span class="s2">,</span>
                 <span class="s1">backend: Backend</span><span class="s2">, </span><span class="s1">compiled: xc.LoadedExecutable</span><span class="s2">,</span>
                 <span class="s1">host_callbacks: List[Any]):</span>
  <span class="s4">&quot;&quot;&quot;Writes `serialized_computation` to the persistent compilation cache.&quot;&quot;&quot;</span>
  <span class="s0"># Avoid import cycle between jax and jax.experimental</span>
  <span class="s2">from </span><span class="s1">jax.experimental.compilation_cache </span><span class="s2">import </span><span class="s1">compilation_cache </span><span class="s2">as </span><span class="s1">cc</span>

  <span class="s2">if </span><span class="s1">host_callbacks:</span>
    <span class="s1">logger.info(</span>
        <span class="s3">&quot;Not writing persistent cache entry for '%s' because it uses host &quot;</span>
        <span class="s3">&quot;callbacks (e.g. from jax.debug.print or breakpoint)&quot;</span><span class="s1">)</span>
    <span class="s2">return</span>

  <span class="s1">min_compile_time = config.jax_persistent_cache_min_compile_time_secs</span>
  <span class="s2">if </span><span class="s1">min_compile_time:</span>
    <span class="s2">if </span><span class="s1">compile_time_secs &lt; min_compile_time:</span>
      <span class="s1">logger.info(</span>
          <span class="s3">&quot;Not writing persistent cache entry for '%s' because it took &lt; %.2f &quot;</span>
          <span class="s3">&quot;seconds to compile (%.2fs)&quot;</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">min_compile_time</span><span class="s2">,</span>
          <span class="s1">compile_time_secs)</span>
      <span class="s2">return</span>
    <span class="s2">else</span><span class="s1">:</span>
      <span class="s1">logger.info(</span>
          <span class="s3">&quot;'%s' took at least %.2f seconds to compile (%.2fs), writing &quot;</span>
          <span class="s3">&quot;persistent cache entry&quot;</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">min_compile_time</span><span class="s2">,</span>
          <span class="s1">compile_time_secs)</span>

  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">cc.put_executable(module_name</span><span class="s2">, </span><span class="s1">serialized_computation</span><span class="s2">, </span><span class="s1">compile_options</span><span class="s2">,</span>
                      <span class="s1">compiled</span><span class="s2">, </span><span class="s1">backend)</span>
  <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex:</span>
    <span class="s2">if </span><span class="s1">config.jax_raise_persistent_cache_errors:</span>
      <span class="s2">raise</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">f&quot;Error writing persistent compilation cache entry for &quot;</span>
        <span class="s3">f&quot;'</span><span class="s2">{</span><span class="s1">module_name</span><span class="s2">}</span><span class="s3">': </span><span class="s2">{</span><span class="s1">type(ex).__name__</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_set_aval(val):</span>
  <span class="s2">if </span><span class="s1">val.aval </span><span class="s2">is None</span><span class="s1">:</span>
    <span class="s1">val.aval = core.ShapedArray(val.shape</span><span class="s2">, </span><span class="s1">val.dtype)</span>
  <span class="s2">return </span><span class="s1">val</span>


<span class="s0"># TODO(yashkatariya): Generalize is_compatible_aval (maybe renamed) and use that</span>
<span class="s0"># to check if shardings are compatible with the input.</span>
<span class="s2">def </span><span class="s1">_check_sharding(aval</span><span class="s2">, </span><span class="s1">s):</span>
  <span class="s2">from </span><span class="s1">jax._src </span><span class="s2">import </span><span class="s1">pjit</span>

  <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">XLACompatibleSharding) </span><span class="s2">and not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">PmapSharding):</span>
    <span class="s1">pjit.pjit_check_aval_sharding(</span>
        <span class="s1">(s</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(aval</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;device_put args&quot;</span><span class="s2">, </span><span class="s1">allow_uneven_sharding=</span><span class="s2">False</span><span class="s1">)</span>

  <span class="s2">assert </span><span class="s1">isinstance(aval</span><span class="s2">, </span><span class="s1">core.ShapedArray)</span><span class="s2">, </span><span class="s1">aval</span>
  <span class="s1">s.shard_shape(aval.shape)  </span><span class="s0"># should raise an Error if incompatible</span>


<span class="s2">def </span><span class="s1">_put_x(x</span><span class="s2">, </span><span class="s1">s: Sharding</span><span class="s2">, </span><span class="s1">aval: core.AbstractValue</span><span class="s2">, </span><span class="s1">committed: bool):</span>
  <span class="s1">result_handler = pxla.global_aval_to_result_handler(aval</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">committed</span><span class="s2">, False</span><span class="s1">)</span>
  <span class="s1">map_ = s.devices_indices_map(aval.shape)  </span><span class="s0"># type: ignore</span>
  <span class="s2">return </span><span class="s1">result_handler(pxla.shard_arg(x</span><span class="s2">, </span><span class="s1">list(map_)</span><span class="s2">, </span><span class="s1">list(map_.values())</span><span class="s2">, </span><span class="s1">s))</span>


<span class="s2">def </span><span class="s1">_device_put_impl(</span>
    <span class="s1">x</span><span class="s2">,</span>
    <span class="s1">device: Optional[Union[Device</span><span class="s2">, </span><span class="s1">jax.sharding.Sharding]] = </span><span class="s2">None,</span>
    <span class="s1">src: Optional[Union[Device</span><span class="s2">, </span><span class="s1">jax.sharding.Sharding]] = </span><span class="s2">None</span><span class="s1">):</span>
  <span class="s2">try</span><span class="s1">:</span>
    <span class="s1">aval = xla.abstractify(x)</span>
  <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span>
        <span class="s3">f&quot;Argument '</span><span class="s2">{</span><span class="s1">x</span><span class="s2">}</span><span class="s3">' of type </span><span class="s2">{</span><span class="s1">type(x)</span><span class="s2">} </span><span class="s3">is not a valid JAX type&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

  <span class="s2">if </span><span class="s1">isinstance(device</span><span class="s2">, </span><span class="s1">Sharding):</span>
    <span class="s1">s = device</span>
    <span class="s2">if not </span><span class="s1">s.is_fully_addressable:  </span><span class="s0"># type: ignore</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span>
          <span class="s3">&quot;device_put's second argument must be a Device or a Sharding which &quot;</span>
          <span class="s3">f&quot;represents addressable devices, but got </span><span class="s2">{</span><span class="s1">s</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">_check_sharding(aval</span><span class="s2">, </span><span class="s1">s)</span>
    <span class="s2">if </span><span class="s1">getattr(x</span><span class="s2">, </span><span class="s3">'sharding'</span><span class="s2">, None</span><span class="s1">) == s:</span>
      <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">_put_x(x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, True</span><span class="s1">)</span>

  <span class="s0"># Only `Device` exists below. `Sharding` instance is handled above.</span>
  <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">array.ArrayImpl):</span>
    <span class="s2">if not </span><span class="s1">x.is_fully_addressable:</span>
      <span class="s2">raise </span><span class="s1">ValueError(</span>
          <span class="s3">&quot;device_put's first argument must be a fully addressable array, but &quot;</span>
          <span class="s3">f&quot;got value with devices </span><span class="s2">{</span><span class="s1">x.devices()</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">device </span><span class="s2">is None</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">elif </span><span class="s1">is_single_device_sharding(x.sharding):</span>
      <span class="s2">return </span><span class="s1">pxla.batched_device_put(aval</span><span class="s2">, </span><span class="s1">SingleDeviceSharding(device)</span><span class="s2">, </span><span class="s1">[x]</span><span class="s2">,</span>
                                     <span class="s1">[device])</span>

  <span class="s1">sh = SingleDeviceSharding(pxla._get_default_device()</span>
                            <span class="s2">if </span><span class="s1">device </span><span class="s2">is None else </span><span class="s1">device)</span>
  <span class="s2">return </span><span class="s1">_put_x(x</span><span class="s2">, </span><span class="s1">sh</span><span class="s2">, </span><span class="s1">aval</span><span class="s2">, </span><span class="s1">device </span><span class="s2">is not None</span><span class="s1">)</span>


<span class="s1">device_put_p = core.Primitive(</span><span class="s3">'device_put'</span><span class="s1">)</span>
<span class="s1">device_put_p.def_impl(_device_put_impl)</span>
<span class="s1">device_put_p.def_abstract_eval(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">device=</span><span class="s2">None, </span><span class="s1">src=</span><span class="s2">None</span><span class="s1">: x)</span>

<span class="s2">def </span><span class="s1">device_put_transpose_rule(ct</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">device</span><span class="s2">, </span><span class="s1">src):</span>
  <span class="s2">return </span><span class="s1">[device_put_p.bind(ct</span><span class="s2">, </span><span class="s1">device=src</span><span class="s2">, </span><span class="s1">src=device)]</span>
<span class="s1">ad.deflinear2(device_put_p</span><span class="s2">, </span><span class="s1">device_put_transpose_rule)</span>
<span class="s1">batching.defvectorized(device_put_p)</span>

<span class="s2">def </span><span class="s1">_device_put_lowering(ctx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">device</span><span class="s2">, </span><span class="s1">src):</span>
  <span class="s2">return </span><span class="s1">[x]</span>


<span class="s1">mlir.register_lowering(device_put_p</span><span class="s2">, </span><span class="s1">_device_put_lowering)</span>
</pre>
</body>
</html>