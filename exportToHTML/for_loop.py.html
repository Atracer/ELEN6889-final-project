<html>
<head>
<title>for_loop.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
for_loop.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2022 The JAX Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;Module for the `for_loop` primitive.&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">operator</span>

<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Generic</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Set</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">TypeVar</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">jax.numpy </span><span class="s3">as </span><span class="s1">jnp</span>
<span class="s3">from </span><span class="s1">jax </span><span class="s3">import </span><span class="s1">lax</span>
<span class="s3">from </span><span class="s1">jax.api_util </span><span class="s3">import </span><span class="s1">flatten_fun_nokwargs</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">ad</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">batching</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">mlir</span>
<span class="s3">from </span><span class="s1">jax._src.interpreters </span><span class="s3">import </span><span class="s1">partial_eval </span><span class="s3">as </span><span class="s1">pe</span>
<span class="s3">from </span><span class="s1">jax.tree_util </span><span class="s3">import </span><span class="s1">(tree_flatten</span><span class="s3">, </span><span class="s1">tree_structure</span><span class="s3">, </span><span class="s1">tree_unflatten</span><span class="s3">,</span>
                           <span class="s1">treedef_tuple</span><span class="s3">, </span><span class="s1">tree_map</span><span class="s3">, </span><span class="s1">tree_leaves</span><span class="s3">, </span><span class="s1">PyTreeDef)</span>

<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">ad_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">core</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dispatch</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">dtypes</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">linear_util </span><span class="s3">as </span><span class="s1">lu</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">source_info_util</span>
<span class="s3">from </span><span class="s1">jax._src </span><span class="s3">import </span><span class="s1">state</span>
<span class="s3">from </span><span class="s1">jax._src.util </span><span class="s3">import </span><span class="s1">(partition_list</span><span class="s3">, </span><span class="s1">merge_lists</span><span class="s3">, </span><span class="s1">safe_map</span><span class="s3">, </span><span class="s1">safe_zip</span><span class="s3">,</span>
                           <span class="s1">split_list</span><span class="s3">, </span><span class="s1">split_dict)</span>
<span class="s3">from </span><span class="s1">jax._src.lax.control_flow </span><span class="s3">import </span><span class="s1">loops</span>
<span class="s3">from </span><span class="s1">jax._src.lax.control_flow.common </span><span class="s3">import </span><span class="s1">_abstractify</span><span class="s3">, </span><span class="s1">_initial_style_jaxpr</span>

<span class="s0">## JAX utilities</span>

<span class="s1">map</span><span class="s3">, </span><span class="s1">unsafe_map = safe_map</span><span class="s3">, </span><span class="s1">map</span>
<span class="s1">zip</span><span class="s3">, </span><span class="s1">unsafe_zip = safe_zip</span><span class="s3">, </span><span class="s1">zip</span>

<span class="s0">## Helpful type aliases</span>
<span class="s1">S = TypeVar(</span><span class="s4">'S'</span><span class="s1">)</span>
<span class="s1">T = TypeVar(</span><span class="s4">'T'</span><span class="s1">)</span>
<span class="s3">class </span><span class="s1">Ref(Generic[T]): </span><span class="s3">pass</span>
<span class="s1">Array = Any</span>

<span class="s1">ReadEffect = state.ReadEffect</span>
<span class="s1">WriteEffect = state.WriteEffect</span>
<span class="s1">AccumEffect = state.AccumEffect</span>
<span class="s1">StateEffect = state.StateEffect</span>
<span class="s1">AbstractRef = state.AbstractRef</span>
<span class="s1">ref_set = state.ref_set</span>
<span class="s1">ref_get = state.ref_get</span>
<span class="s1">ref_addupdate = state.ref_addupdate</span>
<span class="s1">discharge_state = state.discharge_state</span>


<span class="s0">## `for_loop` implementation</span>

<span class="s1">for_p = core.Primitive(</span><span class="s4">'for'</span><span class="s1">)</span>
<span class="s1">for_p.multiple_results = </span><span class="s3">True</span>

<span class="s0">### Tracing utilities</span>

<span class="s3">def </span><span class="s1">_hoist_consts_to_refs(jaxpr: core.Jaxpr) -&gt; core.Jaxpr:</span>
  <span class="s1">all_const_avals = [var.aval </span><span class="s3">for </span><span class="s1">var </span><span class="s3">in </span><span class="s1">jaxpr.constvars]</span>
  <span class="s1">is_const_ref = [isinstance(var.aval</span><span class="s3">, </span><span class="s1">AbstractRef) </span><span class="s3">for </span><span class="s1">var </span><span class="s3">in</span>
                  <span class="s1">jaxpr.constvars]</span>
  <span class="s1">const_avals</span><span class="s3">, </span><span class="s1">const_ref_avals = partition_list(is_const_ref</span><span class="s3">, </span><span class="s1">all_const_avals)</span>
  <span class="s1">const_avals = map(AbstractRef</span><span class="s3">, </span><span class="s1">const_avals)</span>
  <span class="s1">merged_const_avals = merge_lists(is_const_ref</span><span class="s3">, </span><span class="s1">const_avals</span><span class="s3">, </span><span class="s1">const_ref_avals)</span>
  <span class="s1">i_aval</span><span class="s3">, </span><span class="s1">*arg_avals = [var.aval </span><span class="s3">for </span><span class="s1">var </span><span class="s3">in </span><span class="s1">jaxpr.invars]</span>
  <span class="s1">in_avals = [i_aval</span><span class="s3">, </span><span class="s1">*merged_const_avals</span><span class="s3">, </span><span class="s1">*arg_avals]</span>
  <span class="s1">num_consts = len(merged_const_avals)</span>

  <span class="s3">def </span><span class="s1">_hoist(i</span><span class="s3">, </span><span class="s1">*consts_args):</span>
    <span class="s1">all_consts</span><span class="s3">, </span><span class="s1">args = split_list(consts_args</span><span class="s3">, </span><span class="s1">[num_consts])</span>
    <span class="s1">consts</span><span class="s3">, </span><span class="s1">const_refs = partition_list(is_const_ref</span><span class="s3">, </span><span class="s1">all_consts)</span>
    <span class="s0"># We immediately read the const values out of the `Ref`s.</span>
    <span class="s1">consts = map(</span><span class="s3">lambda </span><span class="s1">x: ref_get(x</span><span class="s3">, </span><span class="s1">())</span><span class="s3">, </span><span class="s1">consts)</span>
    <span class="s1">all_consts = merge_lists(is_const_ref</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">, </span><span class="s1">const_refs)</span>
    <span class="s3">return </span><span class="s1">core.eval_jaxpr(jaxpr</span><span class="s3">, </span><span class="s1">all_consts</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">*args)</span>
  <span class="s1">hoisted_jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">lu.wrap_init(_hoist)</span><span class="s3">, </span><span class="s1">in_avals)</span>
  <span class="s3">assert not </span><span class="s1">consts</span><span class="s3">, </span><span class="s4">&quot;All consts should have been converted to refs&quot;</span>
  <span class="s3">return </span><span class="s1">hoisted_jaxpr</span>

<span class="s3">def </span><span class="s1">_trace_to_jaxpr_with_refs(f</span><span class="s3">, </span><span class="s1">state_tree: PyTreeDef</span><span class="s3">,</span>
                              <span class="s1">state_avals: Sequence[core.AbstractValue]</span>
                              <span class="s1">) -&gt; Tuple[core.Jaxpr</span><span class="s3">, </span><span class="s1">List[Any]</span><span class="s3">, </span><span class="s1">PyTreeDef]:</span>
  <span class="s1">f</span><span class="s3">, </span><span class="s1">out_tree_thunk = flatten_fun_nokwargs(</span>
      <span class="s1">lu.wrap_init(f)</span><span class="s3">, </span><span class="s1">treedef_tuple((tree_structure(</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">state_tree)))</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">f</span><span class="s3">, </span><span class="s1">state_avals)</span>
  <span class="s3">return </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">, </span><span class="s1">out_tree_thunk()</span>

<span class="s3">def </span><span class="s1">val_to_ref_aval(x) -&gt; AbstractRef:</span>
  <span class="s1">aval = core.raise_to_shaped(core.get_aval(x))</span>
  <span class="s3">if </span><span class="s1">type(aval) </span><span class="s3">is not </span><span class="s1">core.ShapedArray:</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">f&quot;can't make ref from </span><span class="s3">{</span><span class="s1">x</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">AbstractRef(aval)</span>

<span class="s3">def </span><span class="s1">for_loop(nsteps: Union[int</span><span class="s3">, </span><span class="s1">Sequence[int]]</span><span class="s3">,</span>
             <span class="s1">body: Callable[[Array</span><span class="s3">, </span><span class="s1">Ref[S]]</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">init_state: S</span><span class="s3">,</span>
             <span class="s1">*</span><span class="s3">, </span><span class="s1">reverse: bool = </span><span class="s3">False, </span><span class="s1">unroll: int = </span><span class="s5">1</span><span class="s1">) -&gt; S:</span>
  <span class="s2">&quot;&quot;&quot;A for-loop combinator that allows read/write semantics in the loop body. 
 
  `for_loop` is a higher-order function that enables writing loops that can be 
  staged out in JIT-ted JAX computations. Unlike `jax.lax.fori_loop`, it allows 
  mutation in its body using `Ref`s. 
 
  `for_loop` will initialize `Ref`s with the values in `init_state`. Each 
  iteration, `body` will be called with the current `Ref`s, which can be read 
  from and written to using `ref_get` and `ref_set`. 
 
  `for_loop` is semantically equivalent to the following Python code: 
 
  ```python 
  def for_loop(nsteps, body, init_state): 
    refs = tree_map(make_ref, init_state) 
    for i in range(nsteps): 
      body(i, refs) 
    return tree_map(ref_get, refs) 
  ``` 
 
  Args: 
    nsteps: Number of iterations 
    body: A callable that takes in the iteration number as its first argument 
      and `Ref`s corresponding to `init_state` as its second argument. 
      `body` is free to read from and write to its `Ref`s. `body` should 
       not return anything. 
    init_state: A Pytree of JAX-compatible values used to initialize the `Ref`s 
      that will be passed into the for loop body. 
    unroll: A positive int specifying, in the underlying operation of the 
      `for` primitive, how many iterations to unroll within a single iteration 
      of a loop. Higher values may speed up execution time at the cost of longer 
      compilation time. 
  Returns: 
    A Pytree of values representing the output of the for loop. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">unroll &lt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`unroll` must be a positive integer.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">isinstance(nsteps</span><span class="s3">, </span><span class="s1">int):</span>
    <span class="s1">nsteps = [nsteps]</span>
  <span class="s3">if </span><span class="s1">len(nsteps) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s1">outer_step</span><span class="s3">, </span><span class="s1">*rest_steps = nsteps</span>
    <span class="s3">def </span><span class="s1">wrapped_body(i</span><span class="s3">, </span><span class="s1">refs):</span>
      <span class="s1">vals = tree_map(</span><span class="s3">lambda </span><span class="s1">ref: state.ref_get(ref</span><span class="s3">, </span><span class="s1">())</span><span class="s3">, </span><span class="s1">refs)</span>
      <span class="s1">vals = for_loop(</span>
          <span class="s1">rest_steps</span><span class="s3">, </span><span class="s1">functools.partial(body</span><span class="s3">, </span><span class="s1">i)</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">, </span><span class="s1">unroll=unroll)</span>
      <span class="s1">tree_map(</span><span class="s3">lambda </span><span class="s1">ref</span><span class="s3">, </span><span class="s1">val: state.ref_set(ref</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">val)</span><span class="s3">, </span><span class="s1">refs</span><span class="s3">, </span><span class="s1">vals)</span>
    <span class="s3">return </span><span class="s1">for_loop(outer_step</span><span class="s3">, </span><span class="s1">wrapped_body</span><span class="s3">, </span><span class="s1">init_state</span><span class="s3">, </span><span class="s1">unroll=unroll)</span>
  <span class="s1">nsteps</span><span class="s3">, </span><span class="s1">= nsteps</span>
  <span class="s1">flat_state</span><span class="s3">, </span><span class="s1">state_tree = tree_flatten(init_state)</span>
  <span class="s1">state_avals = map(val_to_ref_aval</span><span class="s3">, </span><span class="s1">flat_state)</span>
  <span class="s1">idx_aval = core.ShapedArray(()</span><span class="s3">, </span><span class="s1">jnp.dtype(</span><span class="s4">&quot;int32&quot;</span><span class="s1">))</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">, </span><span class="s1">out_tree = _trace_to_jaxpr_with_refs(</span>
      <span class="s1">body</span><span class="s3">, </span><span class="s1">state_tree</span><span class="s3">, </span><span class="s1">[idx_aval</span><span class="s3">, </span><span class="s1">*state_avals])</span>
  <span class="s3">if </span><span class="s1">out_tree != tree_structure(</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;`body` should not return anything.&quot;</span><span class="s1">)</span>
  <span class="s0"># Remove constvars from jaxpr and turn them into `Ref`s</span>
  <span class="s1">jaxpr = _hoist_consts_to_refs(jaxpr)</span>
  <span class="s1">which_linear = (</span><span class="s3">False,</span><span class="s1">) * (len(consts) + len(flat_state))</span>
  <span class="s1">out_flat = for_p.bind(*consts</span><span class="s3">, </span><span class="s1">*flat_state</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr</span><span class="s3">, </span><span class="s1">nsteps=int(nsteps)</span><span class="s3">,</span>
                        <span class="s1">reverse=reverse</span><span class="s3">, </span><span class="s1">which_linear=which_linear</span><span class="s3">,</span>
                        <span class="s1">unroll=unroll)</span>
  <span class="s0"># Consts are `Ref`s so they are both inputs and outputs. We remove them from</span>
  <span class="s0"># the outputs.</span>
  <span class="s1">out_flat = out_flat[len(consts):]</span>
  <span class="s3">return </span><span class="s1">tree_unflatten(state_tree</span><span class="s3">, </span><span class="s1">out_flat)</span>

<span class="s1">Carry = TypeVar(</span><span class="s4">'Carry'</span><span class="s1">)</span>
<span class="s1">X = TypeVar(</span><span class="s4">'X'</span><span class="s1">)</span>
<span class="s1">Y = TypeVar(</span><span class="s4">'Y'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">scan(f: Callable[[Carry</span><span class="s3">, </span><span class="s1">X]</span><span class="s3">, </span><span class="s1">Tuple[Carry</span><span class="s3">, </span><span class="s1">Y]]</span><span class="s3">,</span>
         <span class="s1">init: Carry</span><span class="s3">,</span>
         <span class="s1">xs: X</span><span class="s3">,</span>
         <span class="s1">length: Optional[int] = </span><span class="s3">None,</span>
         <span class="s1">reverse: bool = </span><span class="s3">False,</span>
         <span class="s1">unroll: int = </span><span class="s5">1</span><span class="s1">) -&gt; Tuple[Carry</span><span class="s3">, </span><span class="s1">Y]:</span>
  <span class="s3">if not </span><span class="s1">callable(f):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;scan: f argument should be a callable.&quot;</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">unroll &lt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`unroll` must be a positive integer.&quot;</span><span class="s1">)</span>
  <span class="s1">xs_flat</span><span class="s3">, </span><span class="s1">xs_tree = tree_flatten(xs)</span>

  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">lengths = [x.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat]</span>
  <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err:</span>
    <span class="s1">msg = </span><span class="s4">&quot;scan got value with no leading axis to scan over: {}.&quot;</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span>
      <span class="s1">msg.format(</span><span class="s4">', '</span><span class="s1">.join(str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat</span>
                           <span class="s3">if not </span><span class="s1">hasattr(x</span><span class="s3">, </span><span class="s4">'shape'</span><span class="s1">)))) </span><span class="s3">from </span><span class="s1">err</span>

  <span class="s3">if </span><span class="s1">length </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">length = int(length)</span>
    <span class="s3">if not </span><span class="s1">all(length == l </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">lengths):</span>
      <span class="s1">msg = (</span><span class="s4">&quot;scan got `length` argument of {} which disagrees with &quot;</span>
             <span class="s4">&quot;leading axis sizes {}.&quot;</span><span class="s1">)</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(length</span><span class="s3">, </span><span class="s1">[x.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat]))</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">unique_lengths = set(lengths)</span>
    <span class="s3">if </span><span class="s1">len(unique_lengths) &gt; </span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">msg = </span><span class="s4">&quot;scan got values with different leading axis sizes: {}.&quot;</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg.format(</span><span class="s4">', '</span><span class="s1">.join(str(x.shape[</span><span class="s5">0</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat)))</span>
    <span class="s3">elif </span><span class="s1">len(unique_lengths) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">msg = </span><span class="s4">&quot;scan got no values to scan over and `length` not provided.&quot;</span>
      <span class="s3">raise </span><span class="s1">ValueError(msg)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">length</span><span class="s3">, </span><span class="s1">= unique_lengths</span>

  <span class="s1">x_shapes = [x.shape[</span><span class="s5">1</span><span class="s1">:] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat]</span>
  <span class="s1">x_dtypes = [dtypes.canonicalize_dtype(x.dtype) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xs_flat]</span>
  <span class="s1">x_avals = tuple(map(core.ShapedArray</span><span class="s3">, </span><span class="s1">x_shapes</span><span class="s3">, </span><span class="s1">x_dtypes))</span>

  <span class="s3">def </span><span class="s1">_create_jaxpr(init):</span>
    <span class="s1">init_flat = tree_leaves(init)</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">in_tree = tree_flatten((init</span><span class="s3">, </span><span class="s1">xs))</span>

    <span class="s1">carry_avals = tuple(map(_abstractify</span><span class="s3">, </span><span class="s1">init_flat))</span>
    <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">out_tree = _initial_style_jaxpr(</span>
        <span class="s1">f</span><span class="s3">, </span><span class="s1">in_tree</span><span class="s3">, </span><span class="s1">carry_avals + x_avals</span><span class="s3">, </span><span class="s4">&quot;scan&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">out_tree</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">out_tree = _create_jaxpr(init)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">ys_avals = tree_unflatten(out_tree</span><span class="s3">, </span><span class="s1">jaxpr.out_avals)</span>
  <span class="s1">ys = tree_map(</span><span class="s3">lambda </span><span class="s1">aval: jnp.zeros([length</span><span class="s3">, </span><span class="s1">*aval.shape]</span><span class="s3">, </span><span class="s1">aval.dtype)</span><span class="s3">,</span>
                <span class="s1">ys_avals)</span>
  <span class="s3">def </span><span class="s1">for_body(i</span><span class="s3">, </span><span class="s1">refs):</span>
    <span class="s1">carry_refs</span><span class="s3">, </span><span class="s1">xs_refs</span><span class="s3">, </span><span class="s1">ys_refs = refs</span>
    <span class="s1">carry = tree_map(</span><span class="s3">lambda </span><span class="s1">x: x[()]</span><span class="s3">, </span><span class="s1">carry_refs)</span>
    <span class="s1">x = tree_map(</span><span class="s3">lambda </span><span class="s1">x: x[i]</span><span class="s3">, </span><span class="s1">xs_refs)</span>
    <span class="s1">carry</span><span class="s3">, </span><span class="s1">y = f(carry</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">tree_map(</span><span class="s3">lambda </span><span class="s1">c_ref</span><span class="s3">, </span><span class="s1">c: ref_set(c_ref</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">c)</span><span class="s3">, </span><span class="s1">carry_refs</span><span class="s3">, </span><span class="s1">carry)</span>
    <span class="s1">tree_map(</span><span class="s3">lambda </span><span class="s1">y_ref</span><span class="s3">, </span><span class="s1">y: ref_set(y_ref</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">ys_refs</span><span class="s3">, </span><span class="s1">y)</span>
  <span class="s3">assert </span><span class="s1">isinstance(length</span><span class="s3">, </span><span class="s1">int)</span>
  <span class="s1">init</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">ys = for_loop(length</span><span class="s3">, </span><span class="s1">for_body</span><span class="s3">, </span><span class="s1">(init</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys)</span><span class="s3">, </span><span class="s1">reverse=reverse</span><span class="s3">,</span>
                         <span class="s1">unroll=unroll)</span>
  <span class="s3">return </span><span class="s1">init</span><span class="s3">, </span><span class="s1">ys</span>

<span class="s1">@for_p.def_effectful_abstract_eval</span>
<span class="s3">def </span><span class="s1">_for_abstract_eval(*avals</span><span class="s3">, </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">**__):</span>
  <span class="s0"># Find out for each of the `Ref`s in our jaxpr what effects they have.</span>
  <span class="s1">jaxpr_aval_effects = state.get_ref_state_effects(</span>
      <span class="s1">[v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">jaxpr.invars]</span><span class="s3">, </span><span class="s1">jaxpr.effects)[</span><span class="s5">1</span><span class="s1">:]</span>
  <span class="s1">aval_effects = [set(eff.replace(input_index=eff.input_index - </span><span class="s5">1</span><span class="s1">)</span>
                      <span class="s3">for </span><span class="s1">eff </span><span class="s3">in </span><span class="s1">effs) </span><span class="s3">for </span><span class="s1">aval</span><span class="s3">, </span><span class="s1">effs</span>
                  <span class="s3">in </span><span class="s1">zip(avals</span><span class="s3">, </span><span class="s1">jaxpr_aval_effects)</span>
                  <span class="s3">if </span><span class="s1">isinstance(aval</span><span class="s3">, </span><span class="s1">AbstractRef)]</span>
  <span class="s1">nonlocal_state_effects = core.join_effects(*aval_effects)</span>
  <span class="s3">return </span><span class="s1">list(avals)</span><span class="s3">, </span><span class="s1">nonlocal_state_effects</span>

<span class="s1">@state.register_discharge_rule(for_p)</span>
<span class="s3">def </span><span class="s1">_for_discharge_rule(in_avals</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">*args: Any</span><span class="s3">, </span><span class="s1">jaxpr: core.Jaxpr</span><span class="s3">,</span>
                        <span class="s1">reverse: bool</span><span class="s3">, </span><span class="s1">which_linear: Sequence[bool]</span><span class="s3">,</span>
                        <span class="s1">nsteps: int</span><span class="s3">, </span><span class="s1">unroll: int</span>
                        <span class="s1">) -&gt; Tuple[Sequence[Optional[Any]]</span><span class="s3">, </span><span class="s1">Sequence[Any]]:</span>
  <span class="s1">out_vals = for_p.bind(*args</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr</span><span class="s3">, </span><span class="s1">reverse=reverse</span><span class="s3">,</span>
                        <span class="s1">which_linear=which_linear</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                        <span class="s1">unroll=unroll)</span>
  <span class="s1">new_invals = []</span>
  <span class="s3">for </span><span class="s1">aval</span><span class="s3">, </span><span class="s1">out_val </span><span class="s3">in </span><span class="s1">zip(in_avals</span><span class="s3">, </span><span class="s1">out_vals):</span>
    <span class="s1">new_invals.append(out_val </span><span class="s3">if </span><span class="s1">isinstance(aval</span><span class="s3">, </span><span class="s1">AbstractRef) </span><span class="s3">else None</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">new_invals</span><span class="s3">, </span><span class="s1">out_vals</span>

<span class="s3">def </span><span class="s1">_for_impl(*args</span><span class="s3">, </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">, </span><span class="s1">which_linear</span><span class="s3">, </span><span class="s1">unroll):</span>
  <span class="s3">del </span><span class="s1">which_linear</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s3">def </span><span class="s1">body(i</span><span class="s3">, </span><span class="s1">state):</span>
    <span class="s1">i_ = nsteps - i - </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">reverse </span><span class="s3">else </span><span class="s1">i</span>
    <span class="s3">return </span><span class="s1">core.eval_jaxpr(discharged_jaxpr</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">, </span><span class="s1">i_</span><span class="s3">, </span><span class="s1">*state)</span>
  <span class="s3">return </span><span class="s1">_for_impl_unrolled(body</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">unroll</span><span class="s3">, </span><span class="s1">*args)</span>

<span class="s3">def </span><span class="s1">_for_impl_unrolled(body</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">unroll</span><span class="s3">, </span><span class="s1">*args):</span>
  <span class="s1">remainder = nsteps % unroll</span>
  <span class="s1">i = jnp.int32(</span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">state = list(args)</span>

  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(remainder):</span>
    <span class="s1">state = body(i</span><span class="s3">, </span><span class="s1">state)</span>
    <span class="s1">i = i + </span><span class="s5">1</span>

  <span class="s3">def </span><span class="s1">cond(carry):</span>
    <span class="s1">i</span><span class="s3">, </span><span class="s1">_ = carry</span>
    <span class="s3">return </span><span class="s1">i &lt; nsteps</span>
  <span class="s3">def </span><span class="s1">while_body(carry):</span>
    <span class="s1">i</span><span class="s3">, </span><span class="s1">state = carry</span>
    <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(unroll):</span>
      <span class="s1">state = body(i</span><span class="s3">, </span><span class="s1">state)</span>
      <span class="s1">i = i + </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">state</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">state = lax.while_loop(cond</span><span class="s3">, </span><span class="s1">while_body</span><span class="s3">, </span><span class="s1">(i</span><span class="s3">, </span><span class="s1">state))</span>
  <span class="s3">return </span><span class="s1">state</span>

<span class="s1">mlir.register_lowering(for_p</span><span class="s3">, </span><span class="s1">mlir.lower_fun(_for_impl</span><span class="s3">, </span><span class="s1">multiple_results=</span><span class="s3">True</span><span class="s1">))</span>
<span class="s1">for_p.def_impl(functools.partial(dispatch.apply_primitive</span><span class="s3">, </span><span class="s1">for_p))</span>

<span class="s3">def </span><span class="s1">_for_vmap(spmd_axis_name</span><span class="s3">, </span><span class="s1">axis_size</span><span class="s3">, </span><span class="s1">axis_name</span><span class="s3">, </span><span class="s1">main_type</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
              <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">, </span><span class="s1">which_linear</span><span class="s3">, </span><span class="s1">unroll):</span>
  <span class="s1">init_batched = [d </span><span class="s3">is not </span><span class="s1">batching.not_mapped </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">dims]</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">body_consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s1">batched = init_batched</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(len(batched)):</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">out_batched = batching.batch_jaxpr(</span>
        <span class="s1">core.ClosedJaxpr(discharged_jaxpr</span><span class="s3">, </span><span class="s1">body_consts)</span><span class="s3">,</span>
        <span class="s1">axis_size</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False</span><span class="s1">] + batched</span><span class="s3">, </span><span class="s1">instantiate=batched</span><span class="s3">,</span>
        <span class="s1">axis_name=axis_name</span><span class="s3">, </span><span class="s1">spmd_axis_name=spmd_axis_name</span><span class="s3">, </span><span class="s1">main_type=main_type)</span>
    <span class="s3">if </span><span class="s1">out_batched == batched:</span>
      <span class="s3">break</span>
    <span class="s1">batched = map(operator.or_</span><span class="s3">, </span><span class="s1">batched</span><span class="s3">, </span><span class="s1">out_batched)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Invalid fixpoint&quot;</span><span class="s1">)</span>
  <span class="s1">args = [batching.broadcast(x</span><span class="s3">, </span><span class="s1">axis_size</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s3">if </span><span class="s1">now_bat </span><span class="s3">and not </span><span class="s1">was_bat</span>
          <span class="s3">else </span><span class="s1">batching.moveaxis(x</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s3">if </span><span class="s1">now_bat </span><span class="s3">else </span><span class="s1">x</span>
          <span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">was_bat</span><span class="s3">, </span><span class="s1">now_bat </span><span class="s3">in </span><span class="s1">zip(args</span><span class="s3">, </span><span class="s1">dims</span><span class="s3">, </span><span class="s1">init_batched</span><span class="s3">, </span><span class="s1">batched)]</span>
  <span class="s1">batched_jaxpr_</span><span class="s3">, </span><span class="s1">_ = batching.batch_jaxpr(</span>
      <span class="s1">core.ClosedJaxpr(jaxpr</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">, </span><span class="s1">axis_size</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False</span><span class="s1">] + batched</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">,</span>
      <span class="s1">axis_name=axis_name</span><span class="s3">, </span><span class="s1">spmd_axis_name=spmd_axis_name</span><span class="s3">, </span><span class="s1">main_type=main_type)</span>
  <span class="s1">batched_jaxpr</span><span class="s3">, </span><span class="s1">() = batched_jaxpr_.jaxpr</span><span class="s3">, </span><span class="s1">batched_jaxpr_.consts  </span><span class="s0"># TODO consts</span>
  <span class="s1">out_flat = for_p.bind(*args</span><span class="s3">, </span><span class="s1">jaxpr=batched_jaxpr</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                        <span class="s1">reverse=reverse</span><span class="s3">, </span><span class="s1">which_linear=which_linear</span><span class="s3">,</span>
                        <span class="s1">unroll=unroll)</span>
  <span class="s3">return </span><span class="s1">out_flat</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0 </span><span class="s3">if </span><span class="s1">b </span><span class="s3">else </span><span class="s1">batching.not_mapped </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">batched]</span>
<span class="s1">batching.axis_primitive_batchers[for_p] = functools.partial(_for_vmap</span><span class="s3">, None</span><span class="s1">)</span>
<span class="s1">batching.spmd_axis_primitive_batchers[for_p] = _for_vmap</span>

<span class="s3">def </span><span class="s1">_for_jvp(primals</span><span class="s3">, </span><span class="s1">tangents</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">, </span><span class="s1">which_linear</span><span class="s3">,</span>
             <span class="s1">unroll):</span>
  <span class="s1">nonzero_tangents = [</span><span class="s3">not </span><span class="s1">isinstance(t</span><span class="s3">, </span><span class="s1">ad_util.Zero) </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tangents]</span>
  <span class="s0"># We need to find out which `Ref`s have nonzero tangents after running the</span>
  <span class="s0"># for loop. Ordinarily we do this with a fixed point on the body jaxpr but</span>
  <span class="s0"># a `for` body jaxpr is stateful and has no outputs. We therefore discharge</span>
  <span class="s0"># the state effect from the jaxpr and we will now have a &quot;symmetric&quot; jaxpr</span>
  <span class="s0"># where the inputs line up with the outputs. We use this discharged jaxpr</span>
  <span class="s0"># for the fixed point.</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">body_consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(len(nonzero_tangents)):</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">out_nonzero_tangents = ad.jvp_jaxpr(</span>
        <span class="s1">core.ClosedJaxpr(discharged_jaxpr</span><span class="s3">, </span><span class="s1">body_consts)</span><span class="s3">,</span>
        <span class="s1">[</span><span class="s3">False</span><span class="s1">] + nonzero_tangents</span><span class="s3">, </span><span class="s1">instantiate=nonzero_tangents)</span>
    <span class="s3">if </span><span class="s1">out_nonzero_tangents == nonzero_tangents:</span>
      <span class="s3">break</span>
    <span class="s1">nonzero_tangents = map(operator.or_</span><span class="s3">, </span><span class="s1">nonzero_tangents</span><span class="s3">, </span><span class="s1">out_nonzero_tangents)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Invalid fixpoint&quot;</span><span class="s1">)</span>
  <span class="s1">tangents = [ad.instantiate_zeros(t) </span><span class="s3">if </span><span class="s1">inst </span><span class="s3">else </span><span class="s1">t</span>
              <span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">inst </span><span class="s3">in </span><span class="s1">zip(tangents</span><span class="s3">, </span><span class="s1">nonzero_tangents)]</span>
  <span class="s1">tangents = [t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tangents </span><span class="s3">if </span><span class="s1">type(t) </span><span class="s3">is not </span><span class="s1">ad_util.Zero]</span>
  <span class="s1">closed_jaxpr = core.ClosedJaxpr(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s1">jvp_jaxpr_</span><span class="s3">, </span><span class="s1">_ = ad.jvp_jaxpr(closed_jaxpr</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False</span><span class="s1">] + nonzero_tangents</span><span class="s3">, </span><span class="s1">[])</span>
  <span class="s1">jvp_jaxpr</span><span class="s3">, </span><span class="s1">() = jvp_jaxpr_.jaxpr</span><span class="s3">, </span><span class="s1">jvp_jaxpr_.consts  </span><span class="s0"># TODO consts</span>
  <span class="s1">jvp_which_linear = which_linear + (</span><span class="s3">True,</span><span class="s1">) * len(tangents)</span>
  <span class="s1">out_flat = for_p.bind(*primals</span><span class="s3">, </span><span class="s1">*tangents</span><span class="s3">, </span><span class="s1">jaxpr=jvp_jaxpr</span><span class="s3">,</span>
                        <span class="s1">nsteps=nsteps</span><span class="s3">, </span><span class="s1">reverse=reverse</span><span class="s3">,</span>
                        <span class="s1">which_linear=jvp_which_linear</span><span class="s3">, </span><span class="s1">unroll=unroll)</span>
  <span class="s0"># `out_flat` includes constant inputs into the `for_loop` which are converted</span>
  <span class="s0"># into outputs as well. We don't care about these in AD so we throw them out.</span>
  <span class="s1">out_primals</span><span class="s3">, </span><span class="s1">out_tangents = split_list(out_flat</span><span class="s3">, </span><span class="s1">[len(primals)])</span>
  <span class="s1">out_tangents_iter = iter(out_tangents)</span>
  <span class="s1">out_tangents = [next(out_tangents_iter) </span><span class="s3">if </span><span class="s1">nz </span><span class="s3">else </span><span class="s1">ad_util.Zero.from_value(p)</span>
                  <span class="s3">for </span><span class="s1">p</span><span class="s3">, </span><span class="s1">nz </span><span class="s3">in </span><span class="s1">zip(out_primals</span><span class="s3">, </span><span class="s1">nonzero_tangents)]</span>
  <span class="s3">return </span><span class="s1">out_primals</span><span class="s3">, </span><span class="s1">out_tangents</span>
<span class="s1">ad.primitive_jvps[for_p] = _for_jvp</span>


<span class="s3">def </span><span class="s1">_partial_eval_jaxpr_custom(jaxpr</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">policy):</span>
  <span class="s0"># A simple wrapper around `pe.partial_eval_jaxpr_custom` that assumes all</span>
  <span class="s0"># inputs are instantiated and doesn't ensure any outputs are unknown or</span>
  <span class="s0"># instantiated.</span>
  <span class="s3">return </span><span class="s1">pe.partial_eval_jaxpr_custom(</span>
      <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * len(in_unknowns)</span><span class="s3">, False, False, </span><span class="s1">policy)</span>

<span class="s1">_save_everything = </span><span class="s3">lambda </span><span class="s1">*_</span><span class="s3">, </span><span class="s1">**__: </span><span class="s3">True</span>

<span class="s3">def </span><span class="s1">_is_read_only(ref_effects: Set[StateEffect]) -&gt; bool:</span>
  <span class="s3">assert </span><span class="s1">len(ref_effects) &gt; </span><span class="s5">0</span>
  <span class="s3">if </span><span class="s1">len(ref_effects) &gt; </span><span class="s5">1</span><span class="s1">:</span>
    <span class="s0"># Means we must have a write or accum effect so not read-only</span>
    <span class="s3">return False</span>
  <span class="s1">eff</span><span class="s3">, </span><span class="s1">= ref_effects</span>
  <span class="s3">return </span><span class="s1">isinstance(eff</span><span class="s3">, </span><span class="s1">ReadEffect)</span>

<span class="s3">def </span><span class="s1">_loop_invariant_outputs(jaxpr: core.Jaxpr) -&gt; List[bool]:</span>
  <span class="s0"># Get effects for each of the jaxpr inputs and remove the loop index.</span>
  <span class="s1">ref_effects = state.get_ref_state_effects(</span>
      <span class="s1">[v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">jaxpr.invars]</span><span class="s3">, </span><span class="s1">jaxpr.effects)[</span><span class="s5">1</span><span class="s1">:]</span>
  <span class="s0"># We first assume that *read-only `Ref`s* are loop-invariant. We can safely do</span>
  <span class="s0"># this because the only way something can be loop-varying is if we write to it</span>
  <span class="s0"># at some point. It's *possible* that read-write `Ref`s are loop-invariant but</span>
  <span class="s0"># we conservatively assume they aren't.</span>
  <span class="s1">loop_invar_refs = [_is_read_only(effs) </span><span class="s3">if </span><span class="s1">effs </span><span class="s3">else True</span>
                     <span class="s3">for </span><span class="s1">effs </span><span class="s3">in </span><span class="s1">ref_effects]</span>
  <span class="s1">loop_var_refs = map(operator.not_</span><span class="s3">, </span><span class="s1">loop_invar_refs)</span>

  <span class="s0"># We'd like to detect if the outputs of the jaxpr are loop-invariant. An</span>
  <span class="s0"># output is loop-invariant if it is downstream of only loop-invariant values</span>
  <span class="s0"># (seeded by the read-only `Ref`s). If at any point, a loop-varying value</span>
  <span class="s0"># interacts with a loop-invariant value, we produce a loop-varying value. We</span>
  <span class="s0"># can use `partial_eval` to perform this analysis by treating loop-varying</span>
  <span class="s0"># values as &quot;unknown&quot; and loop-invariant values as &quot;known&quot;, since when a known</span>
  <span class="s0"># and unknown value interact, they produce an unknown value.</span>
  <span class="s1">loop_var_inputs = [</span><span class="s3">True, </span><span class="s1">*loop_var_refs]</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">loop_var_outputs</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">= _partial_eval_jaxpr_custom(</span>
      <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">loop_var_inputs</span><span class="s3">, </span><span class="s1">_save_everything)</span>
  <span class="s3">return </span><span class="s1">map(operator.not_</span><span class="s3">, </span><span class="s1">loop_var_outputs)</span>


<span class="s3">def </span><span class="s1">_for_partial_eval(trace: pe.JaxprTrace</span><span class="s3">, </span><span class="s1">*tracers: pe.JaxprTracer</span><span class="s3">,</span>
                      <span class="s1">jaxpr: core.Jaxpr</span><span class="s3">, </span><span class="s1">nsteps: int</span><span class="s3">, </span><span class="s1">reverse: bool</span><span class="s3">,</span>
                      <span class="s1">which_linear: Tuple[bool</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">,</span>
                      <span class="s1">unroll: int) -&gt; List[pe.JaxprTracer]:</span>
  <span class="s1">num_inputs = len(tracers)</span>
  <span class="s3">assert </span><span class="s1">num_inputs == len(jaxpr.invars) - </span><span class="s5">1</span>
  <span class="s1">in_unknowns = [</span><span class="s3">not </span><span class="s1">t.pval.is_known() </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tracers]</span>
  <span class="s0"># We first need to run a fixpoint to determine which of the `Ref`s are unknown</span>
  <span class="s0"># after running the for loop. We want to use the jaxpr to determine which</span>
  <span class="s0"># `Ref`s are unknown after executing the for loop body given which `Ref`s are</span>
  <span class="s0"># unknown before. However, the jaxpr has no outputs. Instead, we discharge</span>
  <span class="s0"># the body and run the fixpoint with the discharged jaxpr. We can do this</span>
  <span class="s0"># because the outputs of the jaxpr are one-to-one with the inputs.</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">discharged_consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s1">discharged_jaxpr = discharged_jaxpr.replace(</span>
      <span class="s1">invars=discharged_jaxpr.constvars + discharged_jaxpr.invars</span><span class="s3">,</span>
      <span class="s1">constvars=[])</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(num_inputs):</span>
    <span class="s1">jaxpr_in_unknowns = [</span><span class="s3">False</span><span class="s1">] * len(discharged_consts) + [</span><span class="s3">False, </span><span class="s1">*in_unknowns]</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">out_unknowns</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">= pe.partial_eval_jaxpr_custom(</span>
        <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">jaxpr_in_unknowns</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * len(jaxpr_in_unknowns)</span><span class="s3">,</span>
          <span class="s1">in_unknowns</span><span class="s3">, False, </span><span class="s1">_save_everything)</span>
    <span class="s1">out_unknowns = list(out_unknowns)</span>
    <span class="s3">if </span><span class="s1">out_unknowns == in_unknowns:</span>
      <span class="s3">break</span>
    <span class="s1">in_unknowns = map(operator.or_</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">out_unknowns)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Invalid fixpoint&quot;</span><span class="s1">)</span>
  <span class="s3">del </span><span class="s1">out_unknowns  </span><span class="s0"># redundant since it's the same as `in_unknowns`</span>
  <span class="s1">tracers = tuple(trace.instantiate_const(t) </span><span class="s3">if </span><span class="s1">uk </span><span class="s3">else </span><span class="s1">t  </span><span class="s0"># type: ignore</span>
                  <span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">uk </span><span class="s3">in </span><span class="s1">zip(tracers</span><span class="s3">, </span><span class="s1">in_unknowns))</span>

  <span class="s0"># We use `partial_eval_jaxpr_custom` here because it won't remove effectful</span>
  <span class="s0"># primitives like `get`/`set`.</span>
  <span class="s1">jaxpr_known_resout</span><span class="s3">, </span><span class="s1">jaxpr_unknown_resin_</span><span class="s3">, </span><span class="s1">uk_out</span><span class="s3">, </span><span class="s1">inst_out</span><span class="s3">, </span><span class="s1">num_res = \</span>
        <span class="s1">_partial_eval_jaxpr_custom(jaxpr</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False, </span><span class="s1">*in_unknowns]</span><span class="s3">,</span>
                                   <span class="s1">_save_everything)</span>
  <span class="s0"># # `partial_eval_jaxpr_custom` will give us jaxprs that have hybrid `Ref` and</span>
  <span class="s0"># regular valued input/outputs. However, we'd like to bind these jaxprs to a</span>
  <span class="s0"># `for`, which expects only `Ref` inputs and no output. We need to convert</span>
  <span class="s0"># both of these jaxprs into ones that are compatible with `for`.</span>
  <span class="s0"># TODO(sharadmv,mattjj): implement &quot;passthrough&quot; optimization.</span>
  <span class="s0"># TODO(sharadmv,mattjj): rematerialize loop-dependent values instead of</span>
  <span class="s0"># passing the loop index as a residual</span>

  <span class="s0"># `jaxpr_known_resout` is a jaxpr that maps from all the input `Refs`</span>
  <span class="s0"># to output residual values (none of them should be `Ref`s). We'll need to</span>
  <span class="s0"># convert the output residual values into `Ref`s that are initially empty</span>
  <span class="s0"># `Ref`s that are written to at the end of the jaxpr.</span>

  <span class="s0"># # Loop-invariant residual optimization</span>
  <span class="s0"># Here we are interested in finding out which of the residuals are *not*</span>
  <span class="s0"># dependent on the loop index. If a residual is not dependent on the loop</span>
  <span class="s0"># index, we don't need add an extra loop dimension we're reading from when we</span>
  <span class="s0"># convert it from an output into a write.</span>
  <span class="s1">loop_invar_res = _loop_invariant_outputs(jaxpr_known_resout)</span>

  <span class="s1">jaxpr_known</span><span class="s3">, </span><span class="s1">res_avals = _convert_outputs_to_writes(nsteps</span><span class="s3">,</span>
                                                      <span class="s1">jaxpr_known_resout</span><span class="s3">,</span>
                                                      <span class="s1">loop_invar_res)</span>
  <span class="s0"># We now run the known jaxpr to obtain our residual values.</span>
  <span class="s1">known_tracers</span><span class="s3">, </span><span class="s1">_ = partition_list(in_unknowns</span><span class="s3">, </span><span class="s1">tracers)</span>
  <span class="s1">known_vals = [t.pval.get_known() </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">known_tracers]</span>
  <span class="s1">empty_res = map(ad_util.zeros_like_aval</span><span class="s3">, </span><span class="s1">res_avals)</span>
  <span class="s1">jaxpr_known_args = [*known_vals</span><span class="s3">, </span><span class="s1">*empty_res]</span>
  <span class="s0"># We assume the known inputs are nonlinear which is okay to do for AD but not</span>
  <span class="s0"># necessarily okay for general partial eval.</span>
  <span class="s1">jaxpr_known_which_linear = (</span><span class="s3">False,</span><span class="s1">) * len(jaxpr_known_args)</span>
  <span class="s1">out_flat = for_p.bind(*jaxpr_known_args</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr_known</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                        <span class="s1">reverse=reverse</span><span class="s3">, </span><span class="s1">which_linear=jaxpr_known_which_linear</span><span class="s3">,</span>
                        <span class="s1">unroll=unroll)</span>
  <span class="s1">known_outputs</span><span class="s3">, </span><span class="s1">residuals = split_list(out_flat</span><span class="s3">, </span><span class="s1">[len(known_tracers)])</span>
  <span class="s1">residuals = map(trace.new_instantiated_const</span><span class="s3">, </span><span class="s1">residuals)</span>

  <span class="s0"># Now we handle the `jaxpr_unknown` that expects residual values as inputs.</span>
  <span class="s0"># This jaxpr is the output of `partial_eval_jaxpr_custom` that marks which</span>
  <span class="s0"># inputs are actually used.</span>
  <span class="s0"># `partial_eval_jaxpr_custom` doesn't remove extra inputs/outputs for you</span>
  <span class="s0"># so we use `dce_jaxpr` here to do that.</span>
  <span class="s1">jaxpr_unknown_resin</span><span class="s3">, </span><span class="s1">used_inputs = pe.dce_jaxpr(</span>
        <span class="s1">jaxpr_unknown_resin_</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * num_res + [</span><span class="s3">True, </span><span class="s1">*in_unknowns])</span>
  <span class="s1">used_res</span><span class="s3">, </span><span class="s1">(used_i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">used_refs = split_list(used_inputs</span><span class="s3">, </span><span class="s1">[num_res</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
  <span class="s3">assert </span><span class="s1">all(used_res)</span><span class="s3">, </span><span class="s4">&quot;All residuals should be used&quot;</span>
  <span class="s0"># To make it compatible with `for`, we need to convert those residual values</span>
  <span class="s0"># into `Ref`s.</span>
  <span class="s1">jaxpr_unknown = _convert_inputs_to_reads(nsteps</span><span class="s3">, </span><span class="s1">len(res_avals)</span><span class="s3">,</span>
                                           <span class="s1">jaxpr_unknown_resin</span><span class="s3">,</span>
                                           <span class="s1">loop_invar_res)</span>
  <span class="s0"># Since not all inputs are used in jaxpr_unknown, we filter the input tracers</span>
  <span class="s0"># down using the output of `dce_jaxpr`.</span>
  <span class="s1">used_and_known = map(operator.and_</span><span class="s3">, </span><span class="s1">used_refs</span><span class="s3">, </span><span class="s1">map(operator.not_</span><span class="s3">, </span><span class="s1">in_unknowns))</span>
  <span class="s1">tracers = [trace.instantiate_const(t) </span><span class="s3">if </span><span class="s1">u_and_k </span><span class="s3">else </span><span class="s1">t </span><span class="s3">for </span><span class="s1">t</span><span class="s3">, </span><span class="s1">u_and_k  </span><span class="s0"># type: ignore</span>
             <span class="s3">in </span><span class="s1">zip(tracers</span><span class="s3">, </span><span class="s1">used_and_known)]</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">known_used = partition_list(used_refs</span><span class="s3">, </span><span class="s1">used_and_known)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">used_tracers = partition_list(used_refs</span><span class="s3">, </span><span class="s1">tracers)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">used_which_linear = partition_list(used_refs</span><span class="s3">, </span><span class="s1">which_linear)</span>
  <span class="s1">which_linear_unknown = (</span><span class="s3">False,</span><span class="s1">) * num_res + tuple(used_which_linear)</span>
  <span class="s1">unknown_inputs = [*residuals</span><span class="s3">, </span><span class="s1">*used_tracers]</span>
  <span class="s0"># Outputs match inputs so we construct output tracers that look like the input</span>
  <span class="s0"># tracers.</span>
  <span class="s1">res_ref_unknown_outputs = [</span>
      <span class="s1">pe.JaxprTracer(trace</span><span class="s3">, </span><span class="s1">pe.PartialVal.unknown(t.aval)</span><span class="s3">, None</span><span class="s1">)</span>
      <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">unknown_inputs]</span>
  <span class="s1">name_stack = source_info_util.current_name_stack()[len(trace.name_stack):]</span>
  <span class="s1">source = source_info_util.current().replace(name_stack=name_stack)</span>

  <span class="s3">assert </span><span class="s1">len(unknown_inputs) == len(res_ref_unknown_outputs)</span>
  <span class="s3">assert </span><span class="s1">len(unknown_inputs) == len(jaxpr_unknown.invars) - </span><span class="s5">1</span>
  <span class="s1">eqn = pe.new_eqn_recipe(unknown_inputs</span><span class="s3">, </span><span class="s1">res_ref_unknown_outputs</span><span class="s3">,</span>
                          <span class="s1">for_p</span><span class="s3">, </span><span class="s1">dict(jaxpr=jaxpr_unknown</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                                      <span class="s1">reverse=reverse</span><span class="s3">,</span>
                                      <span class="s1">which_linear=which_linear_unknown</span><span class="s3">,</span>
                                      <span class="s1">unroll=unroll)</span><span class="s3">,</span>
                          <span class="s1">core.no_effects</span><span class="s3">, </span><span class="s1">source)</span>
  <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">res_ref_unknown_outputs: t.recipe = eqn</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">unknown_outputs = split_list(res_ref_unknown_outputs</span><span class="s3">, </span><span class="s1">[num_res])</span>
  <span class="s1">unknown_outputs</span><span class="s3">, </span><span class="s1">_ = partition_list(known_used</span><span class="s3">, </span><span class="s1">unknown_outputs)</span>
  <span class="s3">return </span><span class="s1">merge_lists(in_unknowns</span><span class="s3">, </span><span class="s1">known_outputs</span><span class="s3">, </span><span class="s1">unknown_outputs)</span>
<span class="s1">pe.custom_partial_eval_rules[for_p] = _for_partial_eval</span>

<span class="s3">def </span><span class="s1">_for_partial_eval_custom(saveable</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">in_inst</span><span class="s3">, </span><span class="s1">eqn):</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">, </span><span class="s1">which_linear</span><span class="s3">, </span><span class="s1">unroll = split_dict(</span>
      <span class="s1">eqn.params</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;jaxpr&quot;</span><span class="s3">, </span><span class="s4">&quot;nsteps&quot;</span><span class="s3">, </span><span class="s4">&quot;reverse&quot;</span><span class="s3">, </span><span class="s4">&quot;which_linear&quot;</span><span class="s3">, </span><span class="s4">&quot;unroll&quot;</span><span class="s1">])</span>
  <span class="s1">num_inputs = len(eqn.invars)</span>
  <span class="s0"># We first need to run a fixpoint to determine which of the `Ref`s are unknown</span>
  <span class="s0"># after running the for loop. However, the jaxpr has no outputs. Instead, we</span>
  <span class="s0"># discharge the body and run the fixpoint with the discharged jaxpr. We can do</span>
  <span class="s0"># this because the outputs of the discharged jaxpr are one-to-one with the</span>
  <span class="s0"># inputs.</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">discharged_consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">())</span>
  <span class="s1">discharged_jaxpr = discharged_jaxpr.replace(</span>
      <span class="s1">invars=discharged_jaxpr.constvars + discharged_jaxpr.invars</span><span class="s3">,</span>
      <span class="s1">constvars=[])</span>
  <span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">in_inst = list(in_unknowns)</span><span class="s3">, </span><span class="s1">list(in_inst)</span>
  <span class="s1">out_unknowns</span><span class="s3">, </span><span class="s1">out_inst =  in_unknowns</span><span class="s3">, </span><span class="s1">in_inst</span>
  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(num_inputs):</span>
    <span class="s1">jaxpr_in_unknowns = [</span><span class="s3">False</span><span class="s1">] * len(discharged_consts) + [</span><span class="s3">False, </span><span class="s1">*in_unknowns]</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">out_unknowns</span><span class="s3">, </span><span class="s1">out_inst</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">= pe.partial_eval_jaxpr_custom(</span>
        <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">jaxpr_in_unknowns</span><span class="s3">, True,</span>
          <span class="s1">ensure_out_unknowns=in_unknowns</span><span class="s3">, </span><span class="s1">ensure_out_inst=</span><span class="s3">True,</span>
          <span class="s1">saveable=saveable)</span>
    <span class="s1">out_unknowns = list(out_unknowns)</span>
    <span class="s3">if </span><span class="s1">out_unknowns == in_unknowns:</span>
      <span class="s3">break</span>
    <span class="s1">in_unknowns = map(operator.or_</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">out_unknowns)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">num_inputs &gt; </span><span class="s5">0</span><span class="s1">: </span><span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Invalid fixpoint&quot;</span><span class="s1">)</span>
  <span class="s3">del </span><span class="s1">out_unknowns </span><span class="s0"># Redundant since it's the same as `in_unknowns`</span>
  <span class="s1">new_inst = [x </span><span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">inst </span><span class="s3">in </span><span class="s1">zip(eqn.invars</span><span class="s3">, </span><span class="s1">in_inst)</span>
              <span class="s3">if </span><span class="s1">type(x) </span><span class="s3">is </span><span class="s1">core.Var </span><span class="s3">and not </span><span class="s1">inst]</span>
  <span class="s1">in_inst = [</span><span class="s3">True</span><span class="s1">] * len(eqn.invars)</span>

  <span class="s0"># We use `partial_eval_jaxpr_custom` here because it won't remove effectful</span>
  <span class="s0"># primitives like `get`/`set`.</span>
  <span class="s1">jaxpr_known_resout</span><span class="s3">, </span><span class="s1">jaxpr_staged_resin_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">num_res = \</span>
        <span class="s1">pe.partial_eval_jaxpr_custom(jaxpr</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False, </span><span class="s1">*in_unknowns]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s3">True, </span><span class="s1">*in_inst]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">saveable)</span>

  <span class="s0"># `partial_eval_jaxpr_custom` will give us jaxprs that have hybrid `Ref` and</span>
  <span class="s0"># non-Ref input/outputs. However, we'd like to bind these jaxprs to a</span>
  <span class="s0"># `for`, which expects only `Ref` inputs and no output. We need to convert</span>
  <span class="s0"># both of these jaxprs into ones that are compatible with `for`.</span>
  <span class="s0"># TODO(sharadmv,mattjj): implement &quot;passthrough&quot; optimization.</span>
  <span class="s0"># TODO(sharadmv,mattjj): rematerialize loop-dependent values instead of</span>
  <span class="s0"># passing the loop index as a residual</span>

  <span class="s0"># `jaxpr_known_resout` is a jaxpr that maps from all the input `Refs`</span>
  <span class="s0"># to output residual values (none of them should be `Ref`s). We'll need to</span>
  <span class="s0"># convert the output residual values into `Ref`s that are initially empty</span>
  <span class="s0"># `Ref`s that are written to at the end of the jaxpr.</span>

  <span class="s0"># # Loop-invariant residual optimization</span>
  <span class="s0"># Here we are interested in finding out which of the residuals are *not*</span>
  <span class="s0"># dependent on the loop index. If a residual is not dependent on the loop</span>
  <span class="s0"># index, we don't need add an extra loop dimension we're reading from when we</span>
  <span class="s0"># convert it from an output into a write.</span>
  <span class="s1">loop_invar_res = _loop_invariant_outputs(jaxpr_known_resout)</span>

  <span class="s1">jaxpr_known</span><span class="s3">, </span><span class="s1">res_avals = _convert_outputs_to_writes(nsteps</span><span class="s3">,</span>
                                                      <span class="s1">jaxpr_known_resout</span><span class="s3">,</span>
                                                      <span class="s1">loop_invar_res)</span>

  <span class="s1">known_invars</span><span class="s3">, </span><span class="s1">_ = partition_list(in_unknowns</span><span class="s3">, </span><span class="s1">eqn.invars)</span>
  <span class="s1">known_outvars</span><span class="s3">, </span><span class="s1">_ = partition_list(in_unknowns</span><span class="s3">, </span><span class="s1">eqn.outvars)</span>
  <span class="s1">newvar = core.gensym()</span>
  <span class="s1">resvars = map(newvar</span><span class="s3">, </span><span class="s1">res_avals)</span>

  <span class="s1">@lu.wrap_init</span>
  <span class="s3">def </span><span class="s1">known(*known_vals):</span>
    <span class="s1">empty_res = map(ad_util.zeros_like_aval</span><span class="s3">, </span><span class="s1">res_avals)</span>
    <span class="s1">jaxpr_known_args = [*known_vals</span><span class="s3">, </span><span class="s1">*empty_res]</span>
    <span class="s1">jaxpr_known_which_linear = (</span><span class="s3">False,</span><span class="s1">) * len(jaxpr_known_args)</span>
    <span class="s3">return </span><span class="s1">for_p.bind(*jaxpr_known_args</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr_known</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                      <span class="s1">reverse=reverse</span><span class="s3">, </span><span class="s1">which_linear=jaxpr_known_which_linear</span><span class="s3">,</span>
                      <span class="s1">unroll=unroll)</span>
  <span class="s1">call_jaxpr_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">call_jaxpr_consts = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">known</span><span class="s3">, </span><span class="s1">[v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">known_invars])</span>
  <span class="s1">call_jaxpr = core.ClosedJaxpr(call_jaxpr_</span><span class="s3">, </span><span class="s1">call_jaxpr_consts)</span>
  <span class="s1">eqn_known = pe.new_jaxpr_eqn(known_invars</span><span class="s3">, </span><span class="s1">[*known_outvars</span><span class="s3">, </span><span class="s1">*resvars]</span><span class="s3">,</span>
                               <span class="s1">core.closed_call_p</span><span class="s3">, </span><span class="s1">dict(call_jaxpr=call_jaxpr)</span><span class="s3">,</span>
                               <span class="s1">call_jaxpr.effects</span><span class="s3">, </span><span class="s1">eqn.source_info)</span>

  <span class="s1">jaxpr_staged = _convert_inputs_to_reads(nsteps</span><span class="s3">, </span><span class="s1">len(res_avals)</span><span class="s3">,</span>
                                          <span class="s1">jaxpr_staged_resin_</span><span class="s3">,</span>
                                          <span class="s1">loop_invar_res)</span>
  <span class="s1">which_linear_unknown = (</span><span class="s3">False,</span><span class="s1">) * num_res + tuple(which_linear)</span>
  <span class="s1">params_staged = dict(eqn.params</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr_staged</span><span class="s3">, </span><span class="s1">reverse=reverse</span><span class="s3">,</span>
                                   <span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                                   <span class="s1">which_linear=which_linear_unknown</span><span class="s3">,</span>
                                   <span class="s1">unroll=unroll)</span>

  <span class="s1">@lu.wrap_init</span>
  <span class="s3">def </span><span class="s1">staged(*res_and_refs):</span>
    <span class="s1">out_flat = for_p.bind(*res_and_refs</span><span class="s3">, </span><span class="s1">**params_staged)</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">ans = split_list(out_flat</span><span class="s3">, </span><span class="s1">[num_res])</span>
    <span class="s1">_</span><span class="s3">, </span><span class="s1">ans = partition_list(out_inst</span><span class="s3">, </span><span class="s1">ans)</span>
    <span class="s3">return </span><span class="s1">ans</span>
  <span class="s1">call_jaxpr_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">call_jaxpr_consts = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">staged</span><span class="s3">, </span><span class="s1">[v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">[*resvars</span><span class="s3">, </span><span class="s1">*eqn.invars]])</span>
  <span class="s3">assert </span><span class="s1">len(jaxpr_staged.invars) - </span><span class="s5">1 </span><span class="s1">== len(call_jaxpr_.invars)</span>
  <span class="s1">call_jaxpr = core.ClosedJaxpr(call_jaxpr_</span><span class="s3">, </span><span class="s1">call_jaxpr_consts)</span>
  <span class="s1">_</span><span class="s3">, </span><span class="s1">outvars = partition_list(out_inst</span><span class="s3">, </span><span class="s1">eqn.outvars)</span>
  <span class="s1">eqn_staged = pe.new_jaxpr_eqn([*resvars</span><span class="s3">, </span><span class="s1">*eqn.invars]</span><span class="s3">, </span><span class="s1">outvars</span><span class="s3">,</span>
                               <span class="s1">core.closed_call_p</span><span class="s3">, </span><span class="s1">dict(call_jaxpr=call_jaxpr)</span><span class="s3">,</span>
                               <span class="s1">call_jaxpr.effects</span><span class="s3">, </span><span class="s1">eqn.source_info)</span>
  <span class="s1">new_vars = [*new_inst</span><span class="s3">, </span><span class="s1">*resvars]</span>
  <span class="s3">return </span><span class="s1">eqn_known</span><span class="s3">, </span><span class="s1">eqn_staged</span><span class="s3">, </span><span class="s1">in_unknowns</span><span class="s3">, </span><span class="s1">out_inst</span><span class="s3">, </span><span class="s1">new_vars</span>

<span class="s1">pe.partial_eval_jaxpr_custom_rules[for_p] = _for_partial_eval_custom</span>

<span class="s3">def </span><span class="s1">_convert_outputs_to_writes(</span>
    <span class="s1">nsteps: int</span><span class="s3">, </span><span class="s1">jaxpr: core.Jaxpr</span><span class="s3">, </span><span class="s1">loop_invar_res: Sequence[bool]</span>
    <span class="s1">) -&gt; Tuple[core.Jaxpr</span><span class="s3">, </span><span class="s1">List[core.ShapedArray]]:</span>
  <span class="s3">assert not </span><span class="s1">jaxpr.constvars</span><span class="s3">, </span><span class="s4">&quot;Jaxpr shouldn't have constvars.&quot;</span>

  <span class="s1">in_avals = [v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">jaxpr.invars]  </span><span class="s0"># [i, *orig_ref_avals]</span>
  <span class="s1">@lu.wrap_init</span>
  <span class="s3">def </span><span class="s1">eval_jaxpr(i</span><span class="s3">, </span><span class="s1">*refs):</span>
    <span class="s0"># We split the refs into the original input refs and the dummy residual</span>
    <span class="s0"># refs.</span>
    <span class="s1">orig_refs</span><span class="s3">, </span><span class="s1">residual_refs = split_list(refs</span><span class="s3">, </span><span class="s1">[len(in_avals) - </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">residual_vals = core.eval_jaxpr(jaxpr</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">*orig_refs)</span>
    <span class="s3">for </span><span class="s1">res_ref</span><span class="s3">, </span><span class="s1">res_val</span><span class="s3">, </span><span class="s1">loop_invar </span><span class="s3">in </span><span class="s1">zip(residual_refs</span><span class="s3">, </span><span class="s1">residual_vals</span><span class="s3">,</span>
                                            <span class="s1">loop_invar_res):</span>
      <span class="s3">if </span><span class="s1">loop_invar:</span>
        <span class="s1">res_ref[()] = res_val</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">res_ref[i] = res_val</span>
    <span class="s3">return </span><span class="s1">[]</span>
  <span class="s0"># TODO(mattjj, sharadmv): better handling of tokens, which don't have shape/dtype</span>
  <span class="s1">res_ref_avals: List[core.AbstractValue] = [</span>
      <span class="s1">AbstractRef(v.aval) </span><span class="s3">if </span><span class="s1">loop_invar </span><span class="s3">else  </span><span class="s0"># pytype: disable=attribute-error</span>
      <span class="s1">AbstractRef(core.ShapedArray((nsteps</span><span class="s3">, </span><span class="s1">*v.aval.shape)</span><span class="s3">,  </span><span class="s0"># pytype: disable=attribute-error</span>
                  <span class="s1">v.aval.dtype))  </span><span class="s0"># pytype: disable=attribute-error</span>
      <span class="s3">for </span><span class="s1">v</span><span class="s3">, </span><span class="s1">loop_invar </span><span class="s3">in </span><span class="s1">zip(jaxpr.outvars</span><span class="s3">, </span><span class="s1">loop_invar_res)]</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">consts = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">eval_jaxpr</span><span class="s3">, </span><span class="s1">[*in_avals</span><span class="s3">, </span><span class="s1">*res_ref_avals])</span>
  <span class="s3">assert not </span><span class="s1">consts</span>
  <span class="s3">return </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">[core.ShapedArray(a.shape</span><span class="s3">, </span><span class="s1">a.dtype) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">res_ref_avals]  </span><span class="s0"># pytype: disable=attribute-error</span>

<span class="s3">def </span><span class="s1">_convert_inputs_to_reads(</span>
    <span class="s1">nsteps: int</span><span class="s3">, </span><span class="s1">num_res: int</span><span class="s3">, </span><span class="s1">jaxpr: core.Jaxpr</span><span class="s3">,</span>
    <span class="s1">loop_invar_res: Sequence[bool]) -&gt; core.Jaxpr:</span>
  <span class="s3">assert not </span><span class="s1">jaxpr.constvars</span><span class="s3">, </span><span class="s4">&quot;Jaxpr should not have constvars&quot;</span>

  <span class="s1">@lu.wrap_init</span>
  <span class="s3">def </span><span class="s1">eval_jaxpr(i</span><span class="s3">, </span><span class="s1">*refs):</span>
    <span class="s1">residual_refs</span><span class="s3">, </span><span class="s1">orig_refs = split_list(refs</span><span class="s3">, </span><span class="s1">[num_res])</span>
    <span class="s1">residual_vals = [r[()] </span><span class="s3">if </span><span class="s1">loop_invar </span><span class="s3">else </span><span class="s1">r[i] </span><span class="s3">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">loop_invar</span>
                     <span class="s3">in </span><span class="s1">zip(residual_refs</span><span class="s3">, </span><span class="s1">loop_invar_res)]</span>
    <span class="s1">() = core.eval_jaxpr(jaxpr</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">*residual_vals</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">*orig_refs)</span>
    <span class="s3">return </span><span class="s1">[]</span>

  <span class="s1">res_val_avals</span><span class="s3">, </span><span class="s1">(i_aval</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">orig_ref_avals = \</span>
      <span class="s1">split_list([v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">jaxpr.invars]</span><span class="s3">, </span><span class="s1">[num_res</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
  <span class="s1">res_ref_avals: List[core.AbstractValue] = [</span>
      <span class="s1">AbstractRef(aval) </span><span class="s3">if </span><span class="s1">loop_invar </span><span class="s3">else  </span><span class="s0"># pytype: disable=attribute-error</span>
      <span class="s1">AbstractRef(core.ShapedArray((nsteps</span><span class="s3">, </span><span class="s1">*aval.shape)</span><span class="s3">,  </span><span class="s0"># pytype: disable=attribute-error</span>
                  <span class="s1">aval.dtype))  </span><span class="s0"># pytype: disable=attribute-error</span>
      <span class="s3">for </span><span class="s1">aval</span><span class="s3">, </span><span class="s1">loop_invar </span><span class="s3">in </span><span class="s1">zip(res_val_avals</span><span class="s3">, </span><span class="s1">loop_invar_res)]</span>

  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">() = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">eval_jaxpr</span><span class="s3">, </span><span class="s1">[i_aval</span><span class="s3">, </span><span class="s1">*res_ref_avals</span><span class="s3">, </span><span class="s1">*orig_ref_avals])</span>
  <span class="s3">return </span><span class="s1">jaxpr</span>

<span class="s3">def </span><span class="s1">transpose_jaxpr(jaxpr: core.Jaxpr</span><span class="s3">, </span><span class="s1">which_linear: List[bool]) -&gt; core.Jaxpr:</span>
  <span class="s3">def </span><span class="s1">trans(i</span><span class="s3">, </span><span class="s1">*args):</span>
    <span class="s0"># First we want to run the computation to read all the residual refs. We can</span>
    <span class="s0"># do that by using partial evaluation with all linear inputs unknown.</span>
    <span class="s1">res_jaxpr</span><span class="s3">, </span><span class="s1">tangent_jaxpr_</span><span class="s3">, </span><span class="s1">*_ = \</span>
        <span class="s1">_partial_eval_jaxpr_custom(jaxpr</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False, </span><span class="s1">*which_linear]</span><span class="s3">,</span>
                                   <span class="s1">_save_everything)</span>
    <span class="s1">res_args = [x </span><span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lin </span><span class="s3">in </span><span class="s1">zip(args</span><span class="s3">, </span><span class="s1">which_linear) </span><span class="s3">if not </span><span class="s1">lin]</span>
    <span class="s1">res = core.eval_jaxpr(res_jaxpr</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">*res_args)</span>

    <span class="s0"># Now that we have residual values, we run the tangent jaxpr. It takes as</span>
    <span class="s0"># input the residuals, the loop index, and all the refs (at least, the ones</span>
    <span class="s0"># that are used in the body). Luckily, `tangent_jaxpr_` has all known and</span>
    <span class="s0"># unknown inputs!</span>
    <span class="s1">tangent_jaxpr</span><span class="s3">, </span><span class="s1">used = pe.dce_jaxpr(tangent_jaxpr_</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">used_res</span><span class="s3">, </span><span class="s1">(used_i</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">used_ct = split_list(used</span><span class="s3">, </span><span class="s1">[len(res)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">primals_args = [*(r </span><span class="s3">for </span><span class="s1">u</span><span class="s3">, </span><span class="s1">r </span><span class="s3">in </span><span class="s1">zip(used_res</span><span class="s3">, </span><span class="s1">res) </span><span class="s3">if </span><span class="s1">u)]</span>
    <span class="s3">if </span><span class="s1">used_i:</span>
      <span class="s1">primals_args = [*primals_args</span><span class="s3">, </span><span class="s1">i]</span>
    <span class="s1">ct_args = [x </span><span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">u </span><span class="s3">in </span><span class="s1">zip(args</span><span class="s3">, </span><span class="s1">used_ct) </span><span class="s3">if </span><span class="s1">u]</span>
    <span class="s1">ad.backward_pass(</span>
        <span class="s1">tangent_jaxpr</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, False, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">(*primals_args</span><span class="s3">, </span><span class="s1">*ct_args)</span><span class="s3">, </span><span class="s1">())</span>
    <span class="s3">return </span><span class="s1">[]</span>
  <span class="s1">jaxpr_trans</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = pe.trace_to_jaxpr_dynamic(</span>
      <span class="s1">lu.wrap_init(trans)</span><span class="s3">, </span><span class="s1">[v.aval </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">jaxpr.invars])</span>
  <span class="s3">return </span><span class="s1">jaxpr_trans</span>

<span class="s3">def </span><span class="s1">_for_transpose(in_cts</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">, </span><span class="s1">which_linear</span><span class="s3">, </span><span class="s1">unroll):</span>
  <span class="s0"># if any in_ct is nonzero, we definitely want it in args_ (and the</span>
  <span class="s0"># corresponding x in args could be an undefined primal, but doesnt have to be)</span>
  <span class="s0"># for non-res stuff:</span>
  <span class="s0">#   getting and setting =&gt; (nonzero ct, UndefinedPrimal arg)</span>
  <span class="s0">#   just setting =&gt;        (nonzero ct, not UndefinedPrimal, dummy value)</span>
  <span class="s0">#   just getting =&gt;        (zero ct   , UndefinedPrimal arg)</span>
  <span class="s0"># for res stuff:</span>
  <span class="s0">#                          (zero ct   , not UndefinedPrimal)</span>
  <span class="s1">args_ = []</span>
  <span class="s1">which_linear_transpose = []</span>
  <span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">ct </span><span class="s3">in </span><span class="s1">zip(args</span><span class="s3">, </span><span class="s1">in_cts):</span>
    <span class="s3">if   </span><span class="s1">type(ct) </span><span class="s3">is     </span><span class="s1">ad_util.Zero </span><span class="s3">and not </span><span class="s1">ad.is_undefined_primal(x):</span>
      <span class="s0"># this is a residual, take x!</span>
      <span class="s1">args_.append(x)</span>
      <span class="s1">which_linear_transpose.append(</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">type(ct) </span><span class="s3">is     </span><span class="s1">ad_util.Zero </span><span class="s3">and     </span><span class="s1">ad.is_undefined_primal(x):</span>
      <span class="s0"># the loop was 'just getting', plug in a zero</span>
      <span class="s1">args_.append(ad_util.zeros_like_aval(x.aval))</span>
      <span class="s1">which_linear_transpose.append(</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">type(ct) </span><span class="s3">is not </span><span class="s1">ad_util.Zero </span><span class="s3">and not </span><span class="s1">ad.is_undefined_primal(x):</span>
      <span class="s0"># the loop was 'just setting', grab that cotangent! x is dummy</span>
      <span class="s1">args_.append(ct)</span>
      <span class="s1">which_linear_transpose.append(</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">type(ct) </span><span class="s3">is not </span><span class="s1">ad_util.Zero </span><span class="s3">and     </span><span class="s1">ad.is_undefined_primal(x):</span>
      <span class="s0"># the loop was 'getting and setting', grab that cotangent!</span>
      <span class="s1">args_.append(ct)</span>
      <span class="s1">which_linear_transpose.append(</span><span class="s3">True</span><span class="s1">)</span>

  <span class="s1">jaxpr_transpose = transpose_jaxpr(jaxpr</span><span class="s3">, </span><span class="s1">which_linear)</span>
  <span class="s3">assert </span><span class="s1">len(args_) == len(jaxpr_transpose.invars) - </span><span class="s5">1</span>
  <span class="s1">all_outs = for_p.bind(*args_</span><span class="s3">, </span><span class="s1">jaxpr=jaxpr_transpose</span><span class="s3">, </span><span class="s1">nsteps=nsteps</span><span class="s3">,</span>
                        <span class="s1">reverse=</span><span class="s3">not </span><span class="s1">reverse</span><span class="s3">,</span>
                        <span class="s1">which_linear=tuple(which_linear_transpose)</span><span class="s3">,</span>
                        <span class="s1">unroll=unroll)</span>
  <span class="s1">ct_outs = [ct </span><span class="s3">if </span><span class="s1">ad.is_undefined_primal(x) </span><span class="s3">else None</span>
             <span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">ct </span><span class="s3">in </span><span class="s1">zip(args</span><span class="s3">, </span><span class="s1">all_outs)]</span>
  <span class="s3">return </span><span class="s1">ct_outs</span>
<span class="s1">ad.primitive_transposes[for_p] = _for_transpose</span>

<span class="s0">### Testing utility</span>

<span class="s3">def </span><span class="s1">discharged_for_loop(nsteps</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">init_state</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">reverse: bool = </span><span class="s3">False</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;A `for_loop` implementation that discharges its body right away. 
 
  Potentially useful for testing and benchmarking. 
  &quot;&quot;&quot;</span>
  <span class="s1">flat_state</span><span class="s3">, </span><span class="s1">state_tree = tree_flatten(init_state)</span>
  <span class="s1">state_avals = map(val_to_ref_aval</span><span class="s3">, </span><span class="s1">flat_state)</span>
  <span class="s1">idx_aval = core.ShapedArray(()</span><span class="s3">, </span><span class="s1">jnp.dtype(</span><span class="s4">&quot;int32&quot;</span><span class="s1">))</span>
  <span class="s1">jaxpr</span><span class="s3">, </span><span class="s1">consts</span><span class="s3">, </span><span class="s1">out_tree = _trace_to_jaxpr_with_refs(</span>
      <span class="s1">body</span><span class="s3">, </span><span class="s1">state_tree</span><span class="s3">, </span><span class="s1">[idx_aval</span><span class="s3">, </span><span class="s1">*state_avals])</span>
  <span class="s3">if </span><span class="s1">out_tree != tree_structure(</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">raise </span><span class="s1">Exception(</span><span class="s4">&quot;`body` should not return anything.&quot;</span><span class="s1">)</span>
  <span class="s1">discharged_jaxpr</span><span class="s3">, </span><span class="s1">discharged_consts = discharge_state(jaxpr</span><span class="s3">, </span><span class="s1">consts)</span>

  <span class="s3">def </span><span class="s1">fori_body(i</span><span class="s3">, </span><span class="s1">carry):</span>
    <span class="s1">i = jnp.int32(i)</span>
    <span class="s3">if </span><span class="s1">reverse:</span>
      <span class="s1">i = nsteps - i - </span><span class="s5">1</span>
    <span class="s1">out_flat = core.eval_jaxpr(discharged_jaxpr</span><span class="s3">, </span><span class="s1">discharged_consts</span><span class="s3">,</span>
                               <span class="s1">i</span><span class="s3">, </span><span class="s1">*carry)</span>
    <span class="s3">return </span><span class="s1">out_flat</span>
  <span class="s1">out_flat = loops.fori_loop(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nsteps</span><span class="s3">, </span><span class="s1">fori_body</span><span class="s3">, </span><span class="s1">flat_state)</span>
  <span class="s3">return </span><span class="s1">tree_unflatten(state_tree</span><span class="s3">, </span><span class="s1">out_flat)</span>

<span class="s3">def </span><span class="s1">run_state(f</span><span class="s3">, </span><span class="s1">init_state):</span>
  <span class="s1">@functools.wraps(f)</span>
  <span class="s3">def </span><span class="s1">wrapped_body(_</span><span class="s3">, </span><span class="s1">*args):</span>
    <span class="s3">return </span><span class="s1">f(*args)</span>
  <span class="s3">return </span><span class="s1">for_loop(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">wrapped_body</span><span class="s3">, </span><span class="s1">init_state)</span>
</pre>
</body>
</html>